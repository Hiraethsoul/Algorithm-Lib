## 子序列问题
### 最长上升/下降/不升/不降子序列（LIS）
我们用![image](https://cdn.nlark.com/yuque/__latex/9a4b19897e03daeb7e8beeecf02e82cc.svg)的二分做法即可

### 最长公共子序列（LCS）
我们有三种考虑

![image](https://cdn.nlark.com/yuque/__latex/56efd6d97976bd4b9489e073616adfcb.svg)首先暴力二维![image](https://cdn.nlark.com/yuque/__latex/cdaf04cddf57ae63edeafceb53eb4044.svg)在![image](https://cdn.nlark.com/yuque/__latex/023710761254052f2b1fdef291bd2c43.svg)的时间内可以做到求任意两前缀的![image](https://cdn.nlark.com/yuque/__latex/17409b6c27c5a4a1c82f9d5734f93349.svg)

![image](https://cdn.nlark.com/yuque/__latex/4b61aa9ca965e7caa9057c4f4e68b0e5.svg)如果某一个串的字符不重复，我们可以对两个串进行重构，我们记不会重复的串为![image](https://cdn.nlark.com/yuque/__latex/de951302f41d4707b9d80ca1af34dd0f.svg)，我们按![image](https://cdn.nlark.com/yuque/__latex/de951302f41d4707b9d80ca1af34dd0f.svg)的字母顺序给![image](https://cdn.nlark.com/yuque/__latex/54f5fb1b07a88521e7b036e3bc7a5e33.svg)重新编号，把![image](https://cdn.nlark.com/yuque/__latex/54f5fb1b07a88521e7b036e3bc7a5e33.svg)中未出现在![image](https://cdn.nlark.com/yuque/__latex/de951302f41d4707b9d80ca1af34dd0f.svg)中的字符全删掉，求![image](https://cdn.nlark.com/yuque/__latex/54f5fb1b07a88521e7b036e3bc7a5e33.svg)的![image](https://cdn.nlark.com/yuque/__latex/788ab98bd68fdc917445c8fa71a92be8.svg)即可。

1. ![image](https://cdn.nlark.com/yuque/__latex/49acbb6a1d1b916894d09aa694c628e2.svg)(源自![image](https://cdn.nlark.com/yuque/__latex/09f40ce9bfda2fd611779c0a4019c80a.svg)算法的优化)

我们考虑压位，这样可以优化到![image](https://cdn.nlark.com/yuque/__latex/534b222e8569cd80a44f7e966ec7431c.svg)的复杂度，具体的说

我们不妨设主串![image](https://cdn.nlark.com/yuque/__latex/de951302f41d4707b9d80ca1af34dd0f.svg)，副串![image](https://cdn.nlark.com/yuque/__latex/54f5fb1b07a88521e7b036e3bc7a5e33.svg)，我们用![image](https://cdn.nlark.com/yuque/__latex/6bec5bf43c9924bf5006e907b643f00c.svg)个长度为![image](https://cdn.nlark.com/yuque/__latex/4760e2f007e23d820825ba241c47ce3b.svg)的![image](https://cdn.nlark.com/yuque/__latex/759411de49355c93f91977786e8ef4a6.svg)来记录每个字符在![image](https://cdn.nlark.com/yuque/__latex/e3e6ace30a115e42cae3163d49bdf119.svg)串中出现的位置，然后遍历![image](https://cdn.nlark.com/yuque/__latex/de951302f41d4707b9d80ca1af34dd0f.svg)串，我们记前驱![image](https://cdn.nlark.com/yuque/__latex/759411de49355c93f91977786e8ef4a6.svg)向量（长度为![image](https://cdn.nlark.com/yuque/__latex/4760e2f007e23d820825ba241c47ce3b.svg)）为![image](https://cdn.nlark.com/yuque/__latex/32ed5e9e580d123173ac55ad90458209.svg),初始为空，对于当前遍历到的字符![image](https://cdn.nlark.com/yuque/__latex/c8b70bd0be64af603972b820f6ab3878.svg)，我们考虑它对应的![image](https://cdn.nlark.com/yuque/__latex/759411de49355c93f91977786e8ef4a6.svg),我们记当前的![image](https://cdn.nlark.com/yuque/__latex/db6004a1f5b2723ffd8e3fceb7479c6c.svg)，我们记![image](https://cdn.nlark.com/yuque/__latex/1d61fd6ff119f09e2d8ac00cd47a4875.svg),然后使![image](https://cdn.nlark.com/yuque/__latex/83433c22a04b691e172da577b94e964d.svg),此时的![image](https://cdn.nlark.com/yuque/__latex/60ceb24b0e75fa2b0add57c0eab3fe61.svg)即为遍历到![image](https://cdn.nlark.com/yuque/__latex/2443fbcfeb7e85e1d62b6f5e4f27207e.svg)时的答案向量，然后调用![image](https://cdn.nlark.com/yuque/__latex/99a2bc150257e41e05c2beefc1d9466b.svg)即可



需要注意的是![image](https://cdn.nlark.com/yuque/__latex/759411de49355c93f91977786e8ef4a6.svg)减法为二进制向量意义上的减法，而![image](https://cdn.nlark.com/yuque/__latex/7042270128eb118e427c52e0d41f5dac.svg)表示取反，由于![image](https://cdn.nlark.com/yuque/__latex/759411de49355c93f91977786e8ef4a6.svg)不支持减法，我们手动模拟即可。

```cpp
using u64 = unsigned long long;
// 64 位块数表示的 bitset LCS（Hunt–Szymanski 的 bit-parallel 实现）
// 时间 O(|a| * ((|b|+63)/64)), 空间 O(26 * blocks)
int LCS(const std::string &a, const std::string &b)
{
    int n = (int)a.size(), m = (int)b.size();
    if (n == 0 || m == 0)
        return 0;

    int W = (m + 63) / 64; // 每个 bitset 需要的 u64 个数
    std::vector pos(26, std::vector<u64>(W, 0ULL));

    // 构造 pos：pos[c] 在 b 中字符 c 出现位置的位图
    for (int j = 0; j < m; ++j)
    {
        int c = b[j] - 'a';
        pos[c][j >> 6] |= (1ULL << (j & 63));
    }

    std::vector<u64> dp(W, 0ULL), U(W), V(W), SUB(W);
    // 最后一块只保留到 m 的有效位
    u64 last_mask = (m % 64 == 0) ? ~0ULL : ((1ULL << (m % 64)) - 1ULL);

    for (char ch : a)
    {
        int idx = ch - 'a';

        // U = dp | pos[idx]
        for (int i = 0; i < W; ++i)
            U[i] = dp[i] | pos[idx][i];

        // V = (dp << 1) | 1
        u64 carry = 0;
        for (int i = 0; i < W; ++i)
        {
            u64 next_carry = dp[i] >> 63;
            V[i] = (dp[i] << 1) | carry;
            carry = next_carry;
        }
        V[0] |= 1ULL; // 设置最低位

        // SUB = U - V （多块减法，考虑借位）
        unsigned long long borrow = 0ULL;
        for (int i = 0; i < W; ++i)
        {
            // 使用 128 位临时避免加法溢出
            unsigned __int128 v_with_borrow = (unsigned __int128)V[i] + (unsigned __int128)borrow;
            u64 v64 = (u64)v_with_borrow;
            // 结果块
            u64 res = (u64)((unsigned __int128)U[i] - v_with_borrow);
            SUB[i] = res;
            // 产生新的借位当且仅当 v_with_borrow > U[i]
            borrow = (v_with_borrow > (unsigned __int128)U[i]) ? 1ULL : 0ULL;
        }

        // dp = U & ~SUB
        for (int i = 0; i < W; ++i)
            dp[i] = U[i] & ~SUB[i];
        // 清除最后块中超出 m 的位
        dp[W - 1] &= last_mask;
    }

    // 统计 dp 中 1 的个数就是 LCS 长度
    int ans = 0;
    for (int i = 0; i < W; ++i)
        ans += __builtin_popcountll(dp[i]);
    return ans;
}
```

## 自然数划分问题
我们考虑求![image](https://cdn.nlark.com/yuque/__latex/df378375e7693bdcf9535661c023c02e.svg)个自然数总和为![image](https://cdn.nlark.com/yuque/__latex/4760e2f007e23d820825ba241c47ce3b.svg)的方案数

我们不妨设![image](https://cdn.nlark.com/yuque/__latex/d3fc864b0dd57dbb911feb0a2ec94eb6.svg)表示选了![image](https://cdn.nlark.com/yuque/__latex/2443fbcfeb7e85e1d62b6f5e4f27207e.svg)个数字总和为![image](https://cdn.nlark.com/yuque/__latex/036441a335dd85c838f76d63a3db2363.svg)的方案数

### 可重复
![image](https://cdn.nlark.com/yuque/__latex/de0ce2bf88ec1f8061ca36e639f80663.svg)

我们按![image](https://cdn.nlark.com/yuque/__latex/df378375e7693bdcf9535661c023c02e.svg)个数字是否有![image](https://cdn.nlark.com/yuque/__latex/53072c2388d69edc65c2377681e4e87c.svg)来讨论

如果有至少一个![image](https://cdn.nlark.com/yuque/__latex/53072c2388d69edc65c2377681e4e87c.svg)，那么![image](https://cdn.nlark.com/yuque/__latex/d3fc864b0dd57dbb911feb0a2ec94eb6.svg)可以由![image](https://cdn.nlark.com/yuque/__latex/03702cfa64e8086a83e8b7eec0e14756.svg)转移而来，表示我们这一轮选![image](https://cdn.nlark.com/yuque/__latex/53072c2388d69edc65c2377681e4e87c.svg)

如果没有![image](https://cdn.nlark.com/yuque/__latex/53072c2388d69edc65c2377681e4e87c.svg)，那么![image](https://cdn.nlark.com/yuque/__latex/d3fc864b0dd57dbb911feb0a2ec94eb6.svg)可以从![image](https://cdn.nlark.com/yuque/__latex/7f57933e9e4c0a5c5b4d95ec3f1867e2.svg)转移而来，意思是我们把选的每一个数都手动加上![image](https://cdn.nlark.com/yuque/__latex/53072c2388d69edc65c2377681e4e87c.svg)

因此转移式为![image](https://cdn.nlark.com/yuque/__latex/71ae37d1955f1b0b04d30bc273c68b25.svg)

复杂度![image](https://cdn.nlark.com/yuque/__latex/023710761254052f2b1fdef291bd2c43.svg)

![image](https://cdn.nlark.com/yuque/__latex/4b61aa9ca965e7caa9057c4f4e68b0e5.svg)

五边形数定理（![image](https://cdn.nlark.com/yuque/__latex/8a41560ecbe8fafce870a62aad563e5e.svg)）

```cpp
std::vector<int> calc(int n)
{
    std::vector<long long> a(n), p(n);
    p[0] = 1;
    p[1] = 1;
    p[2] = 2;
    for (int i = 1; i < n; i++) /*递推式系数1,2,5,7,12,15,22,26...i*(3*i-1)/2,i*(3*i+1)/2*/
    {
        a[2 * i] = 1ll * i * (i * 3 - 1) / 2; /*五边形数为1,5,12,22...i*(3*i-1)/2*/
        a[2 * i + 1] = 1ll * i * (i * 3 + 1) / 2;
    }
    for (int i = 3; i < n; i++) /*p[n]=p[n-1]+p[n-2]-p[n-5]-p[n-7]+p[12]+p[15]-...+p[n-i*[3i-1]/2]+p[n-i*[3i+1]/2]*/
    {
        for (int j = 2; a[j] <= i; j++)
        {
            p[i] += (j & 2) ? 1 : -1 * p[i - a[j]];
            norm(p[j]);
        }
    }
    return p;
}
```

### 不可重复
我们仍然用同样的讨论思路

如果要恰有一个![image](https://cdn.nlark.com/yuque/__latex/53072c2388d69edc65c2377681e4e87c.svg)，那么我们这一轮选![image](https://cdn.nlark.com/yuque/__latex/53072c2388d69edc65c2377681e4e87c.svg)并且让之前的数字都加![image](https://cdn.nlark.com/yuque/__latex/53072c2388d69edc65c2377681e4e87c.svg)，也就是![image](https://cdn.nlark.com/yuque/__latex/b7fd3362424e2b3f7e2aa1b59bf649f4.svg)

如果要没有![image](https://cdn.nlark.com/yuque/__latex/53072c2388d69edc65c2377681e4e87c.svg)，我们直接让之前数字都加![image](https://cdn.nlark.com/yuque/__latex/53072c2388d69edc65c2377681e4e87c.svg)即可，也就是![image](https://cdn.nlark.com/yuque/__latex/7f57933e9e4c0a5c5b4d95ec3f1867e2.svg)

转移式为![image](https://cdn.nlark.com/yuque/__latex/658e1cb3c55d9db57f27a841a89c3d65.svg)

复杂度![image](https://cdn.nlark.com/yuque/__latex/8a41560ecbe8fafce870a62aad563e5e.svg)

## 背包DP
### 多重背包 (单调队列优化)
```cpp
auto multiBag(std::vector<std::array<int, 3>> &goods, int S)
{
    // S 总背包大小
    std::vector<i64> f(S + 1, 0);
    std::vector<int> q(S + 2, 0);
    for (auto [v, w, m] : goods)
    {
        // v价值, w体积, m数量
        auto calc = [&](int i, int j)
        {
            return f[j] + 1ll * (i - j) / w * v;
        };
        for (int up = S; up + w > S; up--)
        {
            int l = 1, r = 0, k = up;
            for (int x = up; x > 0; x -= w)
            {
                for (; k >= std::max(0ll, x - 1ll * m * w); k -= w)
                {
                    while (l <= r and calc(x, k) > calc(x, q[r]))
                        r--;
                    q[++r] = k;
                }
                f[x] = calc(x, q[l]);
                if (q[l] == x)
                    l++;
            }
        }
    }
    return f;
}
```

### 树上背包
思路往往是考虑每条边的贡献 在上下界优化后复杂度为![image](https://cdn.nlark.com/yuque/__latex/f2d5f588234eb61a559ff90c41511b85.svg)

我们在每次转移的时候都开一个临时数组![image](https://cdn.nlark.com/yuque/__latex/dd2c210bcbca2a070159bd50e3628a2f.svg)，目的是防止从同一个子树内重复转移状态

```cpp
template <class T>
class PackageOnTree
{
    const T inf = std::numeric_limits<T>::max() / 2;

public:
    std::vector<std::vector<T>> dp;
    void addEdge(int u, int v, T w)
    {
        g[u].emplace_back(v, w);
        g[v].emplace_back(u, w);
    }

    PackageOnTree(int n, int m, int root) : n(n), g(n + 1), siz(n + 1), infCapacity(m), root(root)
    {
        dp.resize(n + 1, std::vector<T>(m + 1));
    }

    void work()
    {
        dfs(root, 0);
    }

private:
    int infCapacity;
    int n, root;
    std::vector<std::vector<std::pair<int, T>>> g;
    std::vector<int> siz;
    T calc(int u, T w, int cnt) // u子树内选cnt个点 父边权值为w
    {
        return w * (cnt * (infCapacity - cnt) + (siz[u] - cnt) * (n - infCapacity - (siz[u] - cnt)));
    }
    void dfs(int u, int fa)
    {
        dp[u][0] = 0;
        siz[u] = 1;
        for (auto [v, w] : g[u])
        {
            if (v == fa)
            {
                continue;
            }
            dfs(v, u);
            siz[u] += siz[v];
            std::vector<T> temp(std::min(siz[u], infCapacity) + 1, 0);
            for (int j = std::min(infCapacity, siz[u]); j >= 0; --j)
            {
                for (int k = std::max(0ll, siz[v] + j - siz[u]); k <= std::min(siz[v], j); ++k)
                {
                    temp[j] = std::max(temp[j], dp[u][j - k] + dp[v][k] + calc(v, w, k));
                }
            }
            for (int j = 0; j <= std::min(siz[u], infCapacity); ++j)
            {
                dp[u][j] = temp[j];
            }
        }
    }
};
```

## 区间DP
区间DP往往都是![image](https://cdn.nlark.com/yuque/__latex/a77815a52a2d0050828079fb142b1410.svg)的复杂度，且操作方式相对单一，我们外层先枚举区间长度，内层枚举左端点，由于长度已知，那么右端点已知，我们枚举中间点转移状态，转移式形如![image](https://cdn.nlark.com/yuque/__latex/6da8751d31ac2d575363c67140639125.svg),![image](https://cdn.nlark.com/yuque/__latex/611704a0dd22673c878a72abcdc2bda2.svg)为左右端点

## 单调队列优化
DP状态一般为![image](https://cdn.nlark.com/yuque/__latex/7696df7a07d92c087b9d0d42b29b42df.svg)

不难发现是个滑动窗口问题，单调队列优化即可

## 决策单调性优化
### 二维形式（2D）
一般二维的决策单调性DP往往是![image](https://cdn.nlark.com/yuque/__latex/17865270736abf0ab1ef9ec3373c4f38.svg) 

不难发现这种情况的决策单调性来自层与层之间，因为我们的转移也来自不同层

#### 分治做法
我们可以用分治的方法解决该问题，即我们先遍历求出该层mid处的最优决策点 然后递归两边即可 复杂度![image](https://cdn.nlark.com/yuque/__latex/1b11889500e81caaab6b3af3415a9602.svg) ![image](https://cdn.nlark.com/yuque/__latex/70f935b7f95ae3ff5685726be0e7ea38.svg)为层数

```cpp
template <class T>
class OptimizeDP
{
    const T inf = std::numeric_limits<T>::max() / 2;

public:
    std::vector<std::vector<T>> dp;
    int n, dep;
    OptimizeDP(int n, int k) : n(n), dep(k)
    {
        dp.assign(n + 1, std::vector<T>(k + 1, 0));
        for (int j = 1; j <= k; ++j)
        // 由于转移是层与层之间的 所以我们可以选择分支
        {
            work(1, n, 1, n, j);
        }
    }

private:
    T calcW(int l, int r)
    {
        // 这里我们可以使用正常计算

        // 我们这里可以考虑使用莫队计算 可以证明复杂度是正确的
    }
    void work(int l, int r, int L, int R, int dep) // l和r是求解区间  L,R是决策区间
    {
        if (l > r)
        {
            return;
        }
        int mid = l + r >> 1;
        T maxVal = 0, transferPoint = -1;
        // 找最大值和转移点
        for (int i = std::min(R, mid); i >= L; --i)
        {
            if (dp[i - 1][dep - 1] + calcW(i + 1, mid) > maxVal)
            {
                maxVal = dp[i - 1][dep - 1] + calcW(i + 1, mid);
                transferPoint = i;
            }
        }
        dp[mid][dep] = maxVal;
        work(l, mid - 1, L, transferPoint, dep); // 根据决策单调性优化
        work(mid + 1, r, transferPoint, R, dep);
    }
};
```

#### 二分队列做法
我们同样可以用二分队列的方法解决，具体的说我们开一个三元组队列 队列中![image](https://cdn.nlark.com/yuque/__latex/0cb78f7a1a7d5032c33a31aeebf1d433.svg)

表示区间在![image](https://cdn.nlark.com/yuque/__latex/14bf570f8741f316e21ac3f44bd353fb.svg)的转移最优决策点为![image](https://cdn.nlark.com/yuque/__latex/036441a335dd85c838f76d63a3db2363.svg),我们只需要动态维护该队列即可 

具体的说 我们每次把![image](https://cdn.nlark.com/yuque/__latex/545b9d021c18ab9c5641d29c73dff461.svg)的过时元素弹出, 并把队头的![image](https://cdn.nlark.com/yuque/__latex/6945e109777fe3fd777e8254f0ec0f0c.svg)改为![image](https://cdn.nlark.com/yuque/__latex/2443fbcfeb7e85e1d62b6f5e4f27207e.svg)，更新当前位置![image](https://cdn.nlark.com/yuque/__latex/2443fbcfeb7e85e1d62b6f5e4f27207e.svg)的答案。

然后把队尾过时的元素弹出,如果一个元素在![image](https://cdn.nlark.com/yuque/__latex/6945e109777fe3fd777e8254f0ec0f0c.svg)处转移仍然没有当前位置![image](https://cdn.nlark.com/yuque/__latex/2443fbcfeb7e85e1d62b6f5e4f27207e.svg)更优 它就是过时的。

接下来我们取出队尾，我们二分找出一个![image](https://cdn.nlark.com/yuque/__latex/c4b4aed21f876065eeb9187248d57f19.svg)满足![image](https://cdn.nlark.com/yuque/__latex/924fb68453c8740d82f25f56a904934d.svg)时队尾元素更优，![image](https://cdn.nlark.com/yuque/__latex/1f7303b852597747e43a39c1f1fea489.svg)时![image](https://cdn.nlark.com/yuque/__latex/2443fbcfeb7e85e1d62b6f5e4f27207e.svg)更优 ，更新队列即可

复杂度仍为![image](https://cdn.nlark.com/yuque/__latex/8b4697df25d099ea276195e7f89dc959.svg)![image](https://cdn.nlark.com/yuque/__latex/df976ff7fcf17d60490267d18a1e3996.svg)为层数

```cpp
template <class T>
class OptimizeDP
{
    const T inf = std::numeric_limits<T>::max() / 2;

public:
    std::vector<std::vector<T>> dp;
    OptimizeDP(int n, int k) : n(n), dep(k)
    {
        dp.assign(n + 1, std::vector<T>(k + 1, inf));
        dp[0][0] = 0;
    }

    void work(int d)
    {
        std::vector<std::array<int, 3>> q(n + 1);
        //{j,l,r}表示在[l,r]内的最优转移点为j
        int hh = 1, tt = 0;
        q[++tt] = {0, 1, n}; // 初始化
        for (int i = 1; i <= n; ++i)
        {
            while (hh < tt and q[hh][2] < i) // 队头已经过时
            {
                ++hh;
            }
            q[hh][1] = i; // 把队头左端点改为i
            int k = q[hh][0];
            dp[i][d] = dp[k][d - 1] + getW(k + 1, i); // 转移

            // 如果队尾的决策点转移到l  从d转移的结果不如i 就不断弹出
            while (hh < tt and getDP(q[tt][0], q[tt][1], d - 1) >= getDP(i, q[tt][1], d - 1))
            {
                --tt;
            }
            q[tt][2] = n;                   // 队尾的右端点始终为n
            int l = q[tt][1], r = q[tt][2]; // 二分找到一个位置 后面从i转移更优 前面由tt转移更优
            int pos = n + 1;
            while (l <= r)
            {
                int mid = l + r >> 1;
                if (getDP(q[tt][0], mid, d - 1) >= getDP(i, mid, d - 1)) // i更优
                {
                    r = mid - 1;
                    pos = mid;
                }
                else
                {
                    l = mid + 1;
                }
            }
            if (pos != n + 1)
            {
                q[tt][2] = pos - 1;
                q[++tt] = {i, pos, n};
            }
        }
    }

private:
    int n, dep;
    T getW(int l, int r)
    {
    }
    T getDP(int l, int r, int d) // 层数为d 从l转移到r的值
    {
        return dp[l][d] + getW(l + 1, r);
    }
};
```

### 一维形式（1D）
一般一维形式的决策单调性DP往往是 

![image](https://cdn.nlark.com/yuque/__latex/6c61c4792ddd51d0279f73006382fc94.svg)

满足决策单调性即 当![image](https://cdn.nlark.com/yuque/__latex/7fc512199b8ebbeb7362770223336d51.svg)

不难发现这种情况的决策单调性来自同层之间，因为转移来自同层



此时我们将只能选择二分队列做法，因为决策单调性我们是从每层的mid开始更新，但是我们发现1D形式是同层转移，在我们求mid时![image](https://cdn.nlark.com/yuque/__latex/10b51ac762c771e6115c586a877ba832.svg)处的![image](https://cdn.nlark.com/yuque/__latex/32ed5e9e580d123173ac55ad90458209.svg)值未知，因此无法分治

#### 二分队列做法
具体做法完全和2D的二分队列类似，只不过此时我们只需跑一层的转移

复杂度![image](https://cdn.nlark.com/yuque/__latex/4fdce66a3ca18398b05c1efc03c7aa4f.svg)

```cpp
template <class T>
class OptimizeDP
{
    const T inf = std::numeric_limits<T>::max() / 2;

public:
    std::vector<T> dp;
    OptimizeDP(int n) : n(n)
    {
        dp.assign(n + 1, inf);
        dp[0] = 0;
        work();
    }

    void work()
    {
        std::vector<std::array<int, 3>> q(n + 1);
        //{j,l,r}表示在[l,r]内的最优转移点为j
        int hh = 1, tt = 0;
        q[++tt] = {0, 1, n}; // 初始化
        for (int i = 1; i <= n; ++i)
        {
            while (hh < tt and q[hh][2] < i) // 队头已经过时
            {
                ++hh;
            }
            q[hh][1] = i; // 把队头左端点改为i
            int k = q[hh][0];
            dp[i] = dp[k] + getW(k + 1, i); // 转移

            // 如果队尾的决策点转移到l  从d转移的结果不如i 就不断弹出
            while (hh < tt and getDP(q[tt][0], q[tt][1]) >= getDP(i, q[tt][1]))
            {
                --tt;
            }
            q[tt][2] = n;                   // 队尾的右端点始终为n
            int l = q[tt][1], r = q[tt][2]; // 二分找到一个位置 后面从i转移更优 前面由tt转移更优
            int pos = n + 1;
            while (l <= r)
            {
                int mid = l + r >> 1;
                if (getDP(q[tt][0], mid) >= getDP(i, mid)) // i更优
                {
                    r = mid - 1;
                    pos = mid;
                }
                else
                {
                    l = mid + 1;
                }
            }
            if (pos != n + 1)
            {
                q[tt][2] = pos - 1;
                q[++tt] = {i, pos, n};
            }
        }
    }

private:
    int n;
    T getW(int l, int r)
    {
    }
    T getDP(int l, int r) // 层数为d 从l转移到r的值
    {
        return dp[l] + getW(l + 1, r);
    }
};
```

## 斜率优化
斜率优化是一种特殊的优化DP 其往往表达式为 

![image](https://cdn.nlark.com/yuque/__latex/0ac6a89828b534a38f464d698c30cb67.svg)

我们稍作变形 ![image](https://cdn.nlark.com/yuque/__latex/f2cb42eea315fdc5929a5735cd959438.svg)

我们把![image](https://cdn.nlark.com/yuque/__latex/87d87d84dc175ba39fce2ecce45bb6a8.svg)

那么该式子满足![image](https://cdn.nlark.com/yuque/__latex/cfb745a7fd25a2078a4297a66157699e.svg)

我们想要![image](https://cdn.nlark.com/yuque/__latex/1ff45c94a6ba0831adaf6758bf9232cf.svg) 等价于让b![image](https://cdn.nlark.com/yuque/__latex/00a1827dcf655845e5ff31b3bb5d5105.svg)



我们不难发现我们转移的每个![image](https://cdn.nlark.com/yuque/__latex/72f89366bece32fb94026b3d54d6ae07.svg)都对应着一组![image](https://cdn.nlark.com/yuque/__latex/a969cab25db24b7b40ddd3064d3ab658.svg) 也就是说在![image](https://cdn.nlark.com/yuque/__latex/df976ff7fcf17d60490267d18a1e3996.svg)确定的情况下

我们从很多个![image](https://cdn.nlark.com/yuque/__latex/a969cab25db24b7b40ddd3064d3ab658.svg)中选择一组使得转移最优



我们推式子看看什么样的![image](https://cdn.nlark.com/yuque/__latex/a969cab25db24b7b40ddd3064d3ab658.svg)最优 我们以求min为例![image](https://cdn.nlark.com/yuque/__latex/bfb2feb41ab6e2f7a509edc3c37873f7.svg)

我们分情况讨论 



当![image](https://cdn.nlark.com/yuque/__latex/7db4cee9e74865ab082228d786b31d61.svg)存在单调性时 

也就是说![image](https://cdn.nlark.com/yuque/__latex/e944e418428f25baa86d07412aed4ff4.svg)成立的情况下 ![image](https://cdn.nlark.com/yuque/__latex/686db005de512a3bbce4c42caf0820da.svg)

 但是新加点时我们如何决策呢 假如说我们出现了一种情况

![](https://cdn.nlark.com/yuque/0/2024/png/43183165/1728473984518-17135305-9a47-4380-a99e-5824890fd947.png)

我们通过分类讨论可以证明在这种情况下![image](https://cdn.nlark.com/yuque/__latex/036441a335dd85c838f76d63a3db2363.svg)点永远不会成为最优决策点 我们直接弹出即可

有了这个条件，我们发现维护的队列点集将是一个上凸壳

也就是说队列里的折线斜率单调增加 

那么我们可以再分两种情况 

如果我们的斜率k也单调增加 那么我们发现队头的一些点将会逐渐过时 ，我们不断弹出即可，因此可以单调队列维护 简单来说就是x和k均单调时可以用单调队列维护

### 斜率优化(单调队列)
```cpp
template <class T>
class OptimizeDP
{
    const T inf = std::numeric_limits<T>::max() / 2;

public:
    std::vector<T> dp;
    OptimizeDP(int n) : n(n)
    {
        dp.assign(n + 1, inf);
        dp[0] = 0;
        work();
    }

    void work()
    {
        int hh = 0, tt = -1;
        std::vector<int> q(n + 1, 0);
        q[++tt] = 0;
        for (int i = 1; i <= n; ++i)
        {
            int k = calcK(i);
            while (hh < tt and calcSlope(q[hh], q[hh + 1]) <= k)
            {
                ++hh;
            }
            int j = q[hh]; // 最优转移点
            dp[i] = dp[j] + calcVal(i, j);
            while (hh < tt and calcSlope(q[tt], i) <= calcSlope(q[tt - 1], q[tt]))
            {
                --tt;
            }
            q[++tt] = i;
        }
    }

private:
    int n;

    T calcX(int x)
    {
    }
    T calcY(int x)
    {
    }
    T calcK(int x)
    {
    }
    long double calcSlope(int l, int r)
    {
        if (calcX(r) == calcX(l))
        {
            return inf; // 最大值
        }
        return (long double)((calcY(r) - calcY(l)) / (1.0 * (calcX(r) - calcX(l))));
    }
    T calcVal(int i, int j)
    {
    }
};
```



但是假如说我们的k不再单调时，我们将不再能弹出队头，因为我无法预知我们的最优决策点将在哪里出现，于是我们要保留所有的决策点并使其斜率单调，每次在队列里二分找到最优决策点

### **斜率优化(二分队列)**
```cpp
template <class T>
class OptimizeDP
{
    const T inf = std::numeric_limits<T>::max() / 2;

public:
    std::vector<T> dp;

    OptimizeDP(int n) : n(n)
    {
        dp.assign(n + 1, inf);
        dp[0] = 0;
        work();
    }

    void work()
    {
        int hh = 0, tt = -1;
        std::vector<int> q(n + 1, 0);
        q[++tt] = 0;
        auto findOptimizePoint = [&](int l, int r, int k)
        {
            int ans = r;
            while (l <= r)
            {
                int mid = l + r >> 1;
                if (calcSlope(q[mid], q[mid + 1]) > k)
                {
                    r = mid - 1;
                    ans = mid;
                }
                else
                {
                    l = mid + 1;
                }
            }
            return q[ans];
        };

        for (int i = 1; i <= n; ++i)
        {
            int k = calcK(i);
            int j = findOptimizePoint(1, tt, k); // 在队列里二分找决策点
            dp[i] = dp[j] + calcVal(i, j);
            while (hh < tt and calcSlope(q[tt], i) <= calcSlope(q[tt - 1], q[tt]))
            {
                --tt;
            }
            q[++tt] = i;
        }
    }

private:
    int n;

    T calcX(int x)
    {
    }
    T calcY(int x)
    {
    }
    T calcK(int x)
    {
    }
    long double calcSlope(int l, int r)
    {
        if (calcX(r) == calcX(l))
        {
            return inf; // 最大值
        }
        return (long double)((calcY(r) - calcY(l)) / (1.0 * (calcX(r) - calcX(l))));
    }
    T calcVal(int i, int j)
    {
    }
};
```

当![image](https://cdn.nlark.com/yuque/__latex/712ecf7894348e92d8779c3ee87eeeb0.svg)不存在单调性时，我们的问题将会变的十分麻烦,我们可能需要动态操作凸包，或者利用平衡树，CDQ分治等高级数据结构来维护凸包。

当然我们认为在这种情况下李超线段树可能会成为更好的选择。

## **WQS二分/带权二分优化**
在图论中的最小度限制生成树已经有所涉及，WQS二分能解决的问题往往是在![image](https://cdn.nlark.com/yuque/__latex/df378375e7693bdcf9535661c023c02e.svg)个物品中强制选![image](https://cdn.nlark.com/yuque/__latex/4760e2f007e23d820825ba241c47ce3b.svg)个的最优方案。我们假设![image](https://cdn.nlark.com/yuque/__latex/a6e46ba474c5eb884b3e13555a14cd3a.svg)表示选![image](https://cdn.nlark.com/yuque/__latex/4760e2f007e23d820825ba241c47ce3b.svg)个的最优答案，那么![image](https://cdn.nlark.com/yuque/__latex/1be19cb61ab417aec435bb6276deba0a.svg)二分的使用条件是离散数点函数![image](https://cdn.nlark.com/yuque/__latex/a6e46ba474c5eb884b3e13555a14cd3a.svg)具有凸性，换句话说![image](https://cdn.nlark.com/yuque/__latex/a6e46ba474c5eb884b3e13555a14cd3a.svg)的轮廓构成一个凸壳。具有凸性在数学上的定义为二阶导数恒为正或者恒为负，在几何上的体现就是，对于数点![image](https://cdn.nlark.com/yuque/__latex/bf83270ee75ffd814d96982e1f638072.svg)构成的图像，相邻两点斜率![image](https://cdn.nlark.com/yuque/__latex/54e4eda099f2a73584d1f31821048d04.svg)单调。



对于![image](https://cdn.nlark.com/yuque/__latex/cdaf04cddf57ae63edeafceb53eb4044.svg)的优化在于，此类问题往往可能通过![image](https://cdn.nlark.com/yuque/__latex/ad7f67bfdbefd23a51aa287b5439a512.svg)表示考虑前![image](https://cdn.nlark.com/yuque/__latex/2443fbcfeb7e85e1d62b6f5e4f27207e.svg)个物品选了![image](https://cdn.nlark.com/yuque/__latex/036441a335dd85c838f76d63a3db2363.svg)个的最优结果，在不考虑转移的情况下复杂度为![image](https://cdn.nlark.com/yuque/__latex/023710761254052f2b1fdef291bd2c43.svg),那么如果我们使用![image](https://cdn.nlark.com/yuque/__latex/9586800f4c2c5c7dd06bc499bcbc9da6.svg)二分复杂度可以降为![image](https://cdn.nlark.com/yuque/__latex/61c96cff452e0502059edd2afad1d52b.svg)

在几何上来分析：由于凸壳的斜率单调，我们考虑二分斜率去做凸壳的切线，每条切线都会和凸壳上一个特定的点相切，当切线斜率![image](https://cdn.nlark.com/yuque/__latex/6a6b811a2879516d7418f3d7325a142d.svg)单调时，切点所对应![image](https://cdn.nlark.com/yuque/__latex/712ecf7894348e92d8779c3ee87eeeb0.svg)的坐标也单调，假设我们的切线为![image](https://cdn.nlark.com/yuque/__latex/378a1b3c4cc62e63c5c66edadf0ce5b4.svg)，那么其中的![image](https://cdn.nlark.com/yuque/__latex/bf98c0ddcbe9c1e535f767c78c3aa813.svg)即为![image](https://cdn.nlark.com/yuque/__latex/576f7e879ab6d65902c62101062f694f.svg)，![image](https://cdn.nlark.com/yuque/__latex/712ecf7894348e92d8779c3ee87eeeb0.svg)即为![image](https://cdn.nlark.com/yuque/__latex/cead1760d9d5723460c4b8d4028f113a.svg)，那么式子变为![image](https://cdn.nlark.com/yuque/__latex/23d3339c4f29d398721d90f22a8574c1.svg),当然我们目前并不知道![image](https://cdn.nlark.com/yuque/__latex/cead1760d9d5723460c4b8d4028f113a.svg)是谁。

我们考虑求出![image](https://cdn.nlark.com/yuque/__latex/d29c2e5f4926e5b0e9a95305650f6e54.svg)，那么![image](https://cdn.nlark.com/yuque/__latex/95b7497944aa528dbd5f84aed1b2f053.svg)，这个式子具有的实际意义是理解的关键。

我们不妨假设我们已经知道![image](https://cdn.nlark.com/yuque/__latex/cead1760d9d5723460c4b8d4028f113a.svg)，那么式子的意义是在选定![image](https://cdn.nlark.com/yuque/__latex/cead1760d9d5723460c4b8d4028f113a.svg)个的情况下，把这![image](https://cdn.nlark.com/yuque/__latex/c63044f420b043d8cb76d93a061887bd.svg)个元素对应的权值都减掉![image](https://cdn.nlark.com/yuque/__latex/df976ff7fcf17d60490267d18a1e3996.svg)。那我们怎么通过![image](https://cdn.nlark.com/yuque/__latex/df976ff7fcf17d60490267d18a1e3996.svg)反向求出![image](https://cdn.nlark.com/yuque/__latex/cead1760d9d5723460c4b8d4028f113a.svg)呢？我们把所有相关元素的值提前减掉![image](https://cdn.nlark.com/yuque/__latex/df976ff7fcf17d60490267d18a1e3996.svg)，然后跑朴素的![image](https://cdn.nlark.com/yuque/__latex/cdaf04cddf57ae63edeafceb53eb4044.svg)（不限制选多少个）求出此刻选多少个最优，以及最优解为多少，那么此刻选的数量即为![image](https://cdn.nlark.com/yuque/__latex/cead1760d9d5723460c4b8d4028f113a.svg)，最优解即为![image](https://cdn.nlark.com/yuque/__latex/d29c2e5f4926e5b0e9a95305650f6e54.svg),我们所求的![image](https://cdn.nlark.com/yuque/__latex/166a3f759d17fa6bbdb73afeb2c32ed6.svg)，当然这里的![image](https://cdn.nlark.com/yuque/__latex/c63044f420b043d8cb76d93a061887bd.svg)可能并不是我们想要的，但我们可以根据单调性去二分调整![image](https://cdn.nlark.com/yuque/__latex/df976ff7fcf17d60490267d18a1e3996.svg)的值，从而找到我们想要的![image](https://cdn.nlark.com/yuque/__latex/c63044f420b043d8cb76d93a061887bd.svg)对应的答案。

## 动态DP
我们定义广义矩阵乘法![image](https://cdn.nlark.com/yuque/__latex/2a592340af65c1834af9486061e69f81.svg)为![image](https://cdn.nlark.com/yuque/__latex/a93fe947c62634a47b47116960ba0b5e.svg)

我们考虑一类从左至右的![image](https://cdn.nlark.com/yuque/__latex/cdaf04cddf57ae63edeafceb53eb4044.svg)，不妨假设为![image](https://cdn.nlark.com/yuque/__latex/7eec37d36ce3fcc91bd860091bb1a43c.svg)

不难发现该转移式可以用广义矩阵乘法意义下的矩阵表示

由于矩阵满足从左到右的运算性质，因此满足结合律，用线段树维护区间矩阵乘即可，在此条件下可以满足单点修改的要求

![image](https://cdn.nlark.com/yuque/__latex/bd99fb5ab2c9486e9b38c5fc19206e01.svg)*![image](https://cdn.nlark.com/yuque/__latex/fdaee19580cca86c9628c3910ff2154b.svg)=![image](https://cdn.nlark.com/yuque/__latex/23ea5d765aa04d10abff81c962115a0b.svg)

请注意 在修改矩阵乘法定义后，单位矩阵已经改变

对于运算法则为![image](https://cdn.nlark.com/yuque/__latex/29468c76b632feadaaf0fd5db45c5d8d.svg)的广义矩阵乘，单位矩阵![image](https://cdn.nlark.com/yuque/__latex/df53f70d20a6a901dfd6da9f6986b470.svg)满足，如果![image](https://cdn.nlark.com/yuque/__latex/06f0d21da13a826b3c106db3e08c7527.svg)，![image](https://cdn.nlark.com/yuque/__latex/abaf61adff95616bcf5d9c11f6eddb22.svg),否则![image](https://cdn.nlark.com/yuque/__latex/c5e250e46846ca8ceb887f9883e968cb.svg) 

对于运算法则为![image](https://cdn.nlark.com/yuque/__latex/c492bc675ad017c33ebc507318d822bb.svg)的广义矩阵乘，单位矩阵![image](https://cdn.nlark.com/yuque/__latex/df53f70d20a6a901dfd6da9f6986b470.svg)满足，如果![image](https://cdn.nlark.com/yuque/__latex/06f0d21da13a826b3c106db3e08c7527.svg)，![image](https://cdn.nlark.com/yuque/__latex/abaf61adff95616bcf5d9c11f6eddb22.svg),否则![image](https://cdn.nlark.com/yuque/__latex/185c1d1af2764405b4016b6d556b838e.svg) 

## 状压DP
### SOSDP（子集和DP）
实际上是解决一类问题，就是说对于所有的![image](https://cdn.nlark.com/yuque/__latex/43f29ed0282e34fd96b8dd4ac3668d56.svg)，要求出![image](https://cdn.nlark.com/yuque/__latex/c13869a9bd07227fcfef94eaa7ac26af.svg)

我们暴力的做法是对每个数都枚举子集，复杂度是![image](https://cdn.nlark.com/yuque/__latex/b2c4ac56090b70a950a65344712e9ff8.svg)

这里给出枚举子集的代码

```cpp
 for (int s = 0; s < (1 << n);++s)
    {
        for (int t = s, T = t; T; T = (T - 1) & t) // init为要枚举的对象
        {
            // 对应的子集为T
            dp[s] += dp[T];
        }
    }
```

然后我们发现每次枚举都经过了很多次同样的位置，我们想到对这些位置统一处理，也就是只经过一次

那么我们可以写出SOSDP优化后的代码

```cpp
for (int j = 0; j < n; ++j)
{
    for (int i = 0; i < (1 << n); ++i)
    {
        if (i >> j & 1)
        {
            dp[i] += dp[i ^ (1 << j)];
        }
    }
}
```

当然我们不局限于求子集，也可以做到求超集，也可以从原数向子集DP等等

## 数位DP
我们发现数位DP的一般形式为按位考虑，然后综合考虑所有限制情况来DP

我们用记忆化搜索的方法搞定数位DP，我们给出一般形参的可能情况



以下为记忆化搜索函数![image](https://cdn.nlark.com/yuque/__latex/3554585ecb04a4bf73b5938d239b0fe5.svg)的常设定的形参

+ <font style="color:rgb(25, 27, 31);"></font>![image](https://cdn.nlark.com/yuque/__latex/c4b4aed21f876065eeb9187248d57f19.svg)<font style="color:rgb(25, 27, 31);">:int</font><font style="color:rgb(25, 27, 31);">型变量，表示当前枚举的位置，一般从高到低</font>
+ ![image](https://cdn.nlark.com/yuque/__latex/1d9aa58c802831be26cab67bbd1dc9ed.svg)<font style="color:rgb(25, 27, 31);">：</font><font style="color:rgb(25, 27, 31);">bool</font><font style="color:rgb(25, 27, 31);">型变量，表示枚举的第</font>![image](https://cdn.nlark.com/yuque/__latex/c4b4aed21f876065eeb9187248d57f19.svg)<font style="color:rgb(25, 27, 31);">位是否受到</font><font style="color:rgb(25, 27, 31);">限制</font><font style="color:rgb(25, 27, 31);">，</font>
    - <font style="color:rgb(25, 27, 31);">为true表示取的数不能大于</font>![image](https://cdn.nlark.com/yuque/__latex/f916cd5ffbcda7dbb9810b3092c2a1a6.svg)<font style="color:rgb(25, 27, 31);">，而只有在</font>![image](https://cdn.nlark.com/yuque/__latex/8f4d170a7d2ee53b3e053d5269be0abb.svg)<font style="color:rgb(25, 27, 31);">的位置上填写的数都等于</font>![image](https://cdn.nlark.com/yuque/__latex/f916cd5ffbcda7dbb9810b3092c2a1a6.svg)<font style="color:rgb(25, 27, 31);">时该值才为true</font>
    - <font style="color:rgb(25, 27, 31);">否则表示当前位没有限制，可以取到</font><font style="color:rgb(25, 27, 31);">[0,k−1]</font><font style="color:rgb(25, 27, 31);">，因为</font>![image](https://cdn.nlark.com/yuque/__latex/df976ff7fcf17d60490267d18a1e3996.svg)<font style="color:rgb(25, 27, 31);">进制的数中数位最多能取到的就是</font>![image](https://cdn.nlark.com/yuque/__latex/df976ff7fcf17d60490267d18a1e3996.svg)<font style="color:rgb(25, 27, 31);">−1</font>
+ ![image](https://cdn.nlark.com/yuque/__latex/c0a0aac306bfd34228692a6442cb1cb2.svg)<font style="color:rgb(25, 27, 31);">：</font><font style="color:rgb(25, 27, 31);">int</font><font style="color:rgb(25, 27, 31);">型变量，表示上一位（第</font>![image](https://cdn.nlark.com/yuque/__latex/c4b4aed21f876065eeb9187248d57f19.svg)<font style="color:rgb(25, 27, 31);">+1</font><font style="color:rgb(25, 27, 31);">位）填写的值</font>
    - <font style="color:rgb(25, 27, 31);">往往用于约束了相邻数位之间的关系的题目</font>
+ ![image](https://cdn.nlark.com/yuque/__latex/af54ffdcf52fd7fa6f348525f2f444bc.svg)<font style="color:rgb(25, 27, 31);">：</font><font style="color:rgb(25, 27, 31);">bool</font><font style="color:rgb(25, 27, 31);">型变量，表示是否有</font><font style="color:rgb(25, 27, 31);">前导零</font><font style="color:rgb(25, 27, 31);">，即在</font>![image](https://cdn.nlark.com/yuque/__latex/b3a83f2cda0f662e3eb121e0d06d2f7f.svg)<font style="color:rgb(25, 27, 31);">→</font>![image](https://cdn.nlark.com/yuque/__latex/c351e025ac9e9b919d11c15c2f7da132.svg)<font style="color:rgb(25, 27, 31);">这些位置是不是都是</font><font style="color:rgb(25, 27, 31);">前导零</font>
    - <font style="color:rgb(25, 27, 31);">基于常识，我们往往默认一个数没有前导零，也就是最高位不能为0，即不会写为</font><font style="color:rgb(25, 27, 31);">000123</font><font style="color:rgb(25, 27, 31);">，而是写为</font><font style="color:rgb(25, 27, 31);">123</font>
    - <font style="color:rgb(25, 27, 31);">只有没有前导零的时候，才能计算</font><font style="color:rgb(25, 27, 31);">0</font><font style="color:rgb(25, 27, 31);">的贡献。</font>
    - <font style="color:rgb(25, 27, 31);">那么前导零何时跟答案有关？</font>
        * <font style="color:rgb(25, 27, 31);">统计0的出现次数</font>
        * <font style="color:rgb(25, 27, 31);">相邻数字的差值</font>
        * <font style="color:rgb(25, 27, 31);">以最高位为起点确定的奇偶位</font>
+ ![image](https://cdn.nlark.com/yuque/__latex/5d9e8c2483c4833aa0f798fca42487db.svg)<font style="color:rgb(25, 27, 31);">：</font><font style="color:rgb(25, 27, 31);">int</font><font style="color:rgb(25, 27, 31);">型变量，表示当前</font>![image](https://cdn.nlark.com/yuque/__latex/b3a83f2cda0f662e3eb121e0d06d2f7f.svg)<font style="color:rgb(25, 27, 31);">→</font>![image](https://cdn.nlark.com/yuque/__latex/c351e025ac9e9b919d11c15c2f7da132.svg)<font style="color:rgb(25, 27, 31);">的数位和</font>
+ ![image](https://cdn.nlark.com/yuque/__latex/72cb3a229067770aeb6caa625a65a1a1.svg)<font style="color:rgb(25, 27, 31);">：</font><font style="color:rgb(25, 27, 31);">int</font><font style="color:rgb(25, 27, 31);">型变量，表示整个数前缀取模某个数</font>![image](https://cdn.nlark.com/yuque/__latex/4760e2f007e23d820825ba241c47ce3b.svg)<font style="color:rgb(25, 27, 31);">的余数</font>
    - <font style="color:rgb(25, 27, 31);">该参数一般会用在：约束中出现了能被</font>![image](https://cdn.nlark.com/yuque/__latex/4760e2f007e23d820825ba241c47ce3b.svg)<font style="color:rgb(25, 27, 31);">整除</font>
    - <font style="color:rgb(25, 27, 31);">当然也可以拓展为数位和取模的结果</font>
+ ![image](https://cdn.nlark.com/yuque/__latex/94543bea5eaa6202457626ae7588d1da.svg)<font style="color:rgb(25, 27, 31);">：</font><font style="color:rgb(25, 27, 31);">int</font><font style="color:rgb(25, 27, 31);">型变量，用于状态压缩</font>
    - <font style="color:rgb(25, 27, 31);">对一个集合的数在数位上的出现次数的奇偶性有要求时，其二进制形式就可以表示每个数出现的奇偶性</font>

```cpp
class DigitDP
{

public:
    DigitDP(int infLength, int base) : a(infLength + 1), base(base) 
    {
        f.assign();//视题目而定
    }

    int solve(int l, int r)
    {
        return calc(r) - calc(l - 1);
    }

private:
    std::vector<int> a;
    std::vector f;//开几个维度视情况而定
    int base;//进制基数
    // pos是第几位 我们从高到低枚举 0为递归出口 limit表示这一位是否受限制  lead0表示前面是否都为前导0
    // r表示len位之前的数modp的余数 last表示上一个数字
    void dfs(int pos, int limit, int lead0, int r, int last, int sum)
    {
        if (pos == 0)
        {
            if (满足条件)
            {
                return 1 or sum; // 1是数量  sum是该数字的属性
            }
        }
        if (!limit and f[pos][][] != -1)
        {
            // 不受限制且后面的结果已经求得
            return f[pos][][];
        }
        int up = limit ? a[pos] : base - 1; // 数字的上限
        int res = 0;
        for (int i = 0; i <= up; ++i)
        {
            if (lead0 and i == 0) // 考虑全都是0会怎么样
            {
                res += dfs(pos - 1, limit and i == up, lead0 and i == 0, .......);
            }
            else
            {
                if (满足条件)
                {
                    res += dfs(pos - 1, limit and i == up, lead0 and i == 0, .......);
                }
            }
        }
        if (!limit) // 不受限制
        {
            f[pos][][] = res;
        }
        return res;
    }
    int calc(int x)
    {
        int len = 0;
        while (x)
        {
            a[++len] = x % base; // k是进制数 一般为10或者2
            x /= base;
        }
        return dfs(len, 1, ......); // 数位dp 记忆化搜索过程 形参因题而定
    }

}

```

## 树形DP
### 换根DP
首先换根DP分两种情况，边换根和点换根。

边换根DP并不常见，且处理手法类似，我们主要考虑点换根DP。

然后我们又有两种思考方式来做换根DP

一种是两次![image](https://cdn.nlark.com/yuque/__latex/ab9beef7db741e3cc3445e9070df572e.svg)用一个数组，最终的![image](https://cdn.nlark.com/yuque/__latex/cdaf04cddf57ae63edeafceb53eb4044.svg)数组即为答案

另一种是两次![image](https://cdn.nlark.com/yuque/__latex/dedd23652415728bc1016a87e6dd0cc2.svg)分别用一个数组，其中![image](https://cdn.nlark.com/yuque/__latex/472c29b832d88446163c485a60c71f0b.svg)表示以![image](https://cdn.nlark.com/yuque/__latex/0a25ff5d5f49aeb7283b1b06cf5b55d5.svg)为根子树内的答案,![image](https://cdn.nlark.com/yuque/__latex/217df4193db511a542916d44ffcffabc.svg)表示以![image](https://cdn.nlark.com/yuque/__latex/77c3adce895348f6083c425fe1ba2624.svg)为根子树外的答案，我们将两个数组拼接之后才是真正的答案

#### 前后缀积优化
其实是一个常见的换根DP Trick，也就是说当我们的DP转移如果是关于子树的乘积并涉及取模时，我们换根难免会涉及到除法以及乘法逆元，但当mod数不是质数时逆元不存在，或者说求逆元的值取模后为![image](https://cdn.nlark.com/yuque/__latex/22d0feea96d3bb2fc273f7598ce748c1.svg)。我们将无法处理这个问题，于是我们考虑不再做除法，而是利用前后缀积来优化这个问题。

我们以转移式为![image](https://cdn.nlark.com/yuque/__latex/0def30fe89f9f46978b2e9bb142f783e.svg)为例子

```cpp
template <class T>
class PreSufOptimizeDP
{
public:
    std::vector<T> dp;
    PreSufOptimizeDP(std::vector<std::vector<int>> &g) : g(g), dp(g.size()), pre(g.size()), suf(g.size())
    {
        dfs1(1, 0);
        dfs2(1, 0);
    }

private:
    std::vector<std::vector<int>> g;
    std::vector<std::vector<T>> pre, suf;

    void dfs1(int u, int fa)
    {
        dp[u] = 1;
        pre[u].push_back(1);
        for (auto v : g[u])
        {
            if (v == fa)
            {
                continue;
            }
            dfs1(v, u);
            dp[u] = dp[u] * (dp[v] + 1);
            pre[u].push_back(dp[v] + 1);
            suf[u].push_back(dp[v] + 1);
        }
        suf[u].push_back(1);
        for (int i = 1; i < pre[u].size(); ++i)
        {
            pre[u][i] = pre[u][i] * pre[u][i - 1];
        }
        for (int i = suf[u].size() - 2; i >= 0; --i)
        {
            suf[u][i] = suf[u][i] * suf[u][i + 1];
        }
    }
    //  dp[v]=dp[v]*(dp[u]/(dp[v]+1)+1);
    void dfs2(int u, int fa)
    {
        int idx = 0;
        for (auto v : g[u])
        {
            if (v == fa)
            {
                continue;
            }
            dp[v] = dp[v] * (pre[u][idx] * suf[u][idx + 1] + 1);
            ++idx;
            dfs2(v, u);
        }
    }
};
```

## 关于DP后效性的解决思路
我们的![image](https://cdn.nlark.com/yuque/__latex/cdaf04cddf57ae63edeafceb53eb4044.svg)方程有时候并不能直接递推，他们的转移可能存在环路，这类问题的解决方法一般是把![image](https://cdn.nlark.com/yuque/__latex/cdaf04cddf57ae63edeafceb53eb4044.svg)式子当做方程，通过待定系数法或高斯消元法解决

### 待定系数法
待定系数法最最经典的应用是树上随机游走问题，因为每次随机游走既能走到儿子，又能走到父节点，因此![image](https://cdn.nlark.com/yuque/__latex/cdaf04cddf57ae63edeafceb53eb4044.svg)显然有环.

以一个题目为例，我们从根节点开始,每次随机走向一个邻点,问走到叶子的期望游走次数，那么我们很容易写出转移方程

![image](https://cdn.nlark.com/yuque/__latex/c1ae594e5d65bfe0d9934433978cff99.svg),其中![image](https://cdn.nlark.com/yuque/__latex/15597257932c7632cd491a0957b44bf7.svg)是树上![image](https://cdn.nlark.com/yuque/__latex/7db4cee9e74865ab082228d786b31d61.svg)点的邻域，如果我们把父节点分开，即![image](https://cdn.nlark.com/yuque/__latex/2e467f84a1f598bbca4853800bca0879.svg)

我们设![image](https://cdn.nlark.com/yuque/__latex/a1d49b0bf02fe327f11eda9ade686d45.svg),那么![image](https://cdn.nlark.com/yuque/__latex/f8d3ff368eeb0241a764df296635f3bd.svg),这里![image](https://cdn.nlark.com/yuque/__latex/3008a3591e01a476269965646ce0d0e7.svg)

我们把![image](https://cdn.nlark.com/yuque/__latex/3286b4641404328e5d6cfa57bcc48ea1.svg)代入原![image](https://cdn.nlark.com/yuque/__latex/a4b21aac24e324060119f8c1f9a32b59.svg)式子，解得![image](https://cdn.nlark.com/yuque/__latex/61c2dad2e9066d92249bf39d58c7cdde.svg),我们发现解出的![image](https://cdn.nlark.com/yuque/__latex/7847c47a9e14701ec4e0540e39a1a2d5.svg)只和![image](https://cdn.nlark.com/yuque/__latex/c30c901c44d553a4298085ec031e1c2d.svg)和![image](https://cdn.nlark.com/yuque/__latex/337f15c1149e63a762a585c888a4c7b8.svg)有关，因此我们可以递推求出所有节点的![image](https://cdn.nlark.com/yuque/__latex/df976ff7fcf17d60490267d18a1e3996.svg)和![image](https://cdn.nlark.com/yuque/__latex/e3b1a1ba9d491cc6835e70607ead3750.svg),对于根节点，由于其没有父节点![image](https://cdn.nlark.com/yuque/__latex/7ea26fbe559c675457532683139c2186.svg),求解完成

对于待定系数法的使用，我们并没有特定的标准，只能通过选手自己观察式子特点灵活操作

### 高斯消元法
待定系数法往往只能解决特殊性质的题目，高斯消元则更加朴素，能在![image](https://cdn.nlark.com/yuque/__latex/a77815a52a2d0050828079fb142b1410.svg)时间内解决线性递推的方程组

仍然以一个题目为例：![image](https://cdn.nlark.com/yuque/__latex/df378375e7693bdcf9535661c023c02e.svg)个点![image](https://cdn.nlark.com/yuque/__latex/4760e2f007e23d820825ba241c47ce3b.svg)条边的无向简单连通图,从![image](https://cdn.nlark.com/yuque/__latex/53072c2388d69edc65c2377681e4e87c.svg)号点开始随机游走，到![image](https://cdn.nlark.com/yuque/__latex/df378375e7693bdcf9535661c023c02e.svg)号点时停止，问每个点的期望经过次数。在随机游走中，由于树有极好的性质，我们可以利用待定系数，但图并不具有树的性质，在数据范围允许的情况下，就要考虑高斯消元法

我们写出状态转移方程![image](https://cdn.nlark.com/yuque/__latex/76379c8ed50d5e7bfe5f8e17d4c28fe8.svg),![image](https://cdn.nlark.com/yuque/__latex/6c74a52fe2ae0c5ae377726de64fd4a8.svg),![image](https://cdn.nlark.com/yuque/__latex/3bf707c0cd6141823de7a5e4bb366507.svg)

起点和终点由于其特殊性转移不同，我们发现可以对![image](https://cdn.nlark.com/yuque/__latex/bebac53660c457431fe2934def24e991.svg)的式子进行高斯消元法解出![image](https://cdn.nlark.com/yuque/__latex/d20e38c984dfa040bc8dd22f7aa97d82.svg)个值，从而得到结果

### 带状矩阵高斯消元
是高斯消元法的特殊情况，也就是说，增广矩阵可能具有特殊性质，比如只有一部分区域可能存在非![image](https://cdn.nlark.com/yuque/__latex/22d0feea96d3bb2fc273f7598ce748c1.svg)系数，我们把这类矩阵称作带状矩阵，如果带宽是![image](https://cdn.nlark.com/yuque/__latex/56c1b0cb7a48ccf9520b0adb3c8cb2e8.svg)的话，那么复杂度为![image](https://cdn.nlark.com/yuque/__latex/2ba355c959c4a9c0cfbef5c40dfa6927.svg)






# 组合数学
## 组合数预处理
### 组合数预处理
我们考虑![image](https://cdn.nlark.com/yuque/__latex/e65a67ac353abeeff44c359310d05c02.svg)线性递推预处理出组合数，我们用![image](https://cdn.nlark.com/yuque/__latex/242d6587e294510fe235b9837eed5647.svg)表示阶乘，![image](https://cdn.nlark.com/yuque/__latex/1189ce7c2cc3e1e72082eecc04bdee1c.svg)表示阶乘的逆元，![image](https://cdn.nlark.com/yuque/__latex/22858bd1c8b8ddb2f51c4ec1fdaced86.svg)表示逆元。那么有如下递推式：![image](https://cdn.nlark.com/yuque/__latex/d7aa11340c8872e6ab43615b65c2fa75.svg),![image](https://cdn.nlark.com/yuque/__latex/512ace29bc809c3f964d0c44b0e642b5.svg),![image](https://cdn.nlark.com/yuque/__latex/36b420d4ebac64adad7da047346b9de1.svg)。不难发现我们只要用快速幂求出最后一个![image](https://cdn.nlark.com/yuque/__latex/1189ce7c2cc3e1e72082eecc04bdee1c.svg)的值即可。

```cpp
template <class T, T P>
struct Comb
{
    void norm(ll &x)
    {
        if (x >= P)
        {
            x -= P;
        }
        if (x < 0)
        {
            x += P;
        }
    }
    void norm(int &x)
    {
        if (x >= P)
        {
            x -= P;
        }
        if (x < 0)
        {
            x += P;
        }
    }
    ll mul(ll a, ll b)
    {
        ll res = a * b - (ll)(1.L * a * b / P) * P;
        res %= P;
        norm(res);
        return res;
    }
    int mul(int a, int b)
    {
        int res = 1ll * a * b % P;
        norm(res);
        return res;
    }
    std::vector<T> fac, ifac, inv;
    T power(T a, T b)
    {
        T res = 1;
        while (b)
        {
            if (b & 1)
            {
                res = mul(res, a);
            }
            a = mul(a, a);
            b >>= 1;
        }
        return res;
    }
    T getInv(T a)
    {
        return power(a, P - 2);
    }
    void init(int n)
    {
        fac.resize(n + 1);
        ifac.resize(n + 1);
        inv.resize(n + 1);
        fac[0] = 1; // 从0开始
        for (T i = 1; i <= n; i++)
        {
            fac[i] = mul(i, fac[i - 1]);
        }
        ifac[n] = getInv(fac[n]);
        for (T i = n; i >= 1; i--)
        {
            ifac[i - 1] = mul(i, ifac[i]);
            inv[i] = mul(ifac[i], fac[i - 1]);
        }
    }
    T A(int a, int b)
    {
        return mul(fac[a], ifac[a - b]);
    }
    T C(int a, int b)
    {
        if (a < b or b < 0)
        {
            return 0;
        }
        return mul(A(a, b), ifac[b]);
    }
    Comb(int n)
    {
        init(n);
    }
};
```

### 取模类
```cpp
using i64 = long long;
template <class T>
constexpr T power(T a, i64 b)
{
    T res{1};
    for (; b; b /= 2, a *= a)
    {
        if (b % 2)
        {
            res *= a;
        }
    }
    return res;
}

constexpr i64 mul(i64 a, i64 b, i64 p)
{
    i64 res = a * b - i64(1.L * a * b / p) * p;
    res %= p;
    if (res < 0)
    {
        res += p;
    }
    return res;
}

template <i64 P>
struct MInt
{
    i64 x;
    constexpr MInt() : x{0} {}
    constexpr MInt(i64 x) : x{norm(x % getMod())} {}

    static i64 Mod;
    constexpr static i64 getMod()
    {
        if (P > 0)
        {
            return P;
        }
        else
        {
            return Mod;
        }
    }
    constexpr static void setMod(i64 Mod_)
    {
        Mod = Mod_;
    }
    constexpr i64 norm(i64 x) const
    {
        if (x < 0)
        {
            x += getMod();
        }
        if (x >= getMod())
        {
            x -= getMod();
        }
        return x;
    }
    constexpr i64 val() const
    {
        return x;
    }
    constexpr MInt operator-() const
    {
        MInt res;
        res.x = norm(getMod() - x);
        return res;
    }
    constexpr MInt inv() const
    {
        return power(*this, getMod() - 2);
    }
    constexpr MInt &operator*=(MInt rhs) &
    {
        if (getMod() < (1ULL << 31))
        {
            x = x * rhs.x % (getMod());
        }
        else
        {
            x = mul(x, rhs.x, getMod());
        }
        return *this;
    }
    constexpr MInt &operator+=(MInt rhs) &
    {
        x = norm(x + rhs.x);
        return *this;
    }
    constexpr MInt &operator-=(MInt rhs) &
    {
        x = norm(x - rhs.x);
        return *this;
    }
    constexpr MInt &operator/=(MInt rhs) &
    {
        return *this *= rhs.inv();
    }
    friend constexpr MInt operator*(MInt lhs, MInt rhs)
    {
        MInt res = lhs;
        res *= rhs;
        return res;
    }
    friend constexpr MInt operator+(MInt lhs, MInt rhs)
    {
        MInt res = lhs;
        res += rhs;
        return res;
    }
    friend constexpr MInt operator-(MInt lhs, MInt rhs)
    {
        MInt res = lhs;
        res -= rhs;
        return res;
    }
    friend constexpr MInt operator/(MInt lhs, MInt rhs)
    {
        MInt res = lhs;
        res /= rhs;
        return res;
    }
    friend constexpr std::istream &operator>>(std::istream &is, MInt &a)
    {
        i64 v;
        is >> v;
        a = MInt(v);
        return is;
    }
    friend constexpr std::ostream &operator<<(std::ostream &os, const MInt &a)
    {
        return os << a.val();
    }
    friend constexpr bool operator==(MInt lhs, MInt rhs)
    {
        return lhs.val() == rhs.val();
    }
    friend constexpr bool operator!=(MInt lhs, MInt rhs)
    {
        return lhs.val() != rhs.val();
    }
    friend constexpr bool operator<(MInt lhs, MInt rhs)
    {
        return lhs.val() < rhs.val();
    }
};
template <>
i64 MInt<0>::Mod = 998244353;

constexpr int P = 998244353;
using Z = MInt<P>;

struct Comb
{
    int n;

    std::vector<Z> _fac;
    std::vector<Z> _invfac;
    std::vector<Z> _inv;

    Comb() : n{0}, _fac{1}, _invfac{1}, _inv{0} {}

    Comb(int n) : Comb()
    {
        init(n);
    }

    void init(int m)
    {
        m = std::min<int>(m, Z::getMod() - 1);
        if (m <= n)
            return;
        _fac.resize(m + 1);
        _invfac.resize(m + 1);
        _inv.resize(m + 1);

        for (int i = n + 1; i <= m; i++)
        {
            _fac[i] = _fac[i - 1] * i;
        }
        _invfac[m] = _fac[m].inv();
        for (int i = m; i > n; i--)
        {
            _invfac[i - 1] = _invfac[i] * i;
            _inv[i] = _invfac[i] * _fac[i - 1];
        }
        n = m;
    }

    Z fac(int m)
    {
        if (m > n)
            init(2 * m);
        return _fac[m];
    }
    Z invfac(int m)
    {
        if (m > n)
            init(2 * m);
        return _invfac[m];
    }
    Z inv(int m)
    {
        if (m > n)
            init(2 * m);
        return _inv[m];
    }
    Z A(int a, int b)
    {
        if (a < b or b < 0)
            return 0;
        return fac(a) * invfac(a - b);
    }
    Z C(int n, int m)
    {
        if (n < m || m < 0)
            return 0;
        return fac(n) * invfac(m) * invfac(n - m);
    }
} comb;
```

### 枚举固定大小子集
```cpp
void gospersHack(int n, int k) // 一共n个位 保证其中有k个1
{
    int cur = (1 << k) - 1;
    int limit = 1 << n;
    while (cur < limit)
    {
        std::cerr << cur << '\n';
        // cur是我们想要的数字
        int lb = cur & (-cur);
        int r = cur + lb;
        cur = ((r ^ cur)) >> __builtin_ctz(lb) + 2 | r;
    }
}
```

## 组合恒等式
![image](https://cdn.nlark.com/yuque/__latex/b187acb437322f3f70a13122b4e6e928.svg)

![image](https://cdn.nlark.com/yuque/__latex/96765730709b83729e221f35526759e3.svg)

![image](https://cdn.nlark.com/yuque/__latex/02005cb52ef743b7bafcc5832b7544ce.svg)

![image](https://cdn.nlark.com/yuque/__latex/580c93eab1a18d0ce836aa18c9f19ee0.svg)

![image](https://cdn.nlark.com/yuque/__latex/585910c0778dbc8ec72f1f3c25eb7da1.svg)

![image](https://cdn.nlark.com/yuque/__latex/206dc1462605269c369410f26bfda984.svg)

![image](https://cdn.nlark.com/yuque/__latex/6e227d28c0a40b3f17f1b3e55694b1b2.svg)

![image](https://cdn.nlark.com/yuque/__latex/72b91f6acc0bf52b357e2ce827269ffc.svg)

![image](https://cdn.nlark.com/yuque/__latex/1be5c5426acf0c878683bd3d7176549f.svg)

![image](https://cdn.nlark.com/yuque/__latex/31893cea84b0a04188b7262a1d11f21a.svg)

![image](https://cdn.nlark.com/yuque/__latex/a54df8b4507c27591034ab7f5b40886f.svg)

![image](https://cdn.nlark.com/yuque/__latex/bcb75f7efa5d3b2418b9b959b766f88a.svg)

![image](https://cdn.nlark.com/yuque/__latex/c9575501f5466a9bc6af467c0f12ada4.svg)

![image](https://cdn.nlark.com/yuque/__latex/b1a9593fa8c26e8dc1e22a77fb0846b7.svg)

![image](https://cdn.nlark.com/yuque/__latex/a93c3a6e781e6cc29edf97cb80592d79.svg)

![image](https://cdn.nlark.com/yuque/__latex/e4a05f2fcc64654935f16d1cc9482fb4.svg)

![image](https://cdn.nlark.com/yuque/__latex/7ba366c27c93127c572140dfbd38cd3f.svg)

![image](https://cdn.nlark.com/yuque/__latex/e7615ada63addb47414dc9cd3e02f4dc.svg)

![image](https://cdn.nlark.com/yuque/__latex/31f5fe8ebb7dc75890d20a2edf168682.svg)

![image](https://cdn.nlark.com/yuque/__latex/09ad0f44adc9b43761c68265d51b2cfc.svg)

![image](https://cdn.nlark.com/yuque/__latex/d4503b66b04b873671ec05bf9a5a9d6b.svg)

![image](https://cdn.nlark.com/yuque/__latex/87597ec0cafb93228e7f675c55323910.svg)

## 斯特林数
### 第一类斯特林数
#### 递推公式
![image](https://cdn.nlark.com/yuque/__latex/9470b8a63373c140f046d6904e109a4b.svg)

从组合意义上讲即自己作为一个新的轮换  或者自己插入到已有的人的左边

#### 递推边界
![image](https://cdn.nlark.com/yuque/__latex/3eea0d58a7cc8a9c361735741480c6e8.svg)

### 第二类斯特林数
#### 递推公式
![image](https://cdn.nlark.com/yuque/__latex/fc70490a18f8d914cd47bc902ae419f8.svg)



从组合意义上讲即自己作为一个新的子集  或者自己插入已有的子集中

#### 常用公式
![image](https://cdn.nlark.com/yuque/__latex/22aa3ad347b3451fd45c8205dc9444a0.svg)常用化简 ![image](https://cdn.nlark.com/yuque/__latex/2ce95c8cd540edcd5de30ca6b06b5354.svg)

#### 递推边界
![image](https://cdn.nlark.com/yuque/__latex/a98407a16d737fd4d145292288e288ef.svg)

#### 计算公式
![image](https://cdn.nlark.com/yuque/__latex/968bb757438d4a67030ebb4a9ffe1656.svg)

### 普通幂 下降幂 上升幂互化
![image](https://cdn.nlark.com/yuque/__latex/509b7a8467c1023800cb301e4c6af374.svg) 普通幂转下降幂

![image](https://cdn.nlark.com/yuque/__latex/55d4cc27e18d035fe4d696c94db3d893.svg)下降幂转普通幂

![image](https://cdn.nlark.com/yuque/__latex/50f7de7b7474459a706cb9ed1fd6eaf7.svg)普通幂转上升幂

![image](https://cdn.nlark.com/yuque/__latex/94d15d3ed71b89591be02b23fae4719f.svg)上升幂转普通幂

### 其他斯特林数恒等式
![image](https://cdn.nlark.com/yuque/__latex/619172f258fc282ad7b47468f0c9006d.svg)

![image](https://cdn.nlark.com/yuque/__latex/6ddcdf370743414ae99a0c3eba8c7d9a.svg)

![image](https://cdn.nlark.com/yuque/__latex/d6d4249da3aeccec433ab49a9a82b259.svg)

![image](https://cdn.nlark.com/yuque/__latex/75c6503129f7dbff4210d91344921273.svg)

### 斯特林数 行/列 求和
第二类斯特林数 行 即求出![image](https://cdn.nlark.com/yuque/__latex/326ae7d4eb372491cbab8b968df997c2.svg)

显然公式就是卷积形式 NTT即可



第二类斯特林数 列 即 ![image](https://cdn.nlark.com/yuque/__latex/4ad6069bf8888b0a133300c20e4ca941.svg)

我么考虑设出其生成函数然后递推 ![image](https://cdn.nlark.com/yuque/__latex/64046e13616cfcc32da2ba3abee174c5.svg)

根据递推式我们有 ![image](https://cdn.nlark.com/yuque/__latex/c4937c8137f5df2fbf252d4602d32a05.svg)

那么有![image](https://cdn.nlark.com/yuque/__latex/6cfee8926d7774b07ebf0c2e9b337aae.svg) 也即 ![image](https://cdn.nlark.com/yuque/__latex/cb8f7a122269df7aac1350ec5af80e09.svg)

十分需要注意的是我们需要在分治以后把多项式的![image](https://cdn.nlark.com/yuque/__latex/2225c76ecb18dc7e64ca7ce13d2229bb.svg)重置为![image](https://cdn.nlark.com/yuque/__latex/df976ff7fcf17d60490267d18a1e3996.svg)(开小会![image](https://cdn.nlark.com/yuque/__latex/882d7c35e01d64509b117702f4c11e98.svg))

之后再求逆

第二类斯特林数求和 即![image](https://cdn.nlark.com/yuque/__latex/4a6338642d278ec99d933b1f69b1cad7.svg) 

考虑按公式展开并交换求和次序 即

![image](https://cdn.nlark.com/yuque/__latex/84abe2f8f19b09205b5423acf4e05cbc.svg)     ![image](https://cdn.nlark.com/yuque/__latex/d1b9bfac48fa20fcd851002618f3f2c4.svg)

发现后面是个卷积形式 然后![image](https://cdn.nlark.com/yuque/__latex/9a4b19897e03daeb7e8beeecf02e82cc.svg)求得 ![image](https://cdn.nlark.com/yuque/__latex/e65a67ac353abeeff44c359310d05c02.svg)遍历即可

## 容斥原理
### 容斥原理
我们假设有全集![image](https://cdn.nlark.com/yuque/__latex/55fc237afbe535f7d8434985b848a6a7.svg)，以及![image](https://cdn.nlark.com/yuque/__latex/df378375e7693bdcf9535661c023c02e.svg)个集合![image](https://cdn.nlark.com/yuque/__latex/622715ef41fd2f3ab1627ac04b185d8a.svg),每个集合![image](https://cdn.nlark.com/yuque/__latex/2dc649a10f2cddc4f17e401268418402.svg)中的元素具有性质![image](https://cdn.nlark.com/yuque/__latex/282ff0c1015821da5017765ed7c1e43c.svg),现在我们要求不具有任何性质的集合大小，也就是元素个数，则具有如下的计算式子：

![image](https://cdn.nlark.com/yuque/__latex/9120ba41d5d24c417261c9e538c19522.svg)

当然，我们还具有另一种形式

![image](https://cdn.nlark.com/yuque/__latex/02c8e283222a51f18fd05d0fdfada63c.svg)

形式![image](https://cdn.nlark.com/yuque/__latex/53072c2388d69edc65c2377681e4e87c.svg)：不具备任何性质的元素个数 = 就是元素总个数 − 至少具备一个性质的元素个数之和 + 至少具备两个性质的元素个数知和 − 至少具备三个性质的元素个数之和 ......

形式![image](https://cdn.nlark.com/yuque/__latex/2b89979f54ec02a7bf87aa0c1ea58ff9.svg)：所有集合的并集大小 = 所有集合的大小之和 − 每两个集合之间的交集大小 + 每三个集合之间的交集大小 ...

### 广义容斥原理
用语言描述，容斥原理求的是不满足任何性质的方案数，我们通过计算所有至少满足![image](https://cdn.nlark.com/yuque/__latex/df976ff7fcf17d60490267d18a1e3996.svg)个性质的方案数之和来计算。

同样的，我们可以通过计算所有至少满足![image](https://cdn.nlark.com/yuque/__latex/df976ff7fcf17d60490267d18a1e3996.svg)个性质的方案数之和来计算恰好满足![image](https://cdn.nlark.com/yuque/__latex/df976ff7fcf17d60490267d18a1e3996.svg)个性质的方案数。这样的容斥方法我们称之为广义容斥原理。

首先，我们设![image](https://cdn.nlark.com/yuque/__latex/2f57310e267bd15e28d3ee13759bed4c.svg)代表所有至少满足![image](https://cdn.nlark.com/yuque/__latex/df976ff7fcf17d60490267d18a1e3996.svg)个的性质的方案数之和。

也就是说：

![image](https://cdn.nlark.com/yuque/__latex/c579aca320e0c78e409e1a5f4d7ad211.svg)

![image](https://cdn.nlark.com/yuque/__latex/2c2f15e65cb5e71bb2c5be4968d66e7d.svg)

![image](https://cdn.nlark.com/yuque/__latex/3c8cb6ed698f13ee169bf125b3647d2e.svg)

![image](https://cdn.nlark.com/yuque/__latex/1127a2b8a723f20ad22c2dc6a2c28d5d.svg)

![image](https://cdn.nlark.com/yuque/__latex/fd371b156b138293021def4735e05073.svg)



我们发现![image](https://cdn.nlark.com/yuque/__latex/2f57310e267bd15e28d3ee13759bed4c.svg)将具有![image](https://cdn.nlark.com/yuque/__latex/a4b6abda559b7dfeca66846cc8604008.svg)个性质的元素计算了![image](https://cdn.nlark.com/yuque/__latex/2e723807ba8b4e774c7cc4a99d4714c5.svg)次。

假设![image](https://cdn.nlark.com/yuque/__latex/cbacf3e78f9b6c762ab758966d5d1e3d.svg)代表恰好具有![image](https://cdn.nlark.com/yuque/__latex/df976ff7fcf17d60490267d18a1e3996.svg)个元素的方案数，则有递推公式如下:

![image](https://cdn.nlark.com/yuque/__latex/7e63db55125c9b03ce7f6a64dbb01354.svg)![image](https://cdn.nlark.com/yuque/__latex/6f93cb59b69dac4f83ebe6736ca09c1a.svg)

但是这样计算我们需要求出每一个β的值，时间复杂度是![image](https://cdn.nlark.com/yuque/__latex/f2d5f588234eb61a559ff90c41511b85.svg)的。

我们有一个更好的计算式：

![image](https://cdn.nlark.com/yuque/__latex/ec4f6715b478328bdeed3ab25d88ea2e.svg)

这样就可以![image](https://cdn.nlark.com/yuque/__latex/e65a67ac353abeeff44c359310d05c02.svg)计算单个![image](https://cdn.nlark.com/yuque/__latex/6100158802e722a88c15efc101fc275b.svg)的值了

### 最值反演(min-max容斥）
我们先给出公式 我们设![image](https://cdn.nlark.com/yuque/__latex/55fc237afbe535f7d8434985b848a6a7.svg)为非空集合,![image](https://cdn.nlark.com/yuque/__latex/f37090befaae986233f052b5ff610013.svg)表示集合的最大值，![image](https://cdn.nlark.com/yuque/__latex/dcd91bfcd7bf2230250036ef6f287bb2.svg)表示集合的最小值，![image](https://cdn.nlark.com/yuque/__latex/caec7720f8ef555443bd6e4fbe18c555.svg)表示第![image](https://cdn.nlark.com/yuque/__latex/df976ff7fcf17d60490267d18a1e3996.svg)大的值

然后我们有

![image](https://cdn.nlark.com/yuque/__latex/b3cde9b8c365496be5dab88cddab5fa1.svg)

在min和max相反时也成<font style="color:rgb(97, 104, 124);">立</font>![image](https://cdn.nlark.com/yuque/__latex/fe5b8db1bdf712e0899335bc1ea1e0f0.svg)

我们还可以推广到第![image](https://cdn.nlark.com/yuque/__latex/df976ff7fcf17d60490267d18a1e3996.svg)大的形式

![image](https://cdn.nlark.com/yuque/__latex/2f8dbb7122459cda4a20a4d4d403d6ee.svg)

![image](https://cdn.nlark.com/yuque/__latex/2f14a8bf8dce72f9ebcd42a65461e12b.svg)

特别的，![image](https://cdn.nlark.com/yuque/__latex/5497f722ee96a7e78d7898fa019a381b.svg)容斥的公式在期望意义下成立

也就是说![image](https://cdn.nlark.com/yuque/__latex/1f720af4f19ebd715a192e60f205e874.svg)

其他的类似，这是一个非常好的性质，可以解决一类难以解决的期望问题

通常这类题目的特征都是，一共要收集到![image](https://cdn.nlark.com/yuque/__latex/df378375e7693bdcf9535661c023c02e.svg)种物品，每次操作你会得到![image](https://cdn.nlark.com/yuque/__latex/df378375e7693bdcf9535661c023c02e.svg)种物品中的一种或多种，问我们收集到![image](https://cdn.nlark.com/yuque/__latex/df378375e7693bdcf9535661c023c02e.svg)种或者至少![image](https://cdn.nlark.com/yuque/__latex/df976ff7fcf17d60490267d18a1e3996.svg)种的期望操作次数。,那么此时![image](https://cdn.nlark.com/yuque/__latex/1e145b669607202a6694a13da86ae81f.svg)就代表着![image](https://cdn.nlark.com/yuque/__latex/1553dae3cc5c15cddb4f5b5a367b0aba.svg)集合中至少有一个元素被收集到的期望时间，

我们知道![image](https://cdn.nlark.com/yuque/__latex/5db3c26426490cc122a3a665e15c9645.svg)所以只需要求出![image](https://cdn.nlark.com/yuque/__latex/e0b02f6217aeddf5c4a66c7a8347da5f.svg)

我们分两种来考虑，第一种为简单情况，即全部集齐的期望操作次数,根据上面的分析我们只需要求出![image](https://cdn.nlark.com/yuque/__latex/2aaa88a50517414c98fca21cc8a79600.svg)即可，不难发现![image](https://cdn.nlark.com/yuque/__latex/e41e2a0d367498c36c0c9469d46af728.svg)

如果是子集形式我们高维前缀和即可，如果是单个元素的形式我们直接累加即可

第二种为困难情况，即要求至少集齐![image](https://cdn.nlark.com/yuque/__latex/82a9b492e38ab50536a53468696cb06b.svg)种的期望操作次数，此时我们的目标是![image](https://cdn.nlark.com/yuque/__latex/3db548b418e5a612f31e7cbd45ffe85c.svg),我们转化为![image](https://cdn.nlark.com/yuque/__latex/e91e92f1b3582b91d51c36bc6ade9cae.svg)，因为我们可以类似第一种情况求![image](https://cdn.nlark.com/yuque/__latex/1e145b669607202a6694a13da86ae81f.svg)

由于题型比较固定，当我们发现复杂度不能接受类似于![image](https://cdn.nlark.com/yuque/__latex/055ce37910d06a8239ef5a1ee87765f5.svg)时，可以把![image](https://cdn.nlark.com/yuque/__latex/b7324612ce5c6f167ea8fedce94fbaf1.svg)且![image](https://cdn.nlark.com/yuque/__latex/4fad2fa9f9b6a88f6fa51ebb8d1bd046.svg)相同的集合一起处理，我们设![image](https://cdn.nlark.com/yuque/__latex/f4edabbdb22193496b1b3ed0cde66694.svg)表示枚举到第![image](https://cdn.nlark.com/yuque/__latex/2443fbcfeb7e85e1d62b6f5e4f27207e.svg)个物品，![image](https://cdn.nlark.com/yuque/__latex/b7324612ce5c6f167ea8fedce94fbaf1.svg)为![image](https://cdn.nlark.com/yuque/__latex/036441a335dd85c838f76d63a3db2363.svg)，![image](https://cdn.nlark.com/yuque/__latex/4fad2fa9f9b6a88f6fa51ebb8d1bd046.svg)为![image](https://cdn.nlark.com/yuque/__latex/df976ff7fcf17d60490267d18a1e3996.svg)的集合数，这个的前提是![image](https://cdn.nlark.com/yuque/__latex/b7324612ce5c6f167ea8fedce94fbaf1.svg)位数比较少且比较小的情况下才能使用

## 二项式反演
实际上是由容斥原理衍生出的几组恒等式  往往解决至少和恰好 或者 至多和恰好之间的转化

我们给出常用的几种形式

![image](https://cdn.nlark.com/yuque/__latex/0eb30e845f1370ce04407adc80e2b3ac.svg)![image](https://cdn.nlark.com/yuque/__latex/ae58738dadd02826e7d6df0010627760.svg)

![image](https://cdn.nlark.com/yuque/__latex/ba4c3f97371ffa47698bd1290a56dda1.svg)![image](https://cdn.nlark.com/yuque/__latex/48dce8e539cc1ad35c2865bb5447dd16.svg)

![image](https://cdn.nlark.com/yuque/__latex/d2740f66b368443ea5c0fe97baef35f5.svg)![image](https://cdn.nlark.com/yuque/__latex/e6cc852ac98b58fdbaa5ac84dec2a621.svg)

![image](https://cdn.nlark.com/yuque/__latex/29163297c5061d9c3003a867913d3444.svg)![image](https://cdn.nlark.com/yuque/__latex/c88213ced5c5622e710193f186716881.svg)

![image](https://cdn.nlark.com/yuque/__latex/6a0449293c03e703a649c4eafffda31c.svg)![image](https://cdn.nlark.com/yuque/__latex/12001eebb793984ec86156507aab31eb.svg)

![image](https://cdn.nlark.com/yuque/__latex/87cdda31b71bbe9d3d7f592c616006e9.svg)![image](https://cdn.nlark.com/yuque/__latex/16def1dd4a772a00b4f56ef68dee3b1c.svg)

![image](https://cdn.nlark.com/yuque/__latex/c4c37b8e926a64a814441d66eb4b6a78.svg)![image](https://cdn.nlark.com/yuque/__latex/47ca6584b1056e7b3033d8b60d7d0a8f.svg)

![image](https://cdn.nlark.com/yuque/__latex/26c7c5c44b9bf81fb86b08acc7ddde30.svg)![image](https://cdn.nlark.com/yuque/__latex/c5abd141559fa63a6794185787aee36c.svg)

我们类比还可以推广到更高维的形式

## 树计数
### 无标号树计数
有根树计数：

![image](https://cdn.nlark.com/yuque/__latex/370216b4b5f80062d953d2768a685ffd.svg)

递推公式

![image](https://cdn.nlark.com/yuque/__latex/5a3452ded203b66cda84af62aee9fcdb.svg)

无根树计数：

![image](https://cdn.nlark.com/yuque/__latex/df378375e7693bdcf9535661c023c02e.svg)为奇数时

![image](https://cdn.nlark.com/yuque/__latex/987cd3a2cf2065c466b94af80c79a310.svg)

![image](https://cdn.nlark.com/yuque/__latex/df378375e7693bdcf9535661c023c02e.svg)为偶数时

![image](https://cdn.nlark.com/yuque/__latex/e6e9da619fac92e4d84072ade3c8849b.svg)

### Prufer序列
![image](https://cdn.nlark.com/yuque/__latex/c83665563e536f04a4c5fff471c7119d.svg)序列实际上和无根树对应它是无根树衍生出来的一种序列

我们先给出转化方法

![image](https://cdn.nlark.com/yuque/__latex/53072c2388d69edc65c2377681e4e87c.svg)无根树转![image](https://cdn.nlark.com/yuque/__latex/c83665563e536f04a4c5fff471c7119d.svg)序列

首先我们找到编号最小且度数为![image](https://cdn.nlark.com/yuque/__latex/53072c2388d69edc65c2377681e4e87c.svg)的点

其次删除该节点并加入和该节点相连的父节点

我们重复上述操作直至剩下两个节点

不难发现![image](https://cdn.nlark.com/yuque/__latex/df378375e7693bdcf9535661c023c02e.svg)个点的树的![image](https://cdn.nlark.com/yuque/__latex/c83665563e536f04a4c5fff471c7119d.svg)序列长度是![image](https://cdn.nlark.com/yuque/__latex/4adafb65c93bb8ab7e9e8ace7f108dbf.svg)的

因为每删一个点![image](https://cdn.nlark.com/yuque/__latex/c83665563e536f04a4c5fff471c7119d.svg)序列长度加一最后剩两个点说明了![image](https://cdn.nlark.com/yuque/__latex/c83665563e536f04a4c5fff471c7119d.svg)序列的长度为![image](https://cdn.nlark.com/yuque/__latex/4adafb65c93bb8ab7e9e8ace7f108dbf.svg);



![image](https://cdn.nlark.com/yuque/__latex/2b89979f54ec02a7bf87aa0c1ea58ff9.svg)![image](https://cdn.nlark.com/yuque/__latex/c83665563e536f04a4c5fff471c7119d.svg)序列转无根树

首先我们取出![image](https://cdn.nlark.com/yuque/__latex/c83665563e536f04a4c5fff471c7119d.svg)序列的首个元素 ![image](https://cdn.nlark.com/yuque/__latex/77c3adce895348f6083c425fe1ba2624.svg)

其次在点集中找到最小的且未出现在![image](https://cdn.nlark.com/yuque/__latex/c83665563e536f04a4c5fff471c7119d.svg)序列中的点![image](https://cdn.nlark.com/yuque/__latex/a770a282bbfa0ae1ec474b7ed311656d.svg) 连边![image](https://cdn.nlark.com/yuque/__latex/40439f547e931e21fa5c305e3df07ada.svg)然后分别删除这两个节点

最后在点集中会剩下![image](https://cdn.nlark.com/yuque/__latex/2b89979f54ec02a7bf87aa0c1ea58ff9.svg)个点给他们连边

虽然转化方法并不重要 但我们仍给出转化的代码

```cpp
std::vector<int> treePru(std::vector<int> &fa, int n) // n为根 fa是[1,n-1]的父亲节点
{
    std::vector<int> deg(n + 1, 0);
    std::vector<int> pru(n - 1, 0);
    for (int i = 1; i < n; ++i)
    {
        ++deg[fa[i]];
    }
    for (int i = 1, j = 1; i <= n - 2; ++i, ++j)
    {
        while (deg[j])
        {
            ++j;
        }
        pru[i] = fa[j];
        while (i < n - 2 && !--deg[pru[i]] && pru[i] < j)
        {
            pru[i + 1] = fa[pru[i]];
            ++i;
        }
    }
    return pru; // n-2个点
}
std::vector<int> pruTree(std::vector<int> &pru, int n)
{
    std::vector<int> deg(n + 1, 0);
    std::vector<int> fa(n + 1, 0);
    pru.resize(n);
    for (int i = 1; i <= n - 2; ++i)
    {
        ++deg[pru[i]];
    }
    pru[n - 1] = n;
    for (int i = 1, j = 1; i < n - 1; ++i, ++j)
    {
        while (deg[j])
        {
            ++j;
        }
        fa[j] = pru[i];
        while (i < n - 1 && !--deg[pru[i]] && pru[i] < j)
        {
            fa[pru[i]] = pru[i + 1];
            ++i;
        }
    }
    fa.resize(n);
    return fa;
}
```

它有如下的性质

1 ![image](https://cdn.nlark.com/yuque/__latex/c83665563e536f04a4c5fff471c7119d.svg)序列和无根树一一对应

2 度数为![image](https://cdn.nlark.com/yuque/__latex/f47ef0f303ba9d9f4f2ac96f6df77277.svg)的点会在prufer序列中出现![image](https://cdn.nlark.com/yuque/__latex/b141fd8d4ad625dfdf43be6963cb00a9.svg)次

3 ![image](https://cdn.nlark.com/yuque/__latex/df378375e7693bdcf9535661c023c02e.svg)个点的树的![image](https://cdn.nlark.com/yuque/__latex/c83665563e536f04a4c5fff471c7119d.svg)序列长度为![image](https://cdn.nlark.com/yuque/__latex/4adafb65c93bb8ab7e9e8ace7f108dbf.svg)



当我们成功把无根树映射成一个序列时 我们将会得到很多好的计数方法

1 对于给定度数序列![image](https://cdn.nlark.com/yuque/__latex/eed28b03090839b9b92aaf8e8181b936.svg)的无根树它的情况数显然为 (可重元素排列计数)

![image](https://cdn.nlark.com/yuque/__latex/b849cf20dcc8f6c8073d54c473b25555.svg)

2 对于给定部分度数序列的无根树它的情况数 

我们记有度数限制的点有![image](https://cdn.nlark.com/yuque/__latex/433b8a66a6efa08fd812b9e20c8af568.svg)个 ，![image](https://cdn.nlark.com/yuque/__latex/5d9e8c2483c4833aa0f798fca42487db.svg)=![image](https://cdn.nlark.com/yuque/__latex/8301bfc9115bfc2d0c7e0ef97b109985.svg) 

那么方案数为![image](https://cdn.nlark.com/yuque/__latex/3aa9843454063dde42cdf46e4312cea8.svg)

#### Cayley定理
1 对于![image](https://cdn.nlark.com/yuque/__latex/df378375e7693bdcf9535661c023c02e.svg)个节点的完全图的生成树个数为![image](https://cdn.nlark.com/yuque/__latex/d1a340b3c2f999f5df583c8a5d7c3d0a.svg)(结论是显然的生成树的prufer序列长为![image](https://cdn.nlark.com/yuque/__latex/4adafb65c93bb8ab7e9e8ace7f108dbf.svg) 同时![image](https://cdn.nlark.com/yuque/__latex/c83665563e536f04a4c5fff471c7119d.svg)序列的每个点都有![image](https://cdn.nlark.com/yuque/__latex/df378375e7693bdcf9535661c023c02e.svg)种可能性)

2 给定 ![image](https://cdn.nlark.com/yuque/__latex/df378375e7693bdcf9535661c023c02e.svg)个点（有标号）其生成的无根树的个数为![image](https://cdn.nlark.com/yuque/__latex/2d57d79ffb7d3ab896f73d2acd5f1f90.svg)(实际上该条件和给定完全图类似)

3给定![image](https://cdn.nlark.com/yuque/__latex/df378375e7693bdcf9535661c023c02e.svg)个点（有标号）其生成的有根树的个数为![image](https://cdn.nlark.com/yuque/__latex/2ab95451510167e85da3c1d9fd8c470c.svg)(结论是显然的对于![image](https://cdn.nlark.com/yuque/__latex/53072c2388d69edc65c2377681e4e87c.svg)中的每种情况我们的根节点都有![image](https://cdn.nlark.com/yuque/__latex/df378375e7693bdcf9535661c023c02e.svg)种选择)

#### **扩展Cayley定理**
由![image](https://cdn.nlark.com/yuque/__latex/c83665563e536f04a4c5fff471c7119d.svg)序列推出，给定一个有![image](https://cdn.nlark.com/yuque/__latex/df378375e7693bdcf9535661c023c02e.svg)个点![image](https://cdn.nlark.com/yuque/__latex/4760e2f007e23d820825ba241c47ce3b.svg)个联通块的无向图，第![image](https://cdn.nlark.com/yuque/__latex/2443fbcfeb7e85e1d62b6f5e4f27207e.svg)个联通块的点数为![image](https://cdn.nlark.com/yuque/__latex/d7be22edeaed1d3066138c4f3debf921.svg)，那么要加![image](https://cdn.nlark.com/yuque/__latex/e695869ab86fb7206de0b9dfed58fb7b.svg)条边使该图联通，方案数为![image](https://cdn.nlark.com/yuque/__latex/3e32e129e79ceebb7b332f02d8f14331.svg)

### **矩阵树定理**
即给定一个无向图（或有向图）求它的生成树个数（可能是外向树或内向树）



![image](https://cdn.nlark.com/yuque/__latex/53072c2388d69edc65c2377681e4e87c.svg)求无向图的生成树个数

![image](https://cdn.nlark.com/yuque/__latex/2b89979f54ec02a7bf87aa0c1ea58ff9.svg)给出有向图和其中的一个点求以这个点为根的生成外向树个数  外向则是由根指向树

![image](https://cdn.nlark.com/yuque/__latex/a7720a85557fdd660de5e2da1dfa7c07.svg)给出有向图和其中的一个点求以这个点为根的生成内向树的个数 内向则是由树指向根



第一种

所求矩阵![image](https://cdn.nlark.com/yuque/__latex/de951302f41d4707b9d80ca1af34dd0f.svg)对角线上为每个点的度数为正数

非对角线的元素![image](https://cdn.nlark.com/yuque/__latex/39e2814cdf3b36b60f76fca8498708e1.svg)为![image](https://cdn.nlark.com/yuque/__latex/2443fbcfeb7e85e1d62b6f5e4f27207e.svg)与![image](https://cdn.nlark.com/yuque/__latex/72f89366bece32fb94026b3d54d6ae07.svg)之间边的数量为负数

去掉最后一行和最后一列求行列式的值



第二种

所求矩阵![image](https://cdn.nlark.com/yuque/__latex/de951302f41d4707b9d80ca1af34dd0f.svg)对角线上为每个点的入度为正数

非对角线的元素![image](https://cdn.nlark.com/yuque/__latex/39e2814cdf3b36b60f76fca8498708e1.svg)为![image](https://cdn.nlark.com/yuque/__latex/2443fbcfeb7e85e1d62b6f5e4f27207e.svg)指向![image](https://cdn.nlark.com/yuque/__latex/036441a335dd85c838f76d63a3db2363.svg)的边的数量为负数

去掉根所在的行和列求行列式的值



第三种

所求矩阵![image](https://cdn.nlark.com/yuque/__latex/de951302f41d4707b9d80ca1af34dd0f.svg)对角线上为每个点的出度为正数

非对角线的元素![image](https://cdn.nlark.com/yuque/__latex/39e2814cdf3b36b60f76fca8498708e1.svg)为![image](https://cdn.nlark.com/yuque/__latex/2443fbcfeb7e85e1d62b6f5e4f27207e.svg)指向![image](https://cdn.nlark.com/yuque/__latex/036441a335dd85c838f76d63a3db2363.svg)的边的数量为负数

去掉根所在的行和列求行列式的值



对于行列式的求值我们需要配合辗转相减高斯消元

我们需要特别注意的是第一种情况要去掉任意一行一列求值只需要![image](https://cdn.nlark.com/yuque/__latex/df378375e7693bdcf9535661c023c02e.svg)自己减一即可

第二种和第三种情况要求删去根所在的行或列也需要对代码进行改动



特别的如果我们要求所有生成树的所有权值和我们只需要把边权![image](https://cdn.nlark.com/yuque/__latex/c9b08ae6d9fed72562880f75720531bc.svg)当做有![image](https://cdn.nlark.com/yuque/__latex/c9b08ae6d9fed72562880f75720531bc.svg)条重边即可体现在矩阵上

<font style="color:rgba(0, 0, 0, 0.75);">根据乘法原理,对于某种生成树的形态,其贡献为每条边重的次数的乘积。</font>

<font style="color:rgba(0, 0, 0, 0.75);">如果把重边次数理解成权值的话,那么矩阵树定理求的就是 : 所有生成树边权乘积的总和。</font>

```cpp
int MatrixTree(std::vector<std::array<int, 3>> &g, int type, int root, int n)
{
    std::vector Mat(n, std::vector<int>(n, 0));
    if (type == 0) // 无向图
    {
        for (auto [u, v, w] : g)
        {
            if (u < n)
            {
                Mat[u][u] += w;
            }
            if (v < n)
            {
                Mat[v][v] += w;
            }
            if (u < n and v < n)
            {
                Mat[u][v] -= w;
                Mat[v][u] -= w;
            }
        }
        return determinant(Mat, n - 1);
    }
    else if (type == 1)          // 外向树
    {                            // 我们想办法把root换成n即可
        for (auto [u, v, w] : g) // u->v
        {
            if (u == root)
            {
                u = n;
            }
            else if (u == n)
            {
                u = root;
            }
            if (v == root)
            {
                v = n;
            }
            else if (v == n)
            {
                v = root;
            }
            if (v < n)
            {
                Mat[v][v] += w;
            }
            if (v < n and u < n)
            {
                Mat[u][v] -= w;
            }
        }
        return determinant(Mat, n - 1);
    }
    else
    {
        for (auto [u, v, w] : g) // u->v
        {
            if (u == root)
            {
                u = n;
            }
            else if (u == n)
            {
                u = root;
            }
            if (v == root)
            {
                v = n;
            }
            else if (v == n)
            {
                v = root;
            }
            if (u < n)
            {
                Mat[u][u] += w;
            }
            if (v < n and u < n)
            {
                Mat[u][v] -= w;
            }
        }
        return determinant(Mat, n - 1);
    }
}
```

## 图计数
### 连通图计数
我们求![image](https://cdn.nlark.com/yuque/__latex/df378375e7693bdcf9535661c023c02e.svg)个点的无向连通图计数

<font style="color:rgb(0, 0, 0);">令 </font>![image](https://cdn.nlark.com/yuque/__latex/bc4270e28da7dabcbcd34c800c06a4a0.svg)<font style="color:rgb(0, 0, 0);">表示 n 个点的带标号简单无向连通图的个数，</font>![image](https://cdn.nlark.com/yuque/__latex/555626ea18d6f96832c756e4ababc86f.svg)<font style="color:rgb(0, 0, 0);">表示 n 个点带标号简单无向图的个数  那么显然有 </font>![image](https://cdn.nlark.com/yuque/__latex/c26e3aa8a4fc357eaf9d751e2381e2d6.svg)<font style="color:rgb(0, 0, 0);">  我们考虑用</font>![image](https://cdn.nlark.com/yuque/__latex/555626ea18d6f96832c756e4ababc86f.svg)<font style="color:rgb(0, 0, 0);">表示</font>![image](https://cdn.nlark.com/yuque/__latex/bc4270e28da7dabcbcd34c800c06a4a0.svg)

我们不妨枚举和点1联通的点的个数 那么有

![image](https://cdn.nlark.com/yuque/__latex/55186550430662fbe295ea378e650e1b.svg)

我们将组合数展开化简得到

![image](https://cdn.nlark.com/yuque/__latex/d3a99395f297e2b2a2dc6dda033280c4.svg)

不难发现右边是卷积形式 

有![image](https://cdn.nlark.com/yuque/__latex/f22ec510ad8fc5461fbec7ad4faa633d.svg)

## **群论计数**
主要解决一类循环对称同构计数问题

考虑到笔者的群论水平十分有限，我们这里不引入很多的群论概念，我们感性理解引理如何使用.

### Burnside引理
简单来说结论，一个置换群的等价类个数等于所有置换不动点个数的平均数

再次简化来说，就是每个置换的不动点个数的平均数就是方案数。



那么什么叫置换呢？常见的有旋转和对称同构，即我们解决的是旋转和对称情况下的方案数计数，

不动点就是指某个方案在该置换下和原方案相同，那么称作不动点.



在![image](https://cdn.nlark.com/yuque/__latex/79a6914b1da52dca1e4e30bd9de2a190.svg)引理中，我们只能手动计数得到不动点个数。



![image](https://cdn.nlark.com/yuque/__latex/1cf2b4a60a7a32f0d3309236f1506e39.svg)

### Polya引理
实际上是![image](https://cdn.nlark.com/yuque/__latex/79a6914b1da52dca1e4e30bd9de2a190.svg)引理的一个特殊情况，我们考虑到任何一个置换都能分解为循环的乘积，那么我们将会得到一系列的置换环 或者说循环节，那么我们有结论，在![image](https://cdn.nlark.com/yuque/__latex/6a6b811a2879516d7418f3d7325a142d.svg)种颜色的情况下，一个置换![image](https://cdn.nlark.com/yuque/__latex/18f3c2855f0e85a1ac2257f64d917144.svg)的不动点个数![image](https://cdn.nlark.com/yuque/__latex/6c2f36efaebd162b27d8729f5580b9ab.svg),![image](https://cdn.nlark.com/yuque/__latex/caa3f5df66f1dfc2ae4d390074ba02ca.svg)表示置换![image](https://cdn.nlark.com/yuque/__latex/18f3c2855f0e85a1ac2257f64d917144.svg)的置换环个数

## 几个经典计数模型
### 卡特兰数
我们考虑推导，首先我们考虑所有情况，那么显然为![image](https://cdn.nlark.com/yuque/__latex/bb59f321021ebe76a8369f318a7a41b1.svg)，但是我们不能越过![image](https://cdn.nlark.com/yuque/__latex/7a7e80f8c122d4d31ecee57ce5d96ae5.svg)，也就是不能触碰![image](https://cdn.nlark.com/yuque/__latex/f813fea35fe951451f8b75f0e6e5aa5a.svg)，考虑求出不合法的情况，我们把触碰![image](https://cdn.nlark.com/yuque/__latex/f813fea35fe951451f8b75f0e6e5aa5a.svg)以后得折线部分关于![image](https://cdn.nlark.com/yuque/__latex/f813fea35fe951451f8b75f0e6e5aa5a.svg)对称，发现终点变成了![image](https://cdn.nlark.com/yuque/__latex/d66324f807f27a3a3add1dcb358dc738.svg)，那么方案数为![image](https://cdn.nlark.com/yuque/__latex/eb8dbc9aeb09f803def69a36be1ec93d.svg)，总方案数为![image](https://cdn.nlark.com/yuque/__latex/a9dee6f66ffbf7e61df2aee9df1109cf.svg)。

我们考虑拓展，假设有![image](https://cdn.nlark.com/yuque/__latex/26fdbf8e53cb0e48da5f4ddd4aaf5a5c.svg)个![image](https://cdn.nlark.com/yuque/__latex/53072c2388d69edc65c2377681e4e87c.svg)，![image](https://cdn.nlark.com/yuque/__latex/e3b1a1ba9d491cc6835e70607ead3750.svg)个![image](https://cdn.nlark.com/yuque/__latex/f5c91774886192157cf2ef03c17dcfc2.svg)，组成一个序列，要求前缀和恒大于等于![image](https://cdn.nlark.com/yuque/__latex/b891664b42113aee13f0bac25eb998e5.svg)，求方案数，发现总的情况数为![image](https://cdn.nlark.com/yuque/__latex/9fe909942f60686df0206aaa3fee56b4.svg)，条件即不能触碰![image](https://cdn.nlark.com/yuque/__latex/2a93479575b24cafdf3c1f7cf77e45da.svg)，那么我们考虑![image](https://cdn.nlark.com/yuque/__latex/3fa416a2719b11d2ab46a98b76dd7be0.svg)关于它的对称点，易得到为![image](https://cdn.nlark.com/yuque/__latex/9747cc78c13b724eea61ab1aa7537603.svg)，那么方案数减去![image](https://cdn.nlark.com/yuque/__latex/16279d935b0b3ad08afd831b5d71b143.svg)即可

#### 卡特兰数
常规的卡特兰数我们有两种表述形式，其一是![image](https://cdn.nlark.com/yuque/__latex/cdaf04cddf57ae63edeafceb53eb4044.svg)式表述，其二是组合意义表述。

组合意义表述来说，就是存在两种元素，满足在序列的任意一个前缀中其中一种的个数恒大于等于另一种且最终二者数量相同 的方案数

就是常规卡特兰数了，例子很多，比如给一个进栈序列求出栈顺序的方案数，满足（入栈数>=出栈数 且最终相等），再比如括号正则表达式，满足(左括号数量>=右括号数量,且最终左等于右)

DP式表述来说，即形如![image](https://cdn.nlark.com/yuque/__latex/db338255d365030546c6f9c3e46319db.svg)的递推式，最终![image](https://cdn.nlark.com/yuque/__latex/13294e05c261f665b2794fc42599500a.svg)的表达式也将是卡特兰数，证明只需把通项公式展开即可,这个的例子形如n个点的二叉树有多少种形态，是由DP式子得到卡特兰数的结论



我们给出几个通项公式，![image](https://cdn.nlark.com/yuque/__latex/f421f0b200a45cd3052765f02f459ec7.svg) 

  ![image](https://cdn.nlark.com/yuque/__latex/e9ea4c49473ece95615596dd0b1edfd0.svg)    ![image](https://cdn.nlark.com/yuque/__latex/e2ad532a33b15d03f7c27d2388bd82b6.svg)

#### 卡特兰数数表
```cpp
1
2
5
14
42
132
429
1430
4862
16796
58786
208012
742900
2674440
9694845
35357670
129644790
477638700
1767263190
6564120420
24466267020
91482563640
343059613650
1289904147324
4861946401452
18367353072152
69533550916004
263747951750360
1002242216651368
3814986502092304
14544636039226909
55534064877048198
212336130412243110
812944042149730764
3116285494907301262
11959798385860453492
45950804324621742364
176733862787006701400
680425371729975800390
2622127042276492108820
10113918591637898134020
39044429911904443959240
150853479205085351660700
583300119592996693088040
2257117854077248073253720
8740328711533173390046320
33868773757191046886429490
131327898242169365477991900
509552245179617138054608572
1978261657756160653623774456
7684785670514316385230816156
29869166945772625950142417512
116157871455782434250553845880
451959718027953471447609509424
1759414616608818870992479875972
6852456927844873497549658464312
26700952856774851904245220912664
104088460289122304033498318812080
405944995127576985730643443367112
1583850964596120042686772779038896
6182127958584855650487080847216336
24139737743045626825711458546273312
94295850558771979787935384946380125
368479169875816659479009042713546950
1440418573150919668872489894243865350
5632681584560312734993915705849145100
22033725021956517463358552614056949950
86218923998960285726185640663701108500
337485502510215975556783793455058624700
1321422108420282270489942177190229544600
5175569924646105559418940193995065716350
20276890389709399862928998568254641025700
79463489365077377841208237632349268884500
311496878311103321137536291518809134027240
1221395654430378811828760722007962130791020
4790408930363303911328386208394864461024520
18793142726809884575211361279087545193250040
73745243611532458459690151854647329239335600
289450081175264899454283846029490767264392230
1136359577947336271931632877004667456667613940
4462290049988320482463241297506133183499654740
17526585015616776834735140517915655636396234280
68854441132780194707888052034668647142985206100
270557451039395118028642463289168566420671280440
1063353702922273835973036658043476458723103404520
4180080073556524734514695828170907458428751314320
16435314834665426797069144960762886143367590394940
64633260585762914370496637486146181462681535261000
254224158304000796523953440778841647086547372026600
1000134600800354781929399250536541864362461089950800
3935312233584004685417853572763349509774031680023800
15487357822491889407128326963778343232013931127835600
60960876535340415751462563580829648891969728907438000
239993345518077005168915776623476723006280827488229600
944973797977428207852605870454939596837230758234904050
3721443204405954385563870541379246659709506697378694300
14657929356129575437016877846657032761712954950899755100
57743358069601357782187700608042856334020731624756611000
227508830794229349661819540395688853956041682601541047340
896519947090131496687170070074100632420837521538745909320

```

#### k阶卡特兰数
![image](https://cdn.nlark.com/yuque/__latex/df976ff7fcf17d60490267d18a1e3996.svg)阶卡特兰数的定义是，在一个网格上我要走到![image](https://cdn.nlark.com/yuque/__latex/4bf46232f7532be5401923af7a1fda57.svg)点，我们移动的向量只有![image](https://cdn.nlark.com/yuque/__latex/6a72c205dbb18f0a93a30f2a69ef4401.svg),且要求我们不能越过![image](https://cdn.nlark.com/yuque/__latex/ef5e36b4796bc427276e681faa7b639c.svg),求移动方案数。

显然当![image](https://cdn.nlark.com/yuque/__latex/9044cadddfbfb9c8eb94245fc369c777.svg)时方案数为常规卡特兰数，因为![image](https://cdn.nlark.com/yuque/__latex/3f6aef3a1c2bf15576b4beb4c266f941.svg)的数量恒大于等于![image](https://cdn.nlark.com/yuque/__latex/2ae4322eb2588ee684ccdb047a14ac06.svg)且数量最终相等

当![image](https://cdn.nlark.com/yuque/__latex/6a6b811a2879516d7418f3d7325a142d.svg)不再为![image](https://cdn.nlark.com/yuque/__latex/53072c2388d69edc65c2377681e4e87c.svg)时，问题变得复杂，我们直接给出公式和DP式，推导咕咕咕



![image](https://cdn.nlark.com/yuque/__latex/752f601036920a77c9570ed925b0a871.svg)



![image](https://cdn.nlark.com/yuque/__latex/30f68b1fd22cdb0b8b16bcabe5064e04.svg)

可以解决如下问题



有![image](https://cdn.nlark.com/yuque/__latex/bc6c70972a5e80203f17eb8f48ecbb3d.svg)个![image](https://cdn.nlark.com/yuque/__latex/53072c2388d69edc65c2377681e4e87c.svg),![image](https://cdn.nlark.com/yuque/__latex/df378375e7693bdcf9535661c023c02e.svg)个![image](https://cdn.nlark.com/yuque/__latex/726d9c5d065e540309b5bbceb2f0464e.svg),要求你组成一个序列且该序列前缀和恒大于等于0，问序列个数



### 欧拉错排数
即n个编号为![image](https://cdn.nlark.com/yuque/__latex/df196fd7c9677458bc7b549d0ae50a2d.svg)的位置，我有同样编号为![image](https://cdn.nlark.com/yuque/__latex/4020fbc2a71742efdd052e9dc7dae80d.svg)的n个数，要求把n个数填到位置中，满足位置号和编号均不相同的方案数![image](https://cdn.nlark.com/yuque/__latex/0072915659f3936217a2d49db6ae6f1b.svg)

这个我们可以递推解决，满足![image](https://cdn.nlark.com/yuque/__latex/e8bc584276b369a6f0e379432df9669c.svg)



简单证明:我们假设第一个数放在位置![image](https://cdn.nlark.com/yuque/__latex/df976ff7fcf17d60490267d18a1e3996.svg)上，![image](https://cdn.nlark.com/yuque/__latex/df976ff7fcf17d60490267d18a1e3996.svg)有n-1种选择，我们考虑![image](https://cdn.nlark.com/yuque/__latex/df976ff7fcf17d60490267d18a1e3996.svg)位置的选择 分两种情况

如果![image](https://cdn.nlark.com/yuque/__latex/df976ff7fcf17d60490267d18a1e3996.svg)也放在![image](https://cdn.nlark.com/yuque/__latex/53072c2388d69edc65c2377681e4e87c.svg)位置上那么就是剩下![image](https://cdn.nlark.com/yuque/__latex/4adafb65c93bb8ab7e9e8ace7f108dbf.svg)个数再次错排，否则将是![image](https://cdn.nlark.com/yuque/__latex/f29219be34b160369c88fab81ea65712.svg)个数错排。

### **<font style="color:rgb(26, 28, 30);">莫茨金数 (Motzkin Numbers)</font>**
![image](https://cdn.nlark.com/yuque/__latex/25fa1a896168a8127d9336352ddd3027.svg)

![image](https://cdn.nlark.com/yuque/__latex/427b920fd7d14ba830872461d80ec3a3.svg)

![image](https://cdn.nlark.com/yuque/__latex/24fc1e27b8c98bc8a390c52a112443ef.svg)

经典应用场景：

![image](https://cdn.nlark.com/yuque/__latex/53072c2388d69edc65c2377681e4e87c.svg)一个圆上有![image](https://cdn.nlark.com/yuque/__latex/df378375e7693bdcf9535661c023c02e.svg)个点，画若干条不相交弦的方案数

![image](https://cdn.nlark.com/yuque/__latex/2b89979f54ec02a7bf87aa0c1ea58ff9.svg)在一个二维网格从![image](https://cdn.nlark.com/yuque/__latex/79e4b67771e7db6b16990e64a36c6521.svg)走到![image](https://cdn.nlark.com/yuque/__latex/037dad9055e433661a9c4bd8c0d9d62d.svg)，![image](https://cdn.nlark.com/yuque/__latex/9b50a4cc891e4c232dcd1a3eb20c0632.svg)表示向右上走一步，![image](https://cdn.nlark.com/yuque/__latex/29b99cc5835cb7ab426600c8b964ec24.svg)表示向右走一步，![image](https://cdn.nlark.com/yuque/__latex/f6a91afa2d14f831c72a4f59c1cbc8e6.svg)表示向右下走一步

要求路径中始终不能低于![image](https://cdn.nlark.com/yuque/__latex/712ecf7894348e92d8779c3ee87eeeb0.svg)轴，终点必须在![image](https://cdn.nlark.com/yuque/__latex/037dad9055e433661a9c4bd8c0d9d62d.svg)，问方案数。

### 贝尔数
贝尔数![image](https://cdn.nlark.com/yuque/__latex/d633ffc3f680806cd3225ced35f98bd5.svg)表示把![image](https://cdn.nlark.com/yuque/__latex/df378375e7693bdcf9535661c023c02e.svg)个元素划分集合的方案数，集合数量无限制。

显然贝尔数是第二类斯特林数的和，即![image](https://cdn.nlark.com/yuque/__latex/d23d2b7343273e48b81dfbdb4d8b356a.svg)

递推公式![image](https://cdn.nlark.com/yuque/__latex/96beceb4c8c142a86fcb1b6e6266c993.svg)

![image](https://cdn.nlark.com/yuque/__latex/374ff818e971c9b72d78513c812f3481.svg)

### 斐波那契数列
#### 斐波那契数表
```cpp
 F0	0
 F1	1
 F2	1
 F3	2
 F4	3
 F5	5
 F6	8
 F7	13
 F8	21
 F9	34
 F10	55
 F11	89
 F12	144
 F13	233
 F14	377
 F15	610
 F16	987
 F17	1597
 F18	2584
 F19	4181
 F20	6765
 F21	10946
 F22	17711
 F23	28657
 F24	46368
 F25	75025
 F26	121393
 F27	196418
 F28	317811
 F29	514229
 F30	832040
 F31	1346269
 F32	2178309
 F33	3524578
 F34	5702887
 F35	9227465
 F36	14930352
 F37	24157817
 F38	39088169
 F39	63245986
 F40	102334155
 F41	165580141
 F42	267914296
 F43	433494437
 F44	701408733
 F45	1134903170
 F46	1836311903
 F47	2971215073
 F48	4807526976
 F49	7778742049
 F50	12586269025
 F51	20365011074
 F52	32951280099
 F53	53316291173
 F54	86267571272
 F55	139583862445
 F56	225851433717
 F57	365435296162
 F58	591286729879
 F59	956722026041
 F60	1548008755920
 F61	2504730781961
 F62	4052739537881
 F63	6557470319842
 F64	10610209857723
 F65	17167680177565
 F66	27777890035288
 F67	44945570212853
 F68	72723460248141
 F69	117669030460994
 F70	190392490709135
 F71	308061521170129
 F72	498454011879264
 F73	806515533049393
 F74	1304969544928657
 F75	2111485077978050
 F76	3416454622906707
 F77	5527939700884757
 F78	8944394323791464
 F79	14472334024676221
 F80	23416728348467685
 F81	37889062373143906
 F82	61305790721611591
 F83	99194853094755497
 F84	160500643816367088
 F85	259695496911122585
 F86	420196140727489673
 F87	679891637638612258
 F88	1100087778366101931
 F89	1779979416004714189
 F90	2880067194370816120
 F91	4660046610375530309
 F92	7540113804746346429
 F93	12200160415121876738
 F94	19740274219868223167
 F95	31940434634990099905
 F96	51680708854858323072
 F97	83621143489848422977
 F98	135301852344706746049
 F99	218922995834555169026
 F100	354224848179261915075
 F101	573147844013817084101
 F102	927372692193078999176
 F103	1500520536206896083277
 F104	2427893228399975082453
 F105	3928413764606871165730
 F106	6356306993006846248183
 F107	10284720757613717413913
 F108	16641027750620563662096
 F109	26925748508234281076009
 F110	43566776258854844738105
 F111	70492524767089125814114
 F112	114059301025943970552219
 F113	184551825793033096366333
 F114	298611126818977066918552
 F115	483162952612010163284885
 F116	781774079430987230203437
 F117	1264937032042997393488322
 F118	2046711111473984623691759
 F119	3311648143516982017180081
 F120	5358359254990966640871840
 F121	8670007398507948658051921
 F122	14028366653498915298923761
 F123	22698374052006863956975682
 F124	36726740705505779255899443
 F125	59425114757512643212875125
 F126	96151855463018422468774568
 F127	155576970220531065681649693
 F128	251728825683549488150424261
 F129	407305795904080553832073954
 F130	659034621587630041982498215
 F131	1066340417491710595814572169
 F132	1725375039079340637797070384
 F133	2791715456571051233611642553
 F134	4517090495650391871408712937
 F135	7308805952221443105020355490
 F136	11825896447871834976429068427
 F137	19134702400093278081449423917
 F138	30960598847965113057878492344
 F139	50095301248058391139327916261
 F140	81055900096023504197206408605
 F141	131151201344081895336534324866
 F142	212207101440105399533740733471
 F143	343358302784187294870275058337
 F144	555565404224292694404015791808
 F145	898923707008479989274290850145
 F146	1454489111232772683678306641953
 F147	2353412818241252672952597492098
 F148	3807901929474025356630904134051
 F149	6161314747715278029583501626149
 F150	9969216677189303386214405760200
```

斐波那契数列有许多有趣的性质，我们总结一下

![image](https://cdn.nlark.com/yuque/__latex/53072c2388d69edc65c2377681e4e87c.svg)斐波那契数列我们认为是三角形数，如果要构造一个最长的序列满足任意三个数都不能构成三角形的话，斐波那契数列将是最佳选择

![image](https://cdn.nlark.com/yuque/__latex/2b89979f54ec02a7bf87aa0c1ea58ff9.svg)![image](https://cdn.nlark.com/yuque/__latex/575f47f1743b6e0ba06cc16165a4900f.svg)

![image](https://cdn.nlark.com/yuque/__latex/a7720a85557fdd660de5e2da1dfa7c07.svg)![image](https://cdn.nlark.com/yuque/__latex/92d21bc382705aa0d9fdd1a435ee7783.svg)

![image](https://cdn.nlark.com/yuque/__latex/afb0613a26341d701b3967ba170aa30c.svg)![image](https://cdn.nlark.com/yuque/__latex/a6f178e955b9175f4512a9612f7d0911.svg) ![image](https://cdn.nlark.com/yuque/__latex/3ac5fce8c3af3b4bd301f98e32fc7c51.svg)

![image](https://cdn.nlark.com/yuque/__latex/b15983bcda2a67366d095cfeb326717a.svg)![image](https://cdn.nlark.com/yuque/__latex/d6237b866da2663fcbeb244fc6612a86.svg)

![image](https://cdn.nlark.com/yuque/__latex/984ee5638727be63ceaa544f2e2e01b3.svg)![image](https://cdn.nlark.com/yuque/__latex/2e4c3f8fc5c59cd2be969006d600a3bd.svg)

![image](https://cdn.nlark.com/yuque/__latex/99f891ab02697fa8f7dd1712f367d491.svg)![image](https://cdn.nlark.com/yuque/__latex/8585d8ff52ee0ae34ae6bd2e133c3413.svg)

![image](https://cdn.nlark.com/yuque/__latex/f5794288c516a700737ae84b490f2ca9.svg)![image](https://cdn.nlark.com/yuque/__latex/2abce40895d78e931751b055abacc879.svg)

![image](https://cdn.nlark.com/yuque/__latex/734d44a308da2cab83567813faf1a34d.svg)![image](https://cdn.nlark.com/yuque/__latex/d4d166026fa1dec155e5b7dcb76d711c.svg)

![image](https://cdn.nlark.com/yuque/__latex/134c802fc5f0924cf1ea838feeca6c5e.svg)![image](https://cdn.nlark.com/yuque/__latex/e76b21222f75f45da4ed8c2edb903dda.svg)

![image](https://cdn.nlark.com/yuque/__latex/96dfc028779a6561cbf2cd9c9e6251a2.svg)斐波那契数列在![image](https://cdn.nlark.com/yuque/__latex/f256fe266e1c3d8b261d46c15c9a4c56.svg)意义在存在周期，称作皮萨诺周期，我们已经证明，![image](https://cdn.nlark.com/yuque/__latex/e9424f82b33766c5afe4889cad2e222e.svg)![image](https://cdn.nlark.com/yuque/__latex/4760e2f007e23d820825ba241c47ce3b.svg)的最小循环节不超过![image](https://cdn.nlark.com/yuque/__latex/ac1e81a8cde111b63ab28061e13eec2f.svg)

## 结论
![image](https://cdn.nlark.com/yuque/__latex/53072c2388d69edc65c2377681e4e87c.svg)考虑不定方程![image](https://cdn.nlark.com/yuque/__latex/e383639b50a0469f5d70645b5d35eaa5.svg)的解的数量

也就是把![image](https://cdn.nlark.com/yuque/__latex/4760e2f007e23d820825ba241c47ce3b.svg)分成![image](https://cdn.nlark.com/yuque/__latex/df378375e7693bdcf9535661c023c02e.svg)堆的方案数，我们运用插空法为![image](https://cdn.nlark.com/yuque/__latex/88172d663709eb27b9c190d6e52a0643.svg)

![image](https://cdn.nlark.com/yuque/__latex/2b89979f54ec02a7bf87aa0c1ea58ff9.svg)考虑不定方程![image](https://cdn.nlark.com/yuque/__latex/37ffb1a5c42bf1e806982a04d99f2e2d.svg)的解的数量

我们把所有的![image](https://cdn.nlark.com/yuque/__latex/3899186b08968481e6fe9fb8f22cb223.svg)那么套用结论![image](https://cdn.nlark.com/yuque/__latex/53072c2388d69edc65c2377681e4e87c.svg)，方案数为![image](https://cdn.nlark.com/yuque/__latex/d2c5b8f9241beda49d6f6077c59a34bf.svg)



![image](https://cdn.nlark.com/yuque/__latex/35bd98ee1717f8d6015cb565357765a1.svg)在![image](https://cdn.nlark.com/yuque/__latex/9c83d00b4e19bed04ddb595aa9b98a76.svg)个红球中插入![image](https://cdn.nlark.com/yuque/__latex/4760e2f007e23d820825ba241c47ce3b.svg)个蓝球，空格大小不限，可以插入两边，方案数为![image](https://cdn.nlark.com/yuque/__latex/64119b49bbea2656246e9cedd27338df.svg)

证明：考虑有![image](https://cdn.nlark.com/yuque/__latex/286ad2b5e996f314372ab315083e5718.svg)个空格可以插入，那么问题转化为不定方程![image](https://cdn.nlark.com/yuque/__latex/4900b64988423a242aadbbea4d78699f.svg)的解的个数



![image](https://cdn.nlark.com/yuque/__latex/afb0613a26341d701b3967ba170aa30c.svg)在![image](https://cdn.nlark.com/yuque/__latex/df378375e7693bdcf9535661c023c02e.svg)个红球中插入![image](https://cdn.nlark.com/yuque/__latex/4760e2f007e23d820825ba241c47ce3b.svg)个蓝球，空格大小不限，不可插入两边，方案数为![image](https://cdn.nlark.com/yuque/__latex/e2226e3147583a0cc6742577448f6ed5.svg)

证明：考虑有![image](https://cdn.nlark.com/yuque/__latex/f29219be34b160369c88fab81ea65712.svg)个空格可以插入,那么问题转化为不定方程![image](https://cdn.nlark.com/yuque/__latex/09c92dd99b293f58f19f7972804522e6.svg)的解的个数



![image](https://cdn.nlark.com/yuque/__latex/b15983bcda2a67366d095cfeb326717a.svg)考虑在![image](https://cdn.nlark.com/yuque/__latex/707f426aa893c7cde5d8b2b439f6dafa.svg)区间内选![image](https://cdn.nlark.com/yuque/__latex/6a6b811a2879516d7418f3d7325a142d.svg)个数，满足![image](https://cdn.nlark.com/yuque/__latex/df976ff7fcf17d60490267d18a1e3996.svg)个数都不相邻 问选法多少种

考虑到不能相邻的原因，我们不妨考虑把每个选的数字和它的下一个数字绑在一起，特别地最后一个数字不用捆绑，那么答案为![image](https://cdn.nlark.com/yuque/__latex/b3db32eb75335633d406cc946314dba1.svg)



![image](https://cdn.nlark.com/yuque/__latex/984ee5638727be63ceaa544f2e2e01b3.svg)从![image](https://cdn.nlark.com/yuque/__latex/3f6aef3a1c2bf15576b4beb4c266f941.svg)出发走到![image](https://cdn.nlark.com/yuque/__latex/70b6e0cc8cc05e90ebc15f07ad61290a.svg)，不能越过![image](https://cdn.nlark.com/yuque/__latex/3b4fd33534c6c2764e4898de06c3193d.svg),只能向右或者向上，方案数为![image](https://cdn.nlark.com/yuque/__latex/95304fdfc8a175f9216647c8433a6a44.svg)

# 数论
## O(1)gcd
适用于![image](https://cdn.nlark.com/yuque/__latex/a96c320a1c354c4e09700c0d89cff18c.svg)以内的数字求![image](https://cdn.nlark.com/yuque/__latex/62e1b8edc71b5f118c806bac439d870e.svg),我们传入的![image](https://cdn.nlark.com/yuque/__latex/459f3c80a50b7be28751b0869ef5386a.svg)为能接受数字的上限，![image](https://cdn.nlark.com/yuque/__latex/6f5dde593f0bc27956e14b5eaec2ed17.svg)为小表参数，复杂度为![image](https://cdn.nlark.com/yuque/__latex/31beb0091ff78533d68e83c112dfc5dc.svg)，查询可以认为是![image](https://cdn.nlark.com/yuque/__latex/a2006f1ac61cb1902beacb3e29fff089.svg)，我们一般传入![image](https://cdn.nlark.com/yuque/__latex/0fec5f7e3860b03428dfd75e9c0cada0.svg)即可。

```cpp
class FastGCD
{
    int N;                             // 支持的最大整数
    int M;                             // 小整数表上限
    std::vector<std::vector<int>> f;   // 小整数 GCD 表
    std::vector<std::array<int, 3>> d; // 每个整数拆成最多 3 块质因数
    std::vector<int> p;                // 素数数组
    std::vector<bool> v;               // 筛标记

public:
    FastGCD(int n, int m)
        : N(n), M(m), f(M + 1, std::vector<int>(M + 1)),
          d(N + 1, std::array<int, 3>{0, 0, 0}),
          v(N + 1, false)
    {
        precompute();
    }

    // =================== 普通欧几里得，用于小表生成 ===================
    int gcdNormal(int a, int b) const
    {
        while (b)
        {
            int t = a % b;
            a = b;
            b = t;
        }
        return a;
    }

private:
    void precompute()
    {
        p.clear();

        // 1. 构建小整数 GCD 表 f[i][j]，保证安全
        for (int i = 0; i <= M; i++)
        {
            for (int j = 0; j <= M; j++)
            {
                if (i == 0 || j == 0)
                    f[i][j] = i + j;
                else if (i == j)
                    f[i][j] = i;
                else if (i > j)
                    f[i][j] = f[i - j][j]; // 安全：i-j >= 1
                else
                    f[i][j] = f[j][i]; // i < j，交换
            }
        }

        // 2. 初始化 d[1]
        d[1] = std::array<int, 3>{1, 1, 1};

        // 3. 线性筛 + 分块质因数
        for (int i = 2; i <= N; i++)
        {
            if (!v[i])
            {
                p.push_back(static_cast<int>(i));
                d[i] = std::array<int, 3>{static_cast<int>(i), 1, 1};
            }
            for (size_t j = 0; j < p.size(); j++)
            {
                int k = i * p[j];
                if (k > N)
                    break;
                v[k] = true;
                d[k] = d[i]; // 继承父数质因数块
                if (d[k][0] * p[j] <= M)
                    d[k][0] *= p[j];
                else if (d[k][1] * p[j] <= M)
                    d[k][1] *= p[j];
                else
                    d[k][2] *= p[j];
                if (i % p[j] == 0)
                    break; // 线性筛剪枝
            }
        }
    }

public:
    int query(int x, int y) const
    {
        if (!x || !y)
            return x + y;
        int t = 1;
        const auto &px = d[x];
        for (int i = 0; i < 3 && y > 1; i++)
        {
            if (px[i] <= 1)
                continue;
            int k = 0;
            if (px[i] <= M)
                k = f[px[i]][y % px[i]];
            else if (y % px[i] == 0)
                k = px[i];
            if (k == 0)
                continue; // 避免除零
            t *= k;
            y /= k;
        }
        return t;
    }
};

```

## 数论基础知识
### 关于狄利克雷卷积的定义
![image](https://cdn.nlark.com/yuque/__latex/daf456f19c451a5ea4e412dedee4d483.svg)

### 质数表
```cpp
101	1009	10007	100003	1000003
103	1013	10009	100019	1000033
107	1019	10037	100043	1000037
109	1021	10039	100049	1000039
113	1031	10061	100057	1000081
127	1033	10067	100069	1000099
131	1039	10069	100103	1000117
137	1049	10079	100109	1000121
139	1051	10091	100129	1000133
149	1061	10093	100151	1000151
151	1063	10099	100153	1000159
157	1069	10103	100169	1000171
163	1087	10111	100183	1000183
167	1091	10133	100189	1000187
173	1093	10139	100193	1000193
179	1097	10141	100207	1000199
181	1103	10151	100213	1000211
191	1109	10159	100237	1000213
193	1117	10163	100267	1000231
197	1123	10169	100271	1000249
199	1129	10177	100279	1000253
211	1151	10181	100291	1000273
223	1153	10193	100297	1000289
227	1163	10211	100313	1000291
229	1171	10223	100333	1000303
233	1181	10243	100343	1000313
239	1187	10247	100357	1000333
241	1193	10253	100361	1000357
251	1201	10259	100363	1000367
257	1213	10267	100379	1000381
263	1217	10271	100391	1000393
269	1223	10273	100393	1000397
271	1229	10289	100403	1000403
277	1231	10301	100411	1000409
281	1237	10303	100417	1000423
283	1249	10313	100447	1000427
293	1259	10321	100459	1000429
307	1277	10331	100469	1000453
311	1279	10333	100483	1000457
313	1283	10337	100493	1000507
317	1289	10343	100501	1000537
331	1291	10357	100511	1000541
337	1297	10369	100517	1000547
347	1301	10391	100519	1000577
349	1303	10399	100523	1000579
353	1307	10427	100537	1000589
359	1319	10429	100547	1000609
367	1321	10433	100549	1000619
373	1327	10453	100559	1000621
379	1361	10457	100591	1000639
    
1e7~1e12
10000019	100000007	1000000007	10000000019	100000000003	1000000000039
10000079	100000037	1000000009	10000000033	100000000019	1000000000061
10000103	100000039	1000000021	10000000061	100000000057	1000000000063
10000121	100000049	1000000033	10000000069	100000000063	1000000000091
10000139	100000073	1000000087	10000000097	100000000069	1000000000121
10000141	100000081	1000000093	10000000103	100000000073	1000000000163
10000169	100000123	1000000097	10000000121	100000000091	1000000000169
10000189	100000127	1000000103	10000000141	100000000103	1000000000177
10000223	100000193	1000000123	10000000147	100000000129	1000000000189
10000229	100000213	1000000181	10000000207	100000000171	1000000000193
10000247	100000217	1000000207	10000000259	100000000183	1000000000211
10000253	100000223	1000000223	10000000277	100000000193	1000000000271
10000261	100000231	1000000241	10000000279	100000000211	1000000000303
10000271	100000237	1000000271	10000000319	100000000223	1000000000331
10000303	100000259	1000000289	10000000343	100000000237	1000000000333
10000339	100000267	1000000297	10000000391	100000000253	1000000000339
10000349	100000279	1000000321	10000000403	100000000283	1000000000459
10000357	100000357	1000000349	10000000469	100000000319	1000000000471
10000363	100000379	1000000363	10000000501	100000000363	1000000000537
10000379	100000393	1000000403	10000000537	100000000367	1000000000543
10000439	100000399	1000000409	10000000583	100000000379	1000000000547
10000451	100000421	1000000411	10000000589	100000000393	1000000000561
10000453	100000429	1000000427	10000000597	100000000403	1000000000609
10000457	100000463	1000000433	10000000601	100000000411	1000000000661
10000481	100000469	1000000439	10000000631	100000000417	1000000000669
10000511	100000471	1000000447	10000000643	100000000427	1000000000721
10000537	100000493	1000000453	10000000649	100000000447	1000000000751
10000583	100000541	1000000459	10000000667	100000000487	1000000000787
10000591	100000543	1000000483	10000000679	100000000519	1000000000789
10000609	100000561	1000000513	10000000711	100000000567	1000000000799
10000643	100000567	1000000531	10000000723	100000000579	1000000000841
10000651	100000577	1000000579	10000000741	100000000621	1000000000903
10000657	100000609	1000000607	10000000753	100000000631	1000000000921
10000667	100000627	1000000613	10000000793	100000000637	1000000000931
10000687	100000643	1000000637	10000000799	100000000669	1000000000933
10000691	100000651	1000000663	10000000807	100000000699	1000000000949
10000721	100000661	1000000711	10000000877	100000000703	1000000000997
10000723	100000669	1000000753	10000000883	100000000721	1000000001051
10000733	100000673	1000000787	10000000889	100000000739	1000000001083
10000741	100000687	1000000801	10000000949	100000000747	1000000001123
10000747	100000717	1000000829	10000000963	100000000801	1000000001159
10000759	100000721	1000000861	10000000991	100000000817	1000000001197
10000763	100000793	1000000871	10000000993	100000000819	1000000001201
10000769	100000799	1000000891	10000000999	100000000861	1000000001213
10000789	100000801	1000000901	10000001041	100000000901	1000000001243
10000799	100000837	1000000919	10000001047	100000000943	1000000001261
10000813	100000841	1000000931	10000001051	100000000951	1000000001263
10000819	100000853	1000000933	10000001057	100000001009	1000000001293
10000831	100000891	1000000993	10000001087	100000001099	1000000001303
10000849	100000921	1000001011	10000001101	100000001111	1000000001339

    
1e13~1e16
10000000000037	100000000000031	1000000000000037	10000000000000061
10000000000051	100000000000067	1000000000000091	10000000000000069
10000000000099	100000000000097	1000000000000159	10000000000000079
10000000000129	100000000000099	1000000000000187	10000000000000099
10000000000183	100000000000133	1000000000000223	10000000000000453
10000000000259	100000000000139	1000000000000241	10000000000000481
10000000000267	100000000000169	1000000000000249	10000000000000597
10000000000273	100000000000183	1000000000000259	10000000000000613
10000000000279	100000000000261	1000000000000273	10000000000000639
10000000000283	100000000000357	1000000000000279	10000000000000669
10000000000313	100000000000367	1000000000000297	10000000000000753
10000000000343	100000000000403	1000000000000357	10000000000000793
10000000000391	100000000000423	1000000000000399	10000000000000819
10000000000411	100000000000469	1000000000000403	10000000000000861
10000000000433	100000000000487	1000000000000487	10000000000000897
10000000000453	100000000000493	1000000000000513	10000000000000909
10000000000591	100000000000541	1000000000000613	10000000000000931
10000000000609	100000000000601	1000000000000711	10000000000000949
10000000000643	100000000000643	1000000000000741	10000000000000957
10000000000649	100000000000657	1000000000000783	10000000000000991
10000000000657	100000000000709	1000000000000811	10000000000001029
10000000000687	100000000000721	1000000000000843	10000000000001101
10000000000691	100000000000753	1000000000000873	10000000000001129
10000000000717	100000000000777	1000000000000921	10000000000001239
10000000000729	100000000000807	1000000000001003	10000000000001293
10000000000751	100000000000841	1000000000001027	10000000000001311
10000000000759	100000000000843	1000000000001063	10000000000001321
10000000000777	100000000000861	1000000000001089	10000000000001377
10000000000853	100000000000963	1000000000001117	10000000000001423
10000000000883	100000000000993	1000000000001209	10000000000001477
10000000000943	100000000001087	1000000000001269	10000000000001549
10000000000957	100000000001089	1000000000001293	10000000000001551
10000000000987	100000000001129	1000000000001347	10000000000001567
10000000000993	100000000001173	1000000000001371	10000000000001657
10000000001011	100000000001177	1000000000001413	10000000000001659
10000000001023	100000000001189	1000000000001491	10000000000001719
10000000001087	100000000001197	1000000000001503	10000000000001723
10000000001093	100000000001203	1000000000001551	10000000000001731
10000000001141	100000000001273	1000000000001617	10000000000001743
10000000001161	100000000001303	1000000000001623	10000000000001747
10000000001177	100000000001381	1000000000001669	10000000000001771
10000000001191	100000000001387	1000000000001741	10000000000001789
10000000001207	100000000001413	1000000000001749	10000000000001833
10000000001239	100000000001423	1000000000001819	10000000000001873
10000000001261	100000000001467	1000000000001839	10000000000001939
10000000001267	100000000001549	1000000000001867	10000000000002013
10000000001269	100000000001593	1000000000001897	10000000000002049
10000000001291	100000000001611	1000000000002037	10000000000002053
10000000001309	100000000001623	1000000000002161	10000000000002083
10000000001339	100000000001647	1000000000002193	10000000000002137

1e17	1e18
100000000000000003	1000000000000000003
100000000000000013	1000000000000000009
100000000000000019	1000000000000000031
100000000000000021	1000000000000000079
100000000000000049	1000000000000000177
100000000000000081	1000000000000000183
100000000000000099	1000000000000000201
100000000000000141	1000000000000000283
100000000000000181	1000000000000000381
100000000000000337	1000000000000000387
100000000000000339	1000000000000000507
100000000000000369	1000000000000000523
100000000000000379	1000000000000000583
100000000000000423	1000000000000000603
100000000000000519	1000000000000000619
100000000000000543	1000000000000000621
100000000000000589	1000000000000000799
100000000000000591	1000000000000000841
100000000000000609	1000000000000000861
100000000000000669	1000000000000000877
100000000000000691	1000000000000000913
100000000000000781	1000000000000000931
100000000000000787	1000000000000000997
100000000000000817	1000000000000001093
100000000000000819	1000000000000001191
100000000000000871	1000000000000001267
100000000000000889	1000000000000001323
100000000000001053	1000000000000001347
100000000000001071	1000000000000001359
100000000000001093	1000000000000001453
100000000000001099	1000000000000001459
100000000000001107	1000000000000001537
100000000000001201	1000000000000001563
100000000000001219	1000000000000001593
100000000000001221	1000000000000001659
100000000000001243	1000000000000001683
100000000000001249	1000000000000001729
100000000000001287	1000000000000001743
100000000000001293	1000000000000001771
100000000000001327	1000000000000001827
100000000000001399	1000000000000001879
100000000000001429	1000000000000001953
100000000000001449	1000000000000002049
100000000000001459	1000000000000002097
100000000000001573	1000000000000002137
100000000000001603	1000000000000002217
100000000000001623	1000000000000002271
100000000000001641	1000000000000002319
100000000000001903	1000000000000002481
100000000000001921	1000000000000002493
```

## 数论定理
### 三平方和定理
对于任意自然数![image](https://cdn.nlark.com/yuque/__latex/df378375e7693bdcf9535661c023c02e.svg)，可以表示为![image](https://cdn.nlark.com/yuque/__latex/c8c368e07e5883d7fd7a4a45d877be84.svg)形式的![image](https://cdn.nlark.com/yuque/__latex/9c83d00b4e19bed04ddb595aa9b98a76.svg)的条件是![image](https://cdn.nlark.com/yuque/__latex/95875bfd78dc2b96260c23d8f618caa9.svg)

### 拉格朗日四平方和定理
对于任意自然数![image](https://cdn.nlark.com/yuque/__latex/df378375e7693bdcf9535661c023c02e.svg)，都可以表示为![image](https://cdn.nlark.com/yuque/__latex/bdd0199b07b0e5896b542d4922281e09.svg)，其中![image](https://cdn.nlark.com/yuque/__latex/c6fffcc8fd091a6cd93470e21a0ab430.svg)可以为![image](https://cdn.nlark.com/yuque/__latex/22d0feea96d3bb2fc273f7598ce748c1.svg)

暴力代码

大约为![image](https://cdn.nlark.com/yuque/__latex/7b6e46d5a223acca301fa6b67dd2cc0e.svg)

```cpp
void fourSquares(int n)
{
    for (int a = 0; a * a <= n; ++a)
        for (int b = 0; a * a + b * b <= n; ++b)
            for (int c = 0; a * a + b * b + c * c <= n; ++c)
            {
                int d2 = n - a * a - b * b - c * c;
                int d = sqrt(d2);
                if (d * d == d2)
                {
                    std::cout << a << ' ' << b << ' ' << c << ' ' << d << '\n';
                    return;
                }
            }
}
```

优化代码

大约为![image](https://cdn.nlark.com/yuque/__latex/dcc6e7e33516b8c7bf42843b63579eb4.svg)到![image](https://cdn.nlark.com/yuque/__latex/e65a67ac353abeeff44c359310d05c02.svg)

```cpp
// 返回 n 的四平方和表示 a^2+b^2+c^2+d^2
// 尽量让 a,b,c 尽量小（更多 0）
std::vector<int> fourSquareSum(int n)
{
    std::vector<int> squares;
    std::unordered_set<int> sq_set;

    int lim = sqrt(n);
    for (int i = 0; i <= lim; ++i)
    {
        int sq = i * i;
        squares.push_back(sq);
        sq_set.insert(sq);
    }
    // 1. 检查 1 个平方数
    if (sq_set.count(n))
    {
        return {int(sqrt(n)), 0, 0, 0};
    }
    // 2. 检查 2 个平方数
    for (int a = 0; a * a <= n; ++a)
    {
        int rem = n - a * a;
        if (sq_set.count(rem))
        {
            int b = sqrt(rem);
            return {a, b, 0, 0};
        }
    }

    // 3. 检查 3 个平方数
    for (int a = 0; a * a <= n; ++a)
    {
        for (int b = 0; a * a + b * b <= n; ++b)
        {
            int rem = n - a * a - b * b;
            if (sq_set.count(rem))
            {
                int c = sqrt(rem);
                return {a, b, c, 0};
            }
        }
    }
    // 4. 最后使用 4 个平方数
    // 枚举 a,b，然后剩余 rem 用两平方和快速查找
    for (int a = 0; a * a <= n; ++a)
    {
        for (int b = 0; a * a + b * b <= n; ++b)
        {
            int rem = n - a * a - b * b;
            for (int c = 0; c * c <= rem; ++c)
            {
                int d2 = rem - c * c;
                if (sq_set.count(d2))
                {
                    int d = sqrt(d2);
                    return {a, b, c, d};
                }
            }
        }
    }
    return {0, 0, 0, 0}; // 不可能到这里
}
```

### 雅可比四平方和定理
设能满足![image](https://cdn.nlark.com/yuque/__latex/bdd0199b07b0e5896b542d4922281e09.svg)的自然数解个数为![image](https://cdn.nlark.com/yuque/__latex/5597f6b75126a594f1bf6baad7f506f5.svg),那么如果![image](https://cdn.nlark.com/yuque/__latex/df378375e7693bdcf9535661c023c02e.svg)为奇数，![image](https://cdn.nlark.com/yuque/__latex/bdb1c95f1a629a629c18d779c89762f4.svg)，否则我们记![image](https://cdn.nlark.com/yuque/__latex/d0f46ac0adcf321ff3687b386623ec75.svg),即去掉所有![image](https://cdn.nlark.com/yuque/__latex/2b89979f54ec02a7bf87aa0c1ea58ff9.svg)的质因子，此时![image](https://cdn.nlark.com/yuque/__latex/45bf5634f078de2746d986e8021fb472.svg)。其中![image](https://cdn.nlark.com/yuque/__latex/9a17313a5d24383eca69ac68f594454d.svg)表示![image](https://cdn.nlark.com/yuque/__latex/712ecf7894348e92d8779c3ee87eeeb0.svg)的约数和

### 毕达哥拉斯三元组
![image](https://cdn.nlark.com/yuque/__latex/3346dcb0ba575bbea7ad0e10d16bb7a0.svg)

令![image](https://cdn.nlark.com/yuque/__latex/220ec9166cc43d4b40c00e35ffbcdc84.svg)

如果要求![image](https://cdn.nlark.com/yuque/__latex/f1aa5d937e2358b765e0422e42e1b007.svg),条件是![image](https://cdn.nlark.com/yuque/__latex/4760e2f007e23d820825ba241c47ce3b.svg)和![image](https://cdn.nlark.com/yuque/__latex/df378375e7693bdcf9535661c023c02e.svg)至少一个是偶数且![image](https://cdn.nlark.com/yuque/__latex/5469835490c5428bcf6b117624a4bab5.svg)

### 预处理因数
我们可以在![image](https://cdn.nlark.com/yuque/__latex/b144de4c4acb502961f5ecffe942b6e9.svg)的时间内处理出![image](https://cdn.nlark.com/yuque/__latex/ae9b6ddac101f100f3085c92a3a18f56.svg)中所有数字的所有因数

```cpp
for (int i = 1; i <= N; ++i)//预处理[1,N]内所有数的所有因数
{
    for (int j = i; j <= N; j += i)
    {
        f[j].push_back(i);
    }
}
```

### 欧拉筛
```cpp
/**
 * @struct Prime
 * @brief 质数筛法结构体（欧拉筛/线性筛）
 */
struct Prime
{
    int n;                           // 筛法处理的上界
    int primeCnt = 0;                // 质数计数器
    std::vector<int> prime;          // 存储所有筛出的质数（从prime[1]开始存储）
    std::vector<bool> vis;           // 标记数组，vis[i]=true表示i是合数
    std::vector<int> minPrimeFactor; // 记录每个数的最小质因子

    /**
     * @brief 构造函数，执行线性筛法预处理
     * @param n 筛法处理的上界值
     */
    Prime(int n) : n(n), prime(n + 1), vis(n + 1), minPrimeFactor(n + 1)
    {
        // 定义并立即执行筛法lambda函数
        auto getPrime = [&]()
        {
            // 0和1不是质数，直接标记
            vis[0] = vis[1] = true;

            // 主筛法循环：从2开始到n
            for (int i = 2; i <= n; ++i)
            {
                // 如果i未被标记为合数，则它是质数
                if (!vis[i])
                {
                    prime[++primeCnt] = i; // 存入质数表
                    minPrimeFactor[i] = i; // 质数的最小质因子是其本身
                }

                // 用当前数i与已筛出的质数相乘来标记合数
                for (int j = 1; j <= primeCnt and i * prime[j] <= n; ++j)
                {
                    // 标记i*prime[j]为合数
                    minPrimeFactor[i * prime[j]] = prime[j]; // 记录最小质因子
                    vis[i * prime[j]] = true;                // 标记为合数

                    // 关键优化：保证每个合数只被最小质因子筛一次
                    if (i % prime[j] == 0)
                    {
                        break;
                    }
                }
            }
        };

        // 执行筛法
        getPrime();

        // 调整prime数组大小为实际质数数量+1（因为prime从下标1开始使用）
        prime.resize(primeCnt + 1);
    }
};
```

### 欧拉函数
欧拉函数的数论意义: ![image](https://cdn.nlark.com/yuque/__latex/eb71e2b4ba44c76e0c7b990dab46e1f8.svg)表示在![image](https://cdn.nlark.com/yuque/__latex/a76b21fda3c9d3c9705f5df0875af0d4.svg)中和![image](https://cdn.nlark.com/yuque/__latex/712ecf7894348e92d8779c3ee87eeeb0.svg)互质的数字的数量

公式：![image](https://cdn.nlark.com/yuque/__latex/3b888305fadb2ae55f31eb641a6ba86c.svg) 其中![image](https://cdn.nlark.com/yuque/__latex/43b350cceac56d796bce88982b040df1.svg)为x的质因子 ![image](https://cdn.nlark.com/yuque/__latex/36095428b8cd52cabf8b57660216f9bb.svg)为质因子数量

```cpp
/**
 * @struct Euler
 * @brief 欧拉筛法实现欧拉函数计算
 *
 * 该类使用欧拉筛法在线性时间内预处理欧拉函数值，
 * 同时记录每个数的最小质因子。
 */
struct Euler
{
    /**
     * @brief 计算单个数的欧拉函数值（适用于超出预处理范围的大数）
     * @param x 要计算欧拉函数的数
     * @return x的欧拉函数值
     */
    int getPhi(int x)
    {
        // 如果在预处理范围内，直接返回预计算值
        if (x <= n)
        {
            return phi[x];
        }

        // 对于超出预处理范围的数，直接计算欧拉函数
        int res = x;
        // 遍历可能的质因子
        for (int i = 2; i <= x / i; ++i)
        {
            if (x % i == 0)
            {                            // 找到一个质因子i
                res = res / i * (i - 1); // 欧拉函数计算公式
                // 去除所有i因子
                while (x % i == 0)
                {
                    x /= i;
                }
            }
        }
        // 处理剩余的大于1的质因子
        if (x > 1)
        {
            res = res / x * (x - 1);
        }
        return res;
    }

    int n;                           // 预处理的上界
    std::vector<int> prime;          // 存储所有预处理的质数
    std::vector<int> phi;            // 存储欧拉函数值
    std::vector<int> minPrimeFactor; // 存储每个数的最小质因子
    std::vector<bool> vis;           // 标记是否为合数
    int primeCnt = 0;                // 质数计数器

    /**
     * @brief 构造函数，执行欧拉筛预处理
     * @param n 预处理的上界
     */
    Euler(int n) : n(n),
                   prime(n + 1),
                   phi(n + 1),
                   vis(n + 1, false),
                   minPrimeFactor(n + 1)
    {
        // 定义并立即执行欧拉筛函数
        auto getPhi = [&]()
        {
            // 初始化特殊情况
            phi[0] = 0;             // 通常认为φ(0)未定义，这里设为0
            phi[1] = 1;             // φ(1) = 1
            vis[0] = vis[1] = true; // 0和1不是质数

            // 欧拉筛主循环
            for (int i = 2; i <= n; ++i)
            {
                if (!vis[i])
                {                          // i是质数
                    minPrimeFactor[i] = i; // 质数的最小质因子是其本身
                    prime[++primeCnt] = i; // 存入质数表
                    phi[i] = i - 1;        // 质数的欧拉函数值为i-1
                }

                // 用当前数i与已知质数筛合数
                for (int j = 1; j <= primeCnt && i * prime[j] <= n; ++j)
                {
                    vis[i * prime[j]] = true;                // 标记为合数
                    minPrimeFactor[i * prime[j]] = prime[j]; // 记录最小质因子

                    if (i % prime[j] == 0)
                    {
                        // i包含prime[j]因子时的欧拉函数计算
                        phi[i * prime[j]] = phi[i] * prime[j];
                        break; // 保证每个合数只被最小质因子筛一次
                    }
                    else
                    {
                        // i与prime[j]互质时的欧拉函数计算
                        phi[i * prime[j]] = phi[i] * (prime[j] - 1);
                    }
                }
            }
        };

        // 执行欧拉筛预处理
        getPhi();
    }
};
```

### 莫比乌斯函数
莫比乌斯函数最重要的性质：![image](https://cdn.nlark.com/yuque/__latex/a08a457d0e7f3e308cfc052e61a64267.svg) 用莫比乌斯反演来写 也就是 ![image](https://cdn.nlark.com/yuque/__latex/f3a695d01c161e8f931b5e9fa7c23ab1.svg)

![image](https://cdn.nlark.com/yuque/__latex/2102d856aec925265f95c687721a1e63.svg)

```cpp
struct Mobius
{
    int n; // 预计算的最大数值范围

    // 获取x的莫比乌斯函数值
    int getMo(int x)
    {
        // 如果x在预计算范围内，直接返回结果
        if (x <= n)
        {
            return mo[x];
        }
        // 否则现场计算莫比乌斯函数值
        int res = 1; // 初始化为1
        // 分解质因数
        for (int i = 2; i <= x / i; ++i)
        {
            if (x % i == 0) // 找到质因数
            {
                res *= -1;   // 每找到一个质因数，符号翻转
                int tot = 0; // 计算该质因数的指数
                while (x % i == 0)
                {
                    x /= i;
                    ++tot;
                }
                // 如果质因数的指数大于1，莫比乌斯函数值为0
                if (tot != 1)
                {
                    return 0;
                }
            }
        }
        // 处理剩余的质因数
        if (x != 1)
        {
            res *= -1;
        }
        return res;
    }

    // 下面是预计算莫比乌斯函数用到的成员变量
    std::vector<int> vis;            // 标记是否为合数
    std::vector<int> prime;          // 存储素数
    std::vector<int> mo;             // 存储莫比乌斯函数值
    std::vector<int> minPrimeFactor; // 存储最小质因子
    int primeCnt = 0;                // 素数计数器

    // 构造函数，预计算1到n的莫比乌斯函数
    Mobius(int n) : n(n), vis(n + 1), prime(n + 1), mo(n + 1), minPrimeFactor(n + 1)
    {
        vis[0] = vis[1] = 1; // 0和1不是素数
        mo[0] = mo[1] = 1;   // 0和1的莫比乌斯函数值设为1（注：实际上μ(1)=1，μ(0)通常未定义）

        // 线性筛法计算莫比乌斯函数
        for (int i = 2; i <= n; ++i)
        {
            if (!vis[i]) // i是素数
            {
                prime[++primeCnt] = i; // 记录素数
                mo[i] = -1;            // 素数的莫比乌斯函数值为-1
            }
            // 用当前已知素数筛i的倍数
            for (int j = 1; j <= primeCnt and i * prime[j] <= n; ++j)
            {
                vis[i * prime[j]] = 1; // 标记为合数
                if (i % prime[j] == 0) // i包含prime[j]的平方因子
                {
                    mo[i * prime[j]] = 0; // 莫比乌斯函数值为0
                    break;
                }
                else
                {
                    mo[i * prime[j]] = -mo[i]; // 新的素数因子，符号翻转
                }
            }
        }
    }
};
```

### 欧拉定理
![image](https://cdn.nlark.com/yuque/__latex/960b35d98374540f15a30c613b0b84a3.svg)

### 扩展欧拉定理


![image](https://cdn.nlark.com/yuque/__latex/5940b7f56228acfd7248ede5d5a81671.svg)

### 扩展欧几里得算法
即求 ![image](https://cdn.nlark.com/yuque/__latex/39878951f9a45914048e023af3072e7e.svg)的通解  根据裴蜀定理我们知道 当![image](https://cdn.nlark.com/yuque/__latex/c981d34742f826ffbb11989a5f70ebb7.svg)

所以该二元不定方程有解当且仅当![image](https://cdn.nlark.com/yuque/__latex/92de1c5fb7fff1af878ca64918e50f2d.svg) 我们考虑求出简单式的解再乘![image](https://cdn.nlark.com/yuque/__latex/a33b8bcf8ca9c99e45d7452b23485fa6.svg)即可

同时我们发现 假设一组解![image](https://cdn.nlark.com/yuque/__latex/bc4c0c4348b78c42d9fdee42b2b033d7.svg)是方程![image](https://cdn.nlark.com/yuque/__latex/b4f51f5c2794aa99a86c51b67c448dc8.svg)的一组特解

那么我们可以写出其通解  通解形式为![image](https://cdn.nlark.com/yuque/__latex/63d1b966f0dad05e71041533383f0abe.svg)

那么我们考虑求出一组特解即可 

![image](https://cdn.nlark.com/yuque/__latex/3acfc5f8dddf091fb764a667d847b2a6.svg)

再次根据裴蜀定理我们有

![image](https://cdn.nlark.com/yuque/__latex/4e9a1d5164a12efc2a4d6c9a6de56177.svg)

 结合两个式子我们有 ![image](https://cdn.nlark.com/yuque/__latex/21533bf4fa05cbb3600ed41ccad0bf6d.svg)  那么根据欧几里得算法的过程一定会递归到![image](https://cdn.nlark.com/yuque/__latex/c542e1fc123a3d8ef00aad88fd46c7c6.svg)

那么此时结果为![image](https://cdn.nlark.com/yuque/__latex/c476c8c04f03163f7443219cc7035677.svg) 至此我们的特解求解完成 最终通解仍然要乘![image](https://cdn.nlark.com/yuque/__latex/53bcab94eb2b2eb532b19ec5a3d05562.svg)

```cpp
template <class T>
class ExtendGcd
{
public:
    ExtendGcd(T a, T b, T c)
        : a(a), b(b), c(c), hasSolution(false)
    {
        Work();
    }
    // 传入 ax+by=c的参数 a b c
    std::pair<T, T> particularSolution() const
    {
        return std::make_pair(x_, y_);
    }
    std::array<T, 4> generalSolution() const
    {
        auto [x, y] = particularSolution();
        return {x, b / gcd, y, a / gcd};
        // 返回通解 {x+k*b/gcd,y+k*a/gcd}
    }

private:
    T a;              // 方程系数a
    T b;              // 方程系数b
    T c;              // 方程右侧常数c
    T gcd;            // a和b的最大公约数
    T x_;             // 特解x
    T y_;             // 特解y
    bool hasSolution; // 方程是否有解

    static T extendGcd(T a, T b, T &x, T &y)
    {
        if (b == 0)
        {
            x = 1;
            y = 0;
            return a;
        }
        T tx, ty;
        T gcd = extendGcd(b, a % b, tx, ty);
        x = ty;
        y = tx - (a / b) * ty;
        return gcd;
    }
    void Work()
    {
        // 特殊情况处理
        if (a == 0 && b == 0)
        {
            hasSolution = (c == 0);
            return;
        }

        // 计算gcd(a,b)和特解
        gcd = extendGcd(std::abs(a), std::abs(b), x_, y_);
        // 调整符号
        if (a < 0)
            x_ = -x_;
        if (b < 0)
            y_ = -y_;

        // 检查是否有解
        if (c % gcd != 0)
        {
            hasSolution = false;
            return;
        }
        // 调整特解以满足 ax + by = c
        T factor = c / gcd;
        x_ *= factor;
        y_ *= factor;

        hasSolution = true;
    }
};
```

### 扩展中国剩余定理
扩展中国剩余定理 是用来求解一次同余方程组的通解 考虑到![image](https://cdn.nlark.com/yuque/__latex/3622b047203eff368223df0b1eabd8f2.svg)会比![image](https://cdn.nlark.com/yuque/__latex/b257685f13a8c50583e9469e706b0bc2.svg)适用性更广

（![image](https://cdn.nlark.com/yuque/__latex/e9424f82b33766c5afe4889cad2e222e.svg)数可以不互质） 我们直接考虑![image](https://cdn.nlark.com/yuque/__latex/3622b047203eff368223df0b1eabd8f2.svg) 

方程形式即 ![image](https://cdn.nlark.com/yuque/__latex/e05faf457cdde2060afc3737d79e3416.svg)(我们用![image](https://cdn.nlark.com/yuque/__latex/f957591e0c3d20bc9e493f27ce6dcaff.svg)表示都满足)

我么考虑取出前两个式子 ![image](https://cdn.nlark.com/yuque/__latex/3ab89d0d185908a70d1ace208e476207.svg)，![image](https://cdn.nlark.com/yuque/__latex/cdb3d2573c26ce135db801c9a1d06160.svg)

![image](https://cdn.nlark.com/yuque/__latex/01270686c8cf272550faadf0a6d7aed5.svg)  

我们做差 得到![image](https://cdn.nlark.com/yuque/__latex/f4185aabb7bf5437f9aded0d5e8a2dae.svg) 我们通过Exgcd解出 ![image](https://cdn.nlark.com/yuque/__latex/def1d52eb996c449aaa77667cc686f3d.svg)和![image](https://cdn.nlark.com/yuque/__latex/dd5a8343eb1d63acc2763d535e9819c4.svg)的通解

我们得到![image](https://cdn.nlark.com/yuque/__latex/e9db49c67778c954a457944d8f2b7297.svg)和![image](https://cdn.nlark.com/yuque/__latex/a32c86f2ce6ab3f5ac46877bc7a84161.svg)后再次代入![image](https://cdn.nlark.com/yuque/__latex/c04de0fa488821cf6fed83d7e512dc09.svg)中 得到

 ![image](https://cdn.nlark.com/yuque/__latex/1b6d2f0a38cdf550c553287de5ff8b26.svg)  

其中![image](https://cdn.nlark.com/yuque/__latex/5fab53c9ceda709056f630f1450ea281.svg)表示刚刚解出的![image](https://cdn.nlark.com/yuque/__latex/a4a616027102313492b71d619575a499.svg)的特解

不难发现我们再次得到了一个同余式![image](https://cdn.nlark.com/yuque/__latex/ac2462398f260f52d21e3de568331df3.svg)

我们不断合并直至只剩一个式子 即得答案 复杂度![image](https://cdn.nlark.com/yuque/__latex/d94705defdf5a2c4f2f3abcf7db3d931.svg)

```cpp
template <class T>
struct ExGcd
{
    T operator()(const T &a, const T &b, T &x, T &y)
    {
        if (b == 0)
            return (x = 1, y = 0, a);
        T g = (*this)(b, a % b, y, x);
        y -= a / b * x;
        return g;
    }
};
template <class T, class G>
struct ExCrt : public ExGcd<T>
{
    std::vector<std::pair<T, T>> q;
    void insert(T a, T mod)
    {
        q.push_back({a, mod});
    }

    // 方程组 x ≡ a (模 mod) 返回最小正解
    // 无解返回 -1
    std::pair<T, T> get()
    {
        T res = 0, M = 1;
        for (auto [a, mod] : q) // 返回最小正数解和其mod数 [x,mod] 即x+k*mod均为解
        {
            T r = (a - res) % mod;
            r += (r < 0 ? mod : 0);

            T x, y;
            T g = (*this)(M, mod, x, y);
            if (r % g)
            {
                q.clear();
                return {-1, -1};
            }

            x = (G(x) * r / g % (mod / g));
            x += (x < 0 ? mod / g : 0);

            T Last = M;
            M = M / g * mod;
            res = (G(x) * Last % M + res) % M;
        }
        q.clear();
        return {res, M};
    }
};
ExCrt<int, __int128> crt;

```

### 扩展大步小步算法
我们先提出BSGS算法

BSGS的算法思想很多时候能发挥重要作用，其中文名为大步小步算法，实际上是在进行一种优雅的暴力枚举  

我们的目的是求 ![image](https://cdn.nlark.com/yuque/__latex/7da1f9f063b2beceb522480b0c1b7b10.svg)的解![image](https://cdn.nlark.com/yuque/__latex/7db4cee9e74865ab082228d786b31d61.svg)

我们设![image](https://cdn.nlark.com/yuque/__latex/221c696b133dc4b356a5669ab5821c90.svg) 其中![image](https://cdn.nlark.com/yuque/__latex/fb46325761b6cba22f29f842efdcee87.svg)我们称这个m为大步

我们移项以后![image](https://cdn.nlark.com/yuque/__latex/93a13297fc92f67542bafbc8a0cbc616.svg)我们称1为小步  

我们枚举![image](https://cdn.nlark.com/yuque/__latex/2f1c5bb55816a9229fff062a6cd7c680.svg)从![image](https://cdn.nlark.com/yuque/__latex/53072c2388d69edc65c2377681e4e87c.svg)到![image](https://cdn.nlark.com/yuque/__latex/4760e2f007e23d820825ba241c47ce3b.svg)，用哈希表存下所有左边的值，再枚举![image](https://cdn.nlark.com/yuque/__latex/036441a335dd85c838f76d63a3db2363.svg)同样从![image](https://cdn.nlark.com/yuque/__latex/53072c2388d69edc65c2377681e4e87c.svg)到![image](https://cdn.nlark.com/yuque/__latex/4760e2f007e23d820825ba241c47ce3b.svg)，求出右边的值，在哈希表中查找是否存在答案即可，我们发现所有小步的长度和等于一大步，我们发现这覆盖的范围是![image](https://cdn.nlark.com/yuque/__latex/ba908d70a83bc5fbdfa9ce3c8b816032.svg)，当![image](https://cdn.nlark.com/yuque/__latex/6cce42fd51aec4a3d923230a6fc6c107.svg)，由于扩展欧拉定理的内容,我们发现这已经可以覆盖所有情况，复杂度为![image](https://cdn.nlark.com/yuque/__latex/6d38ea90c18910788af1ee2a7abc5f8e.svg) 

然后我们考虑如何解决(a,P)不互质的情况得到EXBSGS算法

考虑把同余式转化为方程式，即![image](https://cdn.nlark.com/yuque/__latex/d5005ff3fe7a7944f4959f8d6c4ced26.svg)我们设![image](https://cdn.nlark.com/yuque/__latex/4d621edd6ecccedc332cd9a7907043ac.svg),那么由裴蜀定理

当![image](https://cdn.nlark.com/yuque/__latex/32835913e6fbc9defdfda3417a84d71e.svg)的时候原方程有解,如果有解，我们可以转化为 ![image](https://cdn.nlark.com/yuque/__latex/e99ca39169fcf929e1a42eb122f4a0e6.svg) 我们重复此过程直至

![image](https://cdn.nlark.com/yuque/__latex/138e9d4f1e675fa8c6169078b7ca474b.svg)  我们设递归了![image](https://cdn.nlark.com/yuque/__latex/e86261cda08e8f1b091579c042180487.svg)次，这![image](https://cdn.nlark.com/yuque/__latex/3d1224878814676095301edd859cb8e2.svg)次![image](https://cdn.nlark.com/yuque/__latex/7a1e6a754b7a8e45cb731688765c5e85.svg)的乘积为![image](https://cdn.nlark.com/yuque/__latex/f8df64a4bfdeb9bdcbc357668b6fb123.svg)

那么原方程为![image](https://cdn.nlark.com/yuque/__latex/c6bef4517e1aa253079ee0553383ec39.svg) 注意到此时变成了一个BSGS问题但前面多了一个常数

我们可以求其逆元丢到右边即可

```cpp
// 扩展BSGS算法：求解高次同余方程 a^x ≡ b (mod P) 的最小正整数解，其中p不需要是质数
// 参数说明：
//   a: 底数
//   b: 余数
//   P: 模数
// 返回值：
//   成功返回最小正整数解x，无解返回-1

template <class T, ll P>
class ExBsgs
{
public:
    ExBsgs() {};
    T getAns(T a, T b)
    {
        // 首先对参数取模处理
        a %= P, b %= P;

        // 特殊情况处理
        if (b == 1 || P == 1)
        { // 任何数的0次方都是1，且模1的同余式总是成立
            return T(0);
        }

        T d, k = 0, A = 1; // d:最大公约数，k:迭代次数，A:累积系数

        // 第一阶段：消除a和p的公因数
        while (true)
        {
            d = std::gcd(a, P); // 计算a和p的最大公约数
            if (d == 1)
            { // 当a和p互质时退出循环
                break;
            }
            if (b % d)
            { // 如果b不能被d整除，则方程无解
                return T(-1);
            }
            k++;                 // 迭代次数增加
            b /= d;              // 约简b
            P /= d;              // 约简p
            A = A * (a / d) % P; // 更新累积系数

            // 检查是否已经找到解
            if (A == b)
            { // 如果A ≡ b (mod P)，则当前k就是解
                return k;
            }
        }

        // 第二阶段：BSGS算法部分
        T m = ceil(sqrt(P)); // 计算分块大小

        // 预处理：构建哈希表（baby-step）
        T t = b;                         // t用于存储中间结果
        std::unordered_map<T, int> hash; // 哈希表存储值到索引的映射
        hash[b] = 0;                     // 初始状态：b*a^0 ≡ b (mod P)
        for (int j = 1; j < m; ++j)
        {
            t = t * a % P; // 计算b*a^j mod P
            hash[t] = j;   // 存入哈希表
        }

        // 计算a^m mod p（giant-step的基数）
        T mi = 1;
        for (int i = 1; i <= m; ++i)
        {
            mi = mi * a % P;
        }

        // 搜索匹配项（giant-step）
        t = A; // 从累积系数A开始
        for (int i = 1; i <= m; ++i)
        {
            t = t * mi % P; // 计算A*(a^m)^i mod P
            if (hash.count(t))
            { // 如果在哈希表中找到匹配
                // 解为：i*m - hash[t] + k
                return T(i * m - hash[t] + k);
            }
        }
        // 没有找到解
        return T(-1);
    }
};
```

### 卢卡斯定理


即 ![image](https://cdn.nlark.com/yuque/__latex/ff13b8fa404057f9d395d2cd1d08b12d.svg)

不难发现我们写个递归函数就行，请注意递归出口是![image](https://cdn.nlark.com/yuque/__latex/862a9525dbfad9c15ee89508e3e2c0d6.svg)，此时返回![image](https://cdn.nlark.com/yuque/__latex/53072c2388d69edc65c2377681e4e87c.svg)。

### 原根 
阶的定义 ：在![image](https://cdn.nlark.com/yuque/__latex/bf39ac94588137775cc3e0fc4f421251.svg)意义下 满足![image](https://cdn.nlark.com/yuque/__latex/00aebd591456ab94132952aa0094b26e.svg)的最小正整数![image](https://cdn.nlark.com/yuque/__latex/6a6b811a2879516d7418f3d7325a142d.svg)称作![image](https://cdn.nlark.com/yuque/__latex/f8b64cc73b7848a50ed9317d01128637.svg)![image](https://cdn.nlark.com/yuque/__latex/b2dd994a7b9eb4e994544cea27860ce4.svg) 意义下的阶

原根的定义：一个数在![image](data:image/svg+xml;utf8,%3Csvg%20xmlns%3Axlink%3D%22http%3A%2F%2Fwww.w3.org%2F1999%2Fxlink%22%20width%3D%224.965ex%22%20height%3D%222.176ex%22%20style%3D%22vertical-align%3A%20-0.338ex%3B%22%20viewBox%3D%220%20-791.3%202137.5%20936.9%22%20role%3D%22img%22%20focusable%3D%22false%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20aria-labelledby%3D%22MathJax-SVG-1-Title%22%3E%0A%3Ctitle%20id%3D%22MathJax-SVG-1-Title%22%3Emod%20%5C%3C%2Ftitle%3E%0A%3Cdefs%20aria-hidden%3D%22true%22%3E%0A%3Cpath%20stroke-width%3D%221%22%20id%3D%22E1-MJMATHI-6D%22%20d%3D%22M21%20287Q22%20293%2024%20303T36%20341T56%20388T88%20425T132%20442T175%20435T205%20417T221%20395T229%20376L231%20369Q231%20367%20232%20367L243%20378Q303%20442%20384%20442Q401%20442%20415%20440T441%20433T460%20423T475%20411T485%20398T493%20385T497%20373T500%20364T502%20357L510%20367Q573%20442%20659%20442Q713%20442%20746%20415T780%20336Q780%20285%20742%20178T704%2050Q705%2036%20709%2031T724%2026Q752%2026%20776%2056T815%20138Q818%20149%20821%20151T837%20153Q857%20153%20857%20145Q857%20144%20853%20130Q845%20101%20831%2073T785%2017T716%20-10Q669%20-10%20648%2017T627%2073Q627%2092%20663%20193T700%20345Q700%20404%20656%20404H651Q565%20404%20506%20303L499%20291L466%20157Q433%2026%20428%2016Q415%20-11%20385%20-11Q372%20-11%20364%20-4T353%208T350%2018Q350%2029%20384%20161L420%20307Q423%20322%20423%20345Q423%20404%20379%20404H374Q288%20404%20229%20303L222%20291L189%20157Q156%2026%20151%2016Q138%20-11%20108%20-11Q95%20-11%2087%20-5T76%207T74%2017Q74%2030%20112%20181Q151%20335%20151%20342Q154%20357%20154%20369Q154%20405%20129%20405Q107%20405%2092%20377T69%20316T57%20280Q55%20278%2041%20278H27Q21%20284%2021%20287Z%22%3E%3C%2Fpath%3E%0A%3Cpath%20stroke-width%3D%221%22%20id%3D%22E1-MJMATHI-6F%22%20d%3D%22M201%20-11Q126%20-11%2080%2038T34%20156Q34%20221%2064%20279T146%20380Q222%20441%20301%20441Q333%20441%20341%20440Q354%20437%20367%20433T402%20417T438%20387T464%20338T476%20268Q476%20161%20390%2075T201%20-11ZM121%20120Q121%2070%20147%2048T206%2026Q250%2026%20289%2058T351%20142Q360%20163%20374%20216T388%20308Q388%20352%20370%20375Q346%20405%20306%20405Q243%20405%20195%20347Q158%20303%20140%20230T121%20120Z%22%3E%3C%2Fpath%3E%0A%3Cpath%20stroke-width%3D%221%22%20id%3D%22E1-MJMATHI-64%22%20d%3D%22M366%20683Q367%20683%20438%20688T511%20694Q523%20694%20523%20686Q523%20679%20450%20384T375%2083T374%2068Q374%2026%20402%2026Q411%2027%20422%2035Q443%2055%20463%20131Q469%20151%20473%20152Q475%20153%20483%20153H487H491Q506%20153%20506%20145Q506%20140%20503%20129Q490%2079%20473%2048T445%208T417%20-8Q409%20-10%20393%20-10Q359%20-10%20336%205T306%2036L300%2051Q299%2052%20296%2050Q294%2048%20292%2046Q233%20-10%20172%20-10Q117%20-10%2075%2030T33%20157Q33%20205%2053%20255T101%20341Q148%20398%20195%20420T280%20442Q336%20442%20364%20400Q369%20394%20369%20396Q370%20400%20396%20505T424%20616Q424%20629%20417%20632T378%20637H357Q351%20643%20351%20645T353%20664Q358%20683%20366%20683ZM352%20326Q329%20405%20277%20405Q242%20405%20210%20374T160%20293Q131%20214%20119%20129Q119%20126%20119%20118T118%20106Q118%2061%20136%2044T179%2026Q233%2026%20290%2098L298%20109L352%20326Z%22%3E%3C%2Fpath%3E%0A%3C%2Fdefs%3E%0A%3Cg%20stroke%3D%22currentColor%22%20fill%3D%22currentColor%22%20stroke-width%3D%220%22%20transform%3D%22matrix(1%200%200%20-1%200%200)%22%20aria-hidden%3D%22true%22%3E%0A%20%3Cuse%20xlink%3Ahref%3D%22%23E1-MJMATHI-6D%22%20x%3D%220%22%20y%3D%220%22%3E%3C%2Fuse%3E%0A%20%3Cuse%20xlink%3Ahref%3D%22%23E1-MJMATHI-6F%22%20x%3D%22878%22%20y%3D%220%22%3E%3C%2Fuse%3E%0A%20%3Cuse%20xlink%3Ahref%3D%22%23E1-MJMATHI-64%22%20x%3D%221364%22%20y%3D%220%22%3E%3C%2Fuse%3E%0A%3C%2Fg%3E%0A%3C%2Fsvg%3E)意义下的阶等于 ![image](https://cdn.nlark.com/yuque/__latex/4d1f4936bb937e481623bc8568e8164e.svg) 那么该数称作![image](https://cdn.nlark.com/yuque/__latex/ffd1905f6d4d60accedfa6b91be93ea9.svg)的一个原根

首先已有数学家证明 一个数![image](https://cdn.nlark.com/yuque/__latex/c313da45855d219109d79253e9e4a276.svg)的最小原根不会超过![image](https://cdn.nlark.com/yuque/__latex/82b6b1a55b803bbddd3d5beb2b62caa5.svg)

所以我们考虑从小到大暴力枚举 

 在此之前我们已经证明 只有 ![image](https://cdn.nlark.com/yuque/__latex/19b397b2525a929c98a9a75c161847f2.svg)存在原根（这里P是质数）

所以我们先通过欧拉筛预处理 判断出一个数是否存在原根  

 在存在的情况下 我们先求出最小原根  从1开始枚举 然后对每个数分别Check

假设我们枚举到数字![image](https://cdn.nlark.com/yuque/__latex/7db4cee9e74865ab082228d786b31d61.svg) 我们枚举![image](https://cdn.nlark.com/yuque/__latex/2a84c0b2e874ea7901950f2ae74f6043.svg)的所有质因数![image](https://cdn.nlark.com/yuque/__latex/d4cd21d60552e207f237e82def9029b6.svg) 如果![image](https://cdn.nlark.com/yuque/__latex/1117e55fa8af04525c9b12512a138c44.svg)也是![image](https://cdn.nlark.com/yuque/__latex/712ecf7894348e92d8779c3ee87eeeb0.svg)的阶  那么![image](https://cdn.nlark.com/yuque/__latex/712ecf7894348e92d8779c3ee87eeeb0.svg)就不是![image](https://cdn.nlark.com/yuque/__latex/ffd1905f6d4d60accedfa6b91be93ea9.svg)的原根

当我们找到最小原根![image](https://cdn.nlark.com/yuque/__latex/6fe0d2c9fb7f3a4532c0e27bc592bc63.svg)后 对于所有的![image](https://cdn.nlark.com/yuque/__latex/e02bb57caad04f278aba26d0001b8e01.svg)满足![image](https://cdn.nlark.com/yuque/__latex/b6d9031a598b54dd581eb5dfc7e2aee8.svg)的所有![image](https://cdn.nlark.com/yuque/__latex/c63044f420b043d8cb76d93a061887bd.svg) ，满足![image](https://cdn.nlark.com/yuque/__latex/9a2217ae8e38484cdca99356091546fd.svg)也是原根

至此我们得到了求出所有原根的方法 

且根据最后一个定理 我们知道 一个数![image](https://cdn.nlark.com/yuque/__latex/ffd1905f6d4d60accedfa6b91be93ea9.svg)如果存在原根 那么它将有![image](https://cdn.nlark.com/yuque/__latex/1a18c47d18a0f86650ef16e18a99a298.svg)个原根



```cpp

/**
 * @class PrimitiveRootFinder
 * @brief 原根求解器
 *
 * 该类封装了求解模数x的最小原根及其所有原根的方法，
 * 基于欧拉函数和快速幂算法实现。
 */
class PrimitiveRootFinder
{
public:
    /**
     * @brief 构造函数，初始化欧拉筛实例
     * @param euler 预初始化的欧拉筛类实例
     */
    PrimitiveRootFinder() {}

    /**
     * @brief 判断给定数x是否存在原根
     * @param x 要判断的数
     * @return 如果x有原根返回true，否则false
     *
     * @note 根据数论理论，只有以下形式的数有原根：
     * 1. 1, 2, 4
     * 2. p^a，其中p是奇素数
     * 3. 2*p^a，其中p是奇素数
     */
    bool hasRoot(int x) const
    {
        // 特殊情况处理
        if (x == 1 || x == 2 || x == 4)
        {
            return true;
        }

        // 处理偶数情况
        if (x % 2 == 0)
        {
            x /= 2;
            // 如果除以2后还是偶数，则不符合2*p^a的形式
            if (x % 2 == 0)
            {
                return false;
            }
        }

        // 检查是否为p^a的形式
        int primeFactor = euler.minPrimeFactor[x];
        if (primeFactor == 2)
        {
            return false; // 不满足p是奇素数的条件
        }

        // 检查x是否能被分解为p^a
        while (x % primeFactor == 0)
        {
            x /= primeFactor;
        }

        // 如果x被完全分解，说明是p^a的形式
        return x == 1;
    }

    /**
     * @brief 获取模x的最小原根
     * @param x 要求原根的模数
     * @return 最小原根，如果不存在原根则返回-1
     */
    int findMinRoot(int x) const
    {
        if (!hasRoot(x))
        {
            return -1;
        }

        const int phi = euler.getPhi(x);
        const auto primeFactors = getPrimeFactor(phi);

        // 枚举可能的g值寻找最小原根
        for (int g = 1;; ++g)
        {
            // 检查g^phi ≡ 1 P x
            if (fpow(g, phi, x) != 1)
            {
                continue;
            }

            // 检查g^(phi/p) ≠ 1 P x 对所有phi的素因子p
            bool isPrimitive = true;
            for (int p : primeFactors)
            {
                if (fpow(g, phi / p, x) == 1)
                {
                    isPrimitive = false;
                    break;
                }
            }

            if (isPrimitive)
            {
                return g;
            }
        }
    }

    /**
     * @brief 获取模x的所有原根
     * @param x 要求原根的模数
     * @return 包含所有原根的vector，按升序排列
     */
    std::vector<int> findAllRoot(int x) const
    {
        std::vector<int> roots;

        const int g = findMinRoot(x);
        if (g == -1)
        {
            return roots;
        }
        roots.push_back(g);
        const int phi = euler.getPhi(x);
        int current = g;
        // 生成所有原根：g^k，其中gcd(k, phi) = 1
        for (int k = 2; k < phi; ++k)
        {
            current = current * g % x;
            if (std::gcd(k, phi) == 1)
            {
                roots.push_back(current);
            }
        }

        std::sort(roots.begin(), roots.end());
        return roots;
    }

private:
    /**
     * @brief 快速幂算法
     * @param a 底数
     * @param b 指数
     * @param P 模数
     * @return (a^b) % P
     */
    static int fpow(int a, int b, int P)
    {
        int res = 1;
        a %= P;
        while (b > 0)
        {
            if (b & 1)
            {
                res = 1ll * res * a % P;
            }
            b >>= 1;
            a = 1ll * a * a % P;
        }
        return res;
    }

    /**
     * @brief 获取数的所有不同质因数
     * @param n 要分解的数
     * @return 包含n的所有不同质因数的vector
     */
    std::vector<int> getPrimeFactor(int n) const
    {
        std::vector<int> factors;
        if (n == 1)
        {
            return factors;
        }
        while (n != 1)
        {
            int p = euler.minPrimeFactor[n];
            factors.push_back(p);
            while (n % p == 0)
            {
                n /= p;
            }
        }
        return factors;
    }
};
```

### ![image](https://cdn.nlark.com/yuque/__latex/69927ea44e92f8ba1873989db1527b18.svg)方程
即![image](https://cdn.nlark.com/yuque/__latex/99e89ef5c59a9027026019da2de66b65.svg)，求最小正整数解![image](https://cdn.nlark.com/yuque/__latex/a969cab25db24b7b40ddd3064d3ab658.svg)

由于答案可以很大，代码由![image](https://cdn.nlark.com/yuque/__latex/18b296c1a8faff2fef487f056f6b50f8.svg)实现

具体求解方法涉及连分数，这里不过多介绍

```cpp
n = int(raw_input())
j = 1
while j * j < n:
    j += 1
if j * j == n:
    print(j, 1)
if j * j > n:
    p = [0 for i in range(0, 1001)]
    q = [0 for i in range(0, 1001)]
    a = [0 for i in range(0, 1001)]
    g = [0 for i in range(0, 1001)]
    h = [0 for i in range(0, 1001)]
    p[1] = q[0] = h[1] = 1
    p[0] = q[1] = g[1] = 0
    a[2] = j - 1
    i = 2
    while 1:
        g[i] = -g[i - 1] + a[i] * h[i - 1]
        h[i] = (n - g[i] * g[i]) / h[i - 1]
        a[i + 1] = (g[i] + a[2]) / h[i]
        p[i] = a[i] * p[i - 1] + p[i - 2]
        q[i] = a[i] * q[i - 1] + q[i - 2]
        if (p[i] * p[i] - n * q[i] * q[i] == 1):
            print(p[i], q[i])
            break
        i += 1
```

### 类欧几里得算法
类欧算法是一类特定式子的求和方法 

![image](https://cdn.nlark.com/yuque/__latex/5475bc9be2d06505acdd416d108bc702.svg)

![image](https://cdn.nlark.com/yuque/__latex/812373f03f6552e7ca77238f7df40c94.svg)

![image](https://cdn.nlark.com/yuque/__latex/afdbaaa7045fee35244d1e71e1e65d0d.svg)

注意代码并没有处理取模的问题

第一段代码只解决了![image](https://cdn.nlark.com/yuque/__latex/7aaf2781990aa336d909f7ebd32e2f69.svg)的值

递推公式为

若![image](https://cdn.nlark.com/yuque/__latex/4ac0c24ad7077ef127a52a1779195e4e.svg)

![image](https://cdn.nlark.com/yuque/__latex/f986486be1c1c055e26009c170018c4e.svg)

否则

![image](https://cdn.nlark.com/yuque/__latex/a6cbaea8e4b7624bb9b43d1925177c16.svg)，其中![image](https://cdn.nlark.com/yuque/__latex/bcee3d9fd163a11078de3becf7614be1.svg)

递归出口为![image](https://cdn.nlark.com/yuque/__latex/4f5ad05673a64264b0f373fe0c328347.svg)

```cpp

int calc(int a, int b, int c, int n) //(ai+b)/c 对i属于[0,n]求和
{
    if (a == 0)
    {
        return b / c * (n + 1);
    }
    else if (a >= c || b >= c)
    {
        return (a / c) * n * (n + 1) / 2 + (b / c) * (n + 1) + calc(a % c, b % c, c, n);
    }
    else
    {
        return (a * n + b) / c * n - calc(c, c - b - 1, a, (a * n + b) / c - 1);
    }
}
```

第二段代码同时解决了![image](https://cdn.nlark.com/yuque/__latex/a09ba0177a0239b60973c0db8a6587f0.svg)

推导公式过于复杂不再描述

```cpp
const int inv2=
const int inv6=
const int P=
struct val
{
    int f; //(ai+b)/c 对i属于[0,n]求和
    int g; //[(ai+b)/c]*[(ai+b)/c]对i属于[0,n]求和
    int h; //[(ai+b)/c]*i对i属于[0,n]求和
};
val calc(int a, int b, int c, int n)
{
    val ans, prec;
    if (a == 0)
    {
        ans.f = b / c * (n + 1);
        ans.g = b / c * n * (n + 1) * inv2;
        ans.h = b / c * (b / c) * (n + 1);
    }
    else if (a >= c || b >= c)
    {
        prec = calc(a % c, b % c, c, n);
        ans.f = (prec.f + n * (n + 1) * inv2 * (a / c) + (n + 1) * (b / c));
        ans.g = ((a / c) * n * (n + 1) * (2 * n + 1) * inv6 + (b / c) * n * (n + 1) * inv2 + prec.g);
        ans.h = (prec.h + (a / c) * (a / c) * n * (n + 1) * (2 * n + 1) * inv6 + (n + 1) * (b / c) * (b / c) + 2 * (a / c) * prec.g + 2 * (b / c) * prec.f + 2 * (a / c) * (b / c) * n * (n + 1) * inv2);
    }
    else
    {
        int m = (a * n + b) / c;
        prec = calc(c, c - b - 1, a, m - 1);
        ans.f = (n * m-prec.f);
        ans.g = (n * (n + 1) * m-prec.f - prec.h) * inv2;
        ans.h = (n * m * (m + 1) - 2 * prec.g - 2 * prec.f - ans.f);
    }
    return ans;
}
```

### 整除分块
我们考虑如何解决各式各样的整除分块

我们先考虑一维的情况

即![image](https://cdn.nlark.com/yuque/__latex/1a399c49c7115c8685ad9e97fe96b13a.svg)其中m是常数 ![image](https://cdn.nlark.com/yuque/__latex/14d520e07bd730c1cc22396bd18ce107.svg)为单元函数且单调增加,我们只需要每次求出右端点![image](https://cdn.nlark.com/yuque/__latex/22d1b39b0ae42548b9a5ad4bdc0f3842.svg)，然后![image](https://cdn.nlark.com/yuque/__latex/8a435fd147a5e413b87b6944de88fc0a.svg)即可，问题在于如何求出![image](https://cdn.nlark.com/yuque/__latex/dd1caa3f2e1582dab2cf9bfdb21b7556.svg)，我们来推式子

首先我们已经知道左端点![image](https://cdn.nlark.com/yuque/__latex/c895173d3be4872abf206be4268a58cb.svg)，也就相当于知道了当前的值![image](https://cdn.nlark.com/yuque/__latex/8597b8ad64ac82614635dd0459956516.svg)也就是说![image](https://cdn.nlark.com/yuque/__latex/9521b9fd7f34816b6274587c5c172382.svg)那么![image](https://cdn.nlark.com/yuque/__latex/dd1caa3f2e1582dab2cf9bfdb21b7556.svg)应该满足![image](https://cdn.nlark.com/yuque/__latex/0e691eb122d55b7223c3c82d4e0f80e4.svg) 那么![image](https://cdn.nlark.com/yuque/__latex/37439c886b89037b1cfe755a5a6c795d.svg)

然后我们考虑二维的情况，一般形式为![image](https://cdn.nlark.com/yuque/__latex/4197695c6f77a3f5930906da7fc0f15c.svg)，在这种情况下我们发现有两个限制，但我们只需要每次操作取他们的交集即可，因为有![image](https://cdn.nlark.com/yuque/__latex/8a435fd147a5e413b87b6944de88fc0a.svg)在。可以保证全覆盖

也就是取![image](https://cdn.nlark.com/yuque/__latex/eb6e672b3b417d81e6e7572ee9b849c6.svg)，至于函数的形式我们参考一维即可

```cpp
std::vector<std::pair<ll, ll>> floorBlock(ll n, ll m)
// n/i i从1到m的整除分块区间
{
    std::vector<std::pair<ll, ll>> res;
    for (ll l = 1, r; l <= std::min(n, m); l = r + 1)
    {
        r = std::min(n / (n / l), std::min(n, m));
        res.emplace_back(l, r);
    }
    return res;
}
```

上取整的整除分块

```cpp
std::vector<std::pair<ll, ll>> ceilBlock(ll n)
// n/i向上取整的分块区间
{
    std::vector<std::pair<ll, ll>> res;
    for (ll l = 1, r; l <= n; l = r + 1)
    {
        ll val = (n + l - 1) / l;
        r = (val == 1 ? n : (n - 1) / (val - 1));
        res.emplace(l, r);
    }
    return res;
}
```

### 莫比乌斯反演
其实就是一个式子

如果![image](https://cdn.nlark.com/yuque/__latex/5b72fd903620cb75d857562841927406.svg)那么有![image](https://cdn.nlark.com/yuque/__latex/bb930c3fa26d3dd2c33f2d914cf9668e.svg)

当然也和![image](https://cdn.nlark.com/yuque/__latex/a2d39f42e69bca1e8da454427c1bca71.svg)等价

### 杜教筛
杜教筛是一种能在亚线性时间内求出积性函数前缀和的方法

构造方法如下

我们设![image](https://cdn.nlark.com/yuque/__latex/d0103d8bdd582d9114bab6698940d2e4.svg)表示所求函数，![image](https://cdn.nlark.com/yuque/__latex/7a1e6a754b7a8e45cb731688765c5e85.svg)表示辅助函数，![image](https://cdn.nlark.com/yuque/__latex/55fc237afbe535f7d8434985b848a6a7.svg)表示前缀和函数

那么我们有如下式子

![image](https://cdn.nlark.com/yuque/__latex/3e310e5d95e1229d86d8d200fb8382c4.svg)



加入我们可以构造恰当的数论函数![image](https://cdn.nlark.com/yuque/__latex/7a1e6a754b7a8e45cb731688765c5e85.svg)使得:

1.可以快速计算![image](https://cdn.nlark.com/yuque/__latex/71de888b5efbd2662ef2622d36c3d082.svg)

2可以快速计算![image](https://cdn.nlark.com/yuque/__latex/7a1e6a754b7a8e45cb731688765c5e85.svg)的前缀和，从而用数论分块来递归求解![image](https://cdn.nlark.com/yuque/__latex/6bd52f7eac8ddc50f9922bb0abaf8da1.svg)

我们发现构造是一个困难的事情 我们在此给出欧拉函数和莫比乌斯函数的板子

对于欧拉函数 我们可以构造![image](https://cdn.nlark.com/yuque/__latex/fe99d028b84a110d78ae16d0cf7cf564.svg)

对于莫比乌斯函数 我们可以构造 ![image](https://cdn.nlark.com/yuque/__latex/b76b4a977f747c03e9988badc31ab04e.svg)

套公式即可

```cpp
// 杜教筛模板类，用于高效计算欧拉函数φ(n)和莫比乌斯函数μ(n)的前缀和
struct DujiaoSieve
{
    const int N = 2e6;
    std::vector<int> prime, phi, mo;
    std::vector<bool> vis;
    int primeCnt = 0;
    // 哈希表，用于存储已经计算过的前缀和结果（记忆化）
    std::unordered_map<ll, int> hashPhi; // 存储欧拉函数前缀和
    std::unordered_map<ll, int> hashMo;  // 存储莫比乌斯函数前缀和

    // 构造函数，初始化时调用init()进行预处理
    DujiaoSieve() : prime(N + 1), phi(N + 1), mo(N + 1), vis(N + 1, 0)
    {
        init();
    }

    // 初始化函数，使用线性筛预处理前N个数的φ和μ值及其前缀和
    void init()
    {
        // 初始化1的特殊情况
        mo[1] = phi[1] = 1;

        // 线性筛法（欧拉筛）
        for (int i = 2; i <= N; ++i)
        {
            if (!vis[i])
            {                          // 如果i是素数
                prime[++primeCnt] = i; // 记录素数
                phi[i] = i - 1;        // 素数的欧拉函数值为i-1
                mo[i] = -1;            // 素数的莫比乌斯函数值为-1
            }

            // 用当前已知素数筛i的倍数
            for (int j = 1; i * prime[j] <= N && j <= primeCnt; ++j)
            {
                vis[i * prime[j]] = true; // 标记为合数

                if (i % prime[j] == 0)
                {                                          // i包含prime[j]的平方因子
                    mo[i * prime[j]] = 0;                  // 莫比乌斯函数值为0（可以不写，因为默认初始化为0）
                    phi[i * prime[j]] = phi[i] * prime[j]; // 欧拉函数性质
                    break;                                 // 保证每个数只被最小质因子筛一次
                }
                else
                {
                    mo[i * prime[j]] = -mo[i];                   // 新的素数因子，莫比乌斯函数符号翻转
                    phi[i * prime[j]] = phi[i] * (prime[j] - 1); // 欧拉函数性质
                }
            }
        }

        // 计算前缀和数组
        for (int i = 1; i <= N; ++i)
        {
            phi[i] += phi[i - 1]; // 欧拉函数前缀和
            mo[i] += mo[i - 1];   // 莫比乌斯函数前缀和
        }
    }

    // 计算欧拉函数前缀和（杜教筛核心）
    ll prePhi(int n)
    {
        if (n < N)
        { // 如果在预处理范围内，直接返回
            return phi[n];
        }
        if (hashPhi.count(n))
        { // 如果已经计算过，直接从哈希表中取
            return hashPhi[n];
        }

        // 初始估计值（利用欧拉函数求和公式）
        ll ans = 1ll * n * (n + 1) / 2;

        // 分块处理，利用数论分块优化
        for (int l = 2, r; l <= n; l = r + 1)
        {
            r = n / (n / l);                          // 计算当前块的右边界
            ans -= 1ll * prePhi(n / l) * (r - l + 1); // 递归计算并减去贡献
        }

        return hashPhi[n] = ans; // 存储结果到哈希表并返回
    }

    // 计算莫比乌斯函数前缀和（杜教筛核心）
    ll preMo(int n)
    {
        if (n < N)
        { // 如果在预处理范围内，直接返回
            return mo[n];
        }
        if (hashMo.count(n))
        { // 如果已经计算过，直接从哈希表中取
            return hashMo[n];
        }

        // 初始值为1（因为μ(1)=1）
        ll ans = 1;

        // 分块处理，利用数论分块优化
        for (int l = 2, r; l <= n; l = r + 1)
        {
            r = n / (n / l);                         // 计算当前块的右边界
            ans -= 1ll * preMo(n / l) * (r - l + 1); // 递归计算并减去贡献
        }

        return hashMo[n] = ans; // 存储结果到哈希表并返回
    }
};
DujiaoSieve Sieve; 
```

### Min25筛
min25筛是统计一类函数前缀和的方法

这类函数有如下特征

1 ![image](https://cdn.nlark.com/yuque/__latex/eceed646f08b94f8d4d3c45c9ce23a89.svg)可以被表示成简单多项式的形式

2 ![image](https://cdn.nlark.com/yuque/__latex/3fb91e4dbc6af83409a47416fcea55d8.svg)需要容易求得

Min25筛的核心思想是把质数和合数的贡献分开统计，这样同时解决了一些函数质数前缀和的问题

我们设我们要求![image](https://cdn.nlark.com/yuque/__latex/b617df9964e4d3287efc478dbbe71813.svg)

我们先考虑质数如何计算 设![image](https://cdn.nlark.com/yuque/__latex/c5f537812b5ba120337c1f7efcde76b6.svg)其中![image](https://cdn.nlark.com/yuque/__latex/63764e7fee036e73cd4c08d5bd1f1130.svg)

共![image](https://cdn.nlark.com/yuque/__latex/2793099738fd905b9103793403bd03f8.svg)种取值

我们考虑DP,设![image](https://cdn.nlark.com/yuque/__latex/045f6e6f79bbcadc8187ccf28e5ff546.svg)其中![image](https://cdn.nlark.com/yuque/__latex/8c0e127b02c7fff195a6a37cac37f124.svg)表示![image](https://cdn.nlark.com/yuque/__latex/2443fbcfeb7e85e1d62b6f5e4f27207e.svg)的最小质因子，![image](https://cdn.nlark.com/yuque/__latex/425d09e6f8fbe541d0ca5f60c2dc6830.svg)是另一个我们构造出的函数，满足以下条件

![image](https://cdn.nlark.com/yuque/__latex/391675ec20484f03878832dc49e89c84.svg)

![image](https://cdn.nlark.com/yuque/__latex/425d09e6f8fbe541d0ca5f60c2dc6830.svg)是完全积性函数

![image](https://cdn.nlark.com/yuque/__latex/425d09e6f8fbe541d0ca5f60c2dc6830.svg)可以快速求前缀和

DP边界为![image](https://cdn.nlark.com/yuque/__latex/8b5c8b1405328c660cd56b037e09403e.svg)

那么我们的转移有

![image](https://cdn.nlark.com/yuque/__latex/dad448b9cb7d3c095a4e394c259da3d2.svg)因为这里显然不会多出数字满足![image](https://cdn.nlark.com/yuque/__latex/3b4b7d51709f93830ae663f15848de4d.svg)

![image](https://cdn.nlark.com/yuque/__latex/57516f83a08dde0c16a53fab58747b1d.svg)

这里的意义是减去最小质因子为![image](https://cdn.nlark.com/yuque/__latex/d4ceb09b07019c5e59139c2c226e9a85.svg)的数字的贡献 利用了完全积性函数的性质

令![image](https://cdn.nlark.com/yuque/__latex/76906cc0d44658d42eae0c527c6f44c5.svg)表示小于等于![image](https://cdn.nlark.com/yuque/__latex/4760e2f007e23d820825ba241c47ce3b.svg)的质数个数,那么![image](https://cdn.nlark.com/yuque/__latex/fd5fefb9c3e353b803b9082fed79bde0.svg)即为我们所求的![image](https://cdn.nlark.com/yuque/__latex/9a64e39dd4a1c827381171cb8602c046.svg)

当然我们会把第一维滚掉 用整除分块求出所有![image](https://cdn.nlark.com/yuque/__latex/4760e2f007e23d820825ba241c47ce3b.svg)并用![image](https://cdn.nlark.com/yuque/__latex/5c3b519e0e865d41cbab2cf0be94e64e.svg)数组映射

至此我们已经完成了质数前缀和的工作，我们想求出所有数的前缀和，还需要二次![image](https://cdn.nlark.com/yuque/__latex/cdaf04cddf57ae63edeafceb53eb4044.svg)

我们设![image](https://cdn.nlark.com/yuque/__latex/e310155b59a967edd16ede70c8e91f53.svg)那么最终答案为![image](https://cdn.nlark.com/yuque/__latex/430c2008d1176266a071d30aa4dbc45d.svg)

有递推式

![image](https://cdn.nlark.com/yuque/__latex/c9b9f4c73017dee00cbdffb7d41cbf96.svg)

请注意 对![image](https://cdn.nlark.com/yuque/__latex/df378375e7693bdcf9535661c023c02e.svg)求出的![image](https://cdn.nlark.com/yuque/__latex/c5fc17a89338dc827f3a850b0606de25.svg)筛只能得到所有的![image](https://cdn.nlark.com/yuque/__latex/1deba3022dcdf4fb2c455725eac8427b.svg)位置的质数前缀和

在模板中 ![image](https://cdn.nlark.com/yuque/__latex/b20e79ea8f3edb0ffd6c2a3f100c8977.svg)，对于不同的函数我们只需要修改![image](https://cdn.nlark.com/yuque/__latex/d4d93c5e400822fbb0907e3d0c971e12.svg)函数

注意取模！！！

```cpp
struct Min25
{
    int n;            // 要计算前缀和的上界
    int block;        // 分块大小，取sqrt(n)
    int primeCnt = 0; // 素数计数器

    // 存储分块信息：
    std::vector<int> lowBlockId;  // 存储小于等于block的值的id
    std::vector<int> highBlockId; // 存储大于block的值的id
    std::vector<int> w;           // 存储所有分块点的值

    std::vector<int> g;     // 存储g函数的前缀和
    std::vector<int> prime; // 存储预处理的小素数
    std::vector<int> vis;   // 筛法标记数组
    std::vector<int> primePrefix;

    // 根据值val获取其在w数组中的索引
    int getId(int val)
    {
        return (val <= block ? lowBlockId[val] : highBlockId[n / val]);
    }
    int calcPrefix(int x) // 获得所有位置的前缀和
    {
        return x;
    }
    int calcPrimePrefix(int x) // x表示是第几个质数
    {
        return primePrefix[x];
    }
    int calcF(int x) // 对应的函数F(x)
    {
        return 1;
    }

    // 构造函数，初始化Min25筛
    Min25(int n) : n(n),
                   block(sqrt(n)),
                   w(2 * block + 1), // 分配2*sqrt(n)的空间
                   g(2 * block + 1),
                   prime(block + 1),
                   vis(block + 1, 0),
                   lowBlockId(block + 1),
                   highBlockId(block + 1),
                   primePrefix(block + 1, 0)
    {
        // 欧拉筛预处理小素数
        vis[0] = vis[1] = true; // 0和1不是素数
        for (int i = 2; i <= block; ++i)
        {
            if (!vis[i])
            {
                prime[++primeCnt] = i; // 记录素数
                primePrefix[primeCnt] = primePrefix[primeCnt - 1] + calcF(i);
            }
            // 筛去i的倍数
            for (int j = 1; j <= primeCnt and i * prime[j] <= block; ++j)
            {
                vis[i * prime[j]] = true; // 标记为合数
                if (i % prime[j] == 0)
                { // 保证每个数只被最小素因子筛去
                    break;
                }
            }
        }

        // 整除分块预处理
        int tot = 0; // 分块计数器
        for (int l = 1, r; l <= n; l = r + 1)
        {
            r = n / (n / l); // 计算当前块的右边界
            int val = n / l; // 当前块的代表值

            w[++tot] = val; // 存储分块值

            // 根据值大小选择不同的存储位置
            if (val <= block)
            {
                lowBlockId[val] = tot;
            }
            else
            {
                highBlockId[n / val] = tot;
            }

            // 初始化g(0,m)
            g[tot] = calcPrefix(val) - calcPrefix(1);
        }

        // DP计算g函数
        for (int j = 1; j <= primeCnt; ++j)
        { // 遍历所有小素数
            for (int i = 1; i <= tot and prime[j] * prime[j] <= w[i]; ++i)
            {
                int k = getId(w[i] / prime[j]); // 获取转移位置

                g[i] -= calcF(prime[j]) * (g[k] - calcPrimePrefix(j - 1));
            }
        }
    }

    // 获取质数处函数值的前缀和
    int getPrimePrefix(int n)
    {
        int k = getId(n); // 获取n对应的索引
        return g[k];      // 返回预处理好的前缀和
    }
};

```

### 常见的积性函数
![image](https://cdn.nlark.com/yuque/__latex/eb9ca69c0e8e44d6877fe727f9b097e9.svg)

![image](https://cdn.nlark.com/yuque/__latex/7dbcce07641330c188794a54fa7131e5.svg)

![image](https://cdn.nlark.com/yuque/__latex/a8e7d71308b108bbfa0f1832d8e9d1bd.svg)

![image](https://cdn.nlark.com/yuque/__latex/7aa243febac026afe44bab10123cbc31.svg)



![image](https://cdn.nlark.com/yuque/__latex/e35acc3e1ba46378fbea0fe211062aeb.svg)



![image](https://cdn.nlark.com/yuque/__latex/2f68e507425f2db2c1ebbf0d27205bdb.svg)



![image](https://cdn.nlark.com/yuque/__latex/76298428afcc4e599b3ed1bcfd3c0e8c.svg)

## 数论恒等式/推式子/结论
![image](https://cdn.nlark.com/yuque/__latex/8823d9f7c2b729300d073d2fd827fce6.svg)

![image](https://cdn.nlark.com/yuque/__latex/0cf9fd40cb04a7046742949841e81e8b.svg)

![image](https://cdn.nlark.com/yuque/__latex/b76b4a977f747c03e9988badc31ab04e.svg)

![image](https://cdn.nlark.com/yuque/__latex/1a0cc420573be72e02abf232ec16d58a.svg)

![image](https://cdn.nlark.com/yuque/__latex/64fd1bbfca0eef9e4f104c13c2833f6d.svg)

![image](https://cdn.nlark.com/yuque/__latex/8411b1dc05db16f127c69ec642be4910.svg)(这里n是系数)

![image](https://cdn.nlark.com/yuque/__latex/c76b3d53d943d12f8b79344b1b0481bf.svg)

![image](https://cdn.nlark.com/yuque/__latex/947adebe27fa1db18a090eb7bde5238d.svg)

![image](https://cdn.nlark.com/yuque/__latex/58850a984a4894c1d0f39af269cdef19.svg)

![image](https://cdn.nlark.com/yuque/__latex/772df1acf3f30f2db95a8f8e74271c9e.svg)

![image](https://cdn.nlark.com/yuque/__latex/410971e95400802415c75ea676c41f53.svg)

![image](https://cdn.nlark.com/yuque/__latex/d8cd9c52c08edca5d891739e615a5728.svg)

![image](https://cdn.nlark.com/yuque/__latex/e3de01893d209cd3b9fb5de4db3807ac.svg)

![image](https://cdn.nlark.com/yuque/__latex/a1d5fa60b9640bb7d90bc7751db13e39.svg)

![image](https://cdn.nlark.com/yuque/__latex/dc936a9cea43e4f049d345e4d5a504c8.svg)

![image](https://cdn.nlark.com/yuque/__latex/4d005c528c12ef56b61972498c35a5b9.svg)

![image](https://cdn.nlark.com/yuque/__latex/107e0ed3ddaac6d46339bd22dc94143c.svg),![image](https://cdn.nlark.com/yuque/__latex/2a65a54a7058e7360ab82fdf3c9da077.svg)

![image](https://cdn.nlark.com/yuque/__latex/0e926d50fec25912a811b0fc0853040f.svg)

![image](https://cdn.nlark.com/yuque/__latex/aff251b0f08a568f7a0a23cd6762248d.svg)

![image](https://cdn.nlark.com/yuque/__latex/073c672f1d36f636d1a6a7d4e0774ab2.svg)(选择![image](https://cdn.nlark.com/yuque/__latex/df976ff7fcf17d60490267d18a1e3996.svg)个小于等于![image](https://cdn.nlark.com/yuque/__latex/df378375e7693bdcf9535661c023c02e.svg)的正整数取![image](https://cdn.nlark.com/yuque/__latex/62e1b8edc71b5f118c806bac439d870e.svg)再和![image](https://cdn.nlark.com/yuque/__latex/df378375e7693bdcf9535661c023c02e.svg)取![image](https://cdn.nlark.com/yuque/__latex/62e1b8edc71b5f118c806bac439d870e.svg)后为![image](https://cdn.nlark.com/yuque/__latex/53072c2388d69edc65c2377681e4e87c.svg)的方案数)

![image](https://cdn.nlark.com/yuque/__latex/5dfa1ae866a1b6e921e85b564dc658de.svg)

![image](https://cdn.nlark.com/yuque/__latex/b60bfb8daafbfb114d6e25b5eca225b0.svg)

![image](https://cdn.nlark.com/yuque/__latex/cc4271be3961dce4b81e53f678e51b70.svg)

![image](https://cdn.nlark.com/yuque/__latex/32904d981b4071b71350cae1405a9bdd.svg)

![image](https://cdn.nlark.com/yuque/__latex/03326904197693ca318e2244263f0b7e.svg)

![image](https://cdn.nlark.com/yuque/__latex/f6b95a5f253ec39acf951bd59d720683.svg)

![image](https://cdn.nlark.com/yuque/__latex/cd1f24fd6491337d06a4b08a13ac9d4f.svg)

![image](https://cdn.nlark.com/yuque/__latex/e8900470c06d4d3b2723cd1f4cb4ccaf.svg)

![image](https://cdn.nlark.com/yuque/__latex/11c965a93ac8022028ea79480ab07657.svg)

![image](https://cdn.nlark.com/yuque/__latex/4cea1eadcf6044aa1c3c6449f0468782.svg)

![image](https://cdn.nlark.com/yuque/__latex/ee8758ce1267f38861a875340234a269.svg)

![image](https://cdn.nlark.com/yuque/__latex/84bb038f67d4d9e2bfbf221794a74c65.svg)![image](https://cdn.nlark.com/yuque/__latex/cf06859c3d26c82b137950bb723d6dd7.svg)

![image](https://cdn.nlark.com/yuque/__latex/d5bac6d7b1a1ff44621cfa4b7846feda.svg)

## 技巧/Trick
![image](https://cdn.nlark.com/yuque/__latex/53072c2388d69edc65c2377681e4e87c.svg)，我们在一个空数组中不断加入新的数字，那么该数组的![image](https://cdn.nlark.com/yuque/__latex/62e1b8edc71b5f118c806bac439d870e.svg)单调不升，且最多会出现![image](https://cdn.nlark.com/yuque/__latex/efebabab3622c6221ab8d5cef54f384c.svg)种数字，因为每次![image](https://cdn.nlark.com/yuque/__latex/62e1b8edc71b5f118c806bac439d870e.svg)下降至少除以![image](https://cdn.nlark.com/yuque/__latex/2b89979f54ec02a7bf87aa0c1ea58ff9.svg)



![image](https://cdn.nlark.com/yuque/__latex/2b89979f54ec02a7bf87aa0c1ea58ff9.svg)，我们考虑如何维护区间![image](https://cdn.nlark.com/yuque/__latex/994ff73472bbb2f119d3e4ff653e87e8.svg)，首先直接暴力一直取![image](https://cdn.nlark.com/yuque/__latex/994ff73472bbb2f119d3e4ff653e87e8.svg)会变得很大，取模会使答案错误，因此必须从质因子上着手。

我们考虑怎么修正贡献，我们不妨开一个大小为![image](https://cdn.nlark.com/yuque/__latex/9f493997c33913987175caf4a4849955.svg)的桶，其中![image](https://cdn.nlark.com/yuque/__latex/67ccf3d24c082c818188b0cb4e8ce87d.svg)的位置有效，且权值为![image](https://cdn.nlark.com/yuque/__latex/d4cd21d60552e207f237e82def9029b6.svg),答案乘以该权值![image](https://cdn.nlark.com/yuque/__latex/3bb10f1d5025cd88d0887f887470953a.svg)当且仅当询问区间内![image](https://cdn.nlark.com/yuque/__latex/67ccf3d24c082c818188b0cb4e8ce87d.svg)被覆盖至少一次。

那我们不妨考虑离线询问用莫队来做，这样加减一个数字是做![image](https://cdn.nlark.com/yuque/__latex/efebabab3622c6221ab8d5cef54f384c.svg)次桶修改，过程中即可维护答案，复杂度![image](https://cdn.nlark.com/yuque/__latex/746921736ecff6a5a244982cd18a4a88.svg)

如果![image](https://cdn.nlark.com/yuque/__latex/9f493997c33913987175caf4a4849955.svg)很大我们不妨只考虑有效位置，用哈希的办法映射。



![image](https://cdn.nlark.com/yuque/__latex/a7720a85557fdd660de5e2da1dfa7c07.svg)如何求连续自然数的异或和？我们不妨转化为两个从![image](https://cdn.nlark.com/yuque/__latex/53072c2388d69edc65c2377681e4e87c.svg)开始的前缀异或和

那么前缀异或和有结论

```cpp
int calc(int n) {
    if (n % 4 == 0) {
        return n;
    } else if (n % 4 == 1) {
        return 1;
    } else if (n % 4 == 2) {
        return n + 1;
    } else {
        return 0;
    }
}
```



![image](https://cdn.nlark.com/yuque/__latex/afb0613a26341d701b3967ba170aa30c.svg)一段连续的自然数同时异或一个相同的数，会得到![image](https://cdn.nlark.com/yuque/__latex/7604614fddf2d8179cfb467a051ec459.svg)段连续的自然数



![image](https://cdn.nlark.com/yuque/__latex/b15983bcda2a67366d095cfeb326717a.svg)<font style="color:rgb(33, 37, 41);">满足</font>![image](https://cdn.nlark.com/yuque/__latex/aff172e49e22d3b84ea1e41b54462b74.svg)<font style="color:rgb(33, 37, 41);">的组合数</font>![image](https://cdn.nlark.com/yuque/__latex/07c6b623165085bbeb7d563261ee7163.svg)<font style="color:rgb(33, 37, 41);">为奇数，否则为偶数</font>

证明我们考虑![image](https://cdn.nlark.com/yuque/__latex/9399b3296c58c6a7b0e4b278b98ac4c1.svg)定理在![image](https://cdn.nlark.com/yuque/__latex/cb6a001c04f839d69e0fd885fec6f7b6.svg)意义下即可

# 随机数
### Miller Rabin
```cpp
/*
维基百科 :
n < 4e9, Prime = [2, 7, 61]
n < 3e14, Prime = [2, 3, 5, 7, 11, 13, 17]
n < 3e18, Prime = [2, 3, 5, 7, 11, 13, 17, 19, 23]
n < 3e23, Prime = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]
*/
template <class T>
struct MillerRabin
{
    const std::vector<int> Prime;
    MillerRabin() : Prime({2, 3, 5, 7, 11, 13, 17, 19, 23}) {}

    static constexpr int mulp(const int &a, const int &b, const int &P)
    {
        return 1ll * a * b % P;
    }
    static constexpr i64 mulp(const i64 &a, const i64 &b, const i64 &P)
    {
        i64 res = a * b - i64(1.L * a * b / P) * P;
        res %= P;
        res += (res < 0 ? P : 0);
        return res;
    }

    static constexpr T powp(T a, T mi, const T &mod)
    {
        T ans = 1;
        for (; mi; mi >>= 1)
        {
            if (mi & 1)
            {
                ans = mulp(ans, a, mod);
            }
            a = mulp(a, a, mod);
        }
        return ans;
    }

    constexpr bool operator()(const T &v)
    { // 判断v是不是质数
        if (v < 2 or v != 2 and v % 2 == 0)
        {
            return false;
        }
        T s = v - 1;
        while (!(s & 1))
        {
            s >>= 1;
        }
        for (int x : Prime)
        {
            if (v == x)
            {
                return true;
            }
            T t = s, m = powp(x, s, v);
            while (t != v - 1 and m != 1 and m != v - 1)
            {
                m = mulp(m, m, v), t <<= 1;
            }
            if (m != v - 1 and !(t & 1))
            {
                return false;
            }
        }
        return true;
    }
};
MillerRabin<i64> isp;
```

### **<font style="color:rgb(38, 38, 38);">PollardRho</font>**
<font style="color:rgb(38, 38, 38);">如果 </font>![image](https://cdn.nlark.com/yuque/__latex/df378375e7693bdcf9535661c023c02e.svg)<font style="color:rgb(38, 38, 38);"> 是质数 (</font>_<font style="color:rgb(38, 38, 38);">MillerRabbin</font>_<font style="color:rgb(38, 38, 38);">判) 返回 </font>![image](https://cdn.nlark.com/yuque/__latex/df378375e7693bdcf9535661c023c02e.svg)_<font style="color:rgb(38, 38, 38);">     </font>_<font style="color:rgb(38, 38, 38);">否则返回 </font>![image](https://cdn.nlark.com/yuque/__latex/df378375e7693bdcf9535661c023c02e.svg)_<font style="color:rgb(38, 38, 38);"> </font>_<font style="color:rgb(38, 38, 38);">的随机一个</font>![image](https://cdn.nlark.com/yuque/__latex/ff9cb3f3599c3051cc11c3a3684cc807.svg)<font style="color:rgb(38, 38, 38);">的因子</font>

<font style="color:rgb(38, 38, 38);">复杂度 </font>![image](https://cdn.nlark.com/yuque/__latex/8bd2391fb9e9eab9ca048cdbdf2614f9.svg)

```cpp
template <class T>
struct PollardRho : public MillerRabin<T>
{
    std::mt19937 myrand;
    PollardRho(const i64 seed = time(0)) : myrand(seed) {}

    constexpr T rd(T l, T r)
    {
        return std::uniform_int_distribution<T>(l, r)(myrand);
    }
    constexpr T operator()(T n)
    { // 返回 n 的随机一个[2, n-1]内的因子, 或者判定是质数
        if (n == 4)
        {
            return 2;
        }
        MillerRabin<T> &super = *this;
        if (super(n))
        {
            return n; // 如果 n 是质数直接返回 n
        } // Miller-Rabbin 判质数
        while (true)
        {
            T c = rd(1, n - 1);
            auto f = [&](T x)
            { return (super.mulp(x, x, n) + c) % n; };
            T t = 0, r = 0, p = 1, q;
            do
            {
                for (int i = 0; i < 128; i++)
                {
                    t = f(t), r = f(f(r));
                    if (t == r || (q = super.mulp(p, std::abs(t - r), n)) == 0)
                    {
                        break;
                    }
                    p = q;
                }
                T d = std::gcd<T>(p, n);
                if (d > 1)
                {
                    return d;
                }
            } while (t != r);
        }
    }
};
PollardRho<i64> findDiv;
```

### 随机数生成
```cpp
template <class T>
struct Rand {
    std::mt19937 myrand;
    Rand(const i64 seed = time(0)) : myrand(seed) {}
    T operator()(T l, T r) {
        return std::uniform_int_distribution<T>(l, r)(myrand);
    }
};
Rand<int> rd;

std::mt19937 rnd((u64)new char))
std::shuffle(begin(a),end(a),rnd)
```

## 随机化算法
#### KP算法
该算法是一个能求出高度近似解的贪心算法，能解决的问题是，把一个序列分成两个序列，满足它们和的差值尽量小。

执行流程：不断取出序列中的最大值和次大值，并把他们的差值重新插入序列中。重复该操作直至序列只剩一个元素。那么该元素即为近似解。

如果我们时间允许执行多次，我们不妨每次随机取出一个数字后做该过程，再把取出的数字加进去，这样有概率能随机到最优解。

#### MinHash
用于比较两个集合的相似度，我们定义两个集合的![image](https://cdn.nlark.com/yuque/__latex/de951302f41d4707b9d80ca1af34dd0f.svg)和![image](https://cdn.nlark.com/yuque/__latex/54f5fb1b07a88521e7b036e3bc7a5e33.svg)的<font style="color:rgba(0, 0, 0, 0.95) !important;"> Jaccard 相似度</font>记为![image](https://cdn.nlark.com/yuque/__latex/6a89047927a7e60ed7fb20f84b712c8c.svg),即交集大小除以并集大小，但这样比较的效率很低，我们引入![image](https://cdn.nlark.com/yuque/__latex/c828b0a17202103e76db7f102fc64ac9.svg)技术，我们不妨定义![image](https://cdn.nlark.com/yuque/__latex/df976ff7fcf17d60490267d18a1e3996.svg)个不同的哈希函数，对于每个哈希函数，我们对集合![image](https://cdn.nlark.com/yuque/__latex/de951302f41d4707b9d80ca1af34dd0f.svg)中的每个数进行哈希，然后得到其中最小的数字，作为该哈希函数下![image](https://cdn.nlark.com/yuque/__latex/de951302f41d4707b9d80ca1af34dd0f.svg)集合的标准值，这样我们可以得到一个长度为![image](https://cdn.nlark.com/yuque/__latex/df976ff7fcf17d60490267d18a1e3996.svg)的向量作为新的![image](https://cdn.nlark.com/yuque/__latex/de951302f41d4707b9d80ca1af34dd0f.svg)序列。同理得到![image](https://cdn.nlark.com/yuque/__latex/54f5fb1b07a88521e7b036e3bc7a5e33.svg)的新序列。

定理：<font style="color:rgba(0, 0, 0, 0.95) !important;">两个集合的 MinHash 值相同的概率，等于它们的 Jaccard 相似度</font>

这样我们就可以通过比较长度为![image](https://cdn.nlark.com/yuque/__latex/38a3f4d664b7a723d138f9d57be0c783.svg)的序列判断两个序列的相似程度。

#### 模拟退火
即随机化找最优解的贪心方法

执行流程是在现有解的基础上进行扰动，但在劣解情况下也有概率进行转移，这样做是为了防止跳入局部最优解中。

步骤一：确定初始温度![image](https://cdn.nlark.com/yuque/__latex/5147f0dad3345052c03981dae0a7ad6c.svg)和降温系数![image](https://cdn.nlark.com/yuque/__latex/df976ff7fcf17d60490267d18a1e3996.svg)以及最低温![image](https://cdn.nlark.com/yuque/__latex/03b60939d383cc6cbc11b7f36e7002cd.svg)，当温度![image](https://cdn.nlark.com/yuque/__latex/9fdacc73763948bc3be9e73bc1a8cea6.svg)时结束算法，并且每一轮过程都让当前温度![image](https://cdn.nlark.com/yuque/__latex/1553dae3cc5c15cddb4f5b5a367b0aba.svg)变成![image](https://cdn.nlark.com/yuque/__latex/56945d1c188acef551047c50dfbe15c2.svg),我们一般取![image](https://cdn.nlark.com/yuque/__latex/df976ff7fcf17d60490267d18a1e3996.svg)为![image](https://cdn.nlark.com/yuque/__latex/7b2c57912945211caa7fedefbb63a2e5.svg)。

步骤二：选择一个新解并决定是否接受新解，若答案更优直接接受，或者当一个随机数![image](https://cdn.nlark.com/yuque/__latex/f3b2e8981a78f1c5f5124ca8b9e6f194.svg),其中![image](https://cdn.nlark.com/yuque/__latex/b366096db7f8095739886cce8854eaec.svg)为两个解的差值

步骤三：选择一个初始点开始执行模拟退火算法即可。



不难发现当![image](https://cdn.nlark.com/yuque/__latex/1553dae3cc5c15cddb4f5b5a367b0aba.svg)不断趋近于![image](https://cdn.nlark.com/yuque/__latex/22d0feea96d3bb2fc273f7598ce748c1.svg)时，如果新的解不够优秀，接受新解第二个条件变的不可接受，此时会稳定寻找周围的最优解。



初始点的选择：我们尽可能贪心选择一个接近答案位置的解即可。



新解的选择：

我们分不同问题考虑

计算几何连续空间最优化问题：

我们考虑把坐标偏移量和温度挂钩，即使用温度*随机数的方式来选择，这样可以保证在算法初期有足够的探索性，后期又有足够的找精细最优解的能力。

最优顺序/最优选择/最优分组：

方法有很多种，可以随机交换两个位置，也可以翻转某一段区间等等，或者改变某个未知的状态等等。

# 多项式
### 拉格朗日插值
根据拉格朗日定理，我们知道,![image](https://cdn.nlark.com/yuque/__latex/53bd15bd9229cd48a311be75b1a51db2.svg)对点值![image](https://cdn.nlark.com/yuque/__latex/a969cab25db24b7b40ddd3064d3ab658.svg)可以唯一确定一个![image](https://cdn.nlark.com/yuque/__latex/f29219be34b160369c88fab81ea65712.svg)次的多项式，拉格朗日插值即是求解该多项式的过程

用多项式来讲，就是把点值表示法转为系数表示法



其核心思想是考虑点值的独立性然后挨个合并，和![image](https://cdn.nlark.com/yuque/__latex/95d94d5e2b28c78caac7ebf09b8b7ce0.svg)的思想类似，因此我们想到构造![image](https://cdn.nlark.com/yuque/__latex/df378375e7693bdcf9535661c023c02e.svg)个多项式![image](https://cdn.nlark.com/yuque/__latex/75ffc1b4eee586d66a1e07d0023d56a9.svg),满足![image](https://cdn.nlark.com/yuque/__latex/7b373cc967485fd0b8e3c7b5663a2b95.svg),之后最终答案多项式![image](https://cdn.nlark.com/yuque/__latex/77bd20203670a730f7073d131b644794.svg)

我们有一种显然的构造方法![image](https://cdn.nlark.com/yuque/__latex/d491358c1da2d39c2e6c78313eb2728b.svg)然后我们得到了最终的![image](https://cdn.nlark.com/yuque/__latex/3818937ac554603003e6727783932e9f.svg) 



我们发现如果点值是离散数点的话，我们的复杂度将是![image](https://cdn.nlark.com/yuque/__latex/2a1f5db7ab84c7a1ad631960ee8647e9.svg)的



但是如果给定点值的横坐标是连续数点的话，我们有单点快速插值的办法



对于分子，我们可以预处理前缀后缀积快速计算，对于分母，我们发现是一个阶乘形式，预处理即可,下面是单点快速插值代码

```cpp
// 拉格朗日插值函数：通过已知的k个点值，计算多项式在n处的值
// 参数：
//   f: 向量，存储多项式在x=1,2,...,k处的函数值（f[1]到f[k]）
//   k: 已知点的数量（多项式次数m = k-1）
//   n: 要求解的x值
// 返回值：多项式在x=n处的值f(n)
int lagrange(std::vector<int> f, int k, int n)
{
    int res = 0; // 存储最终结果

    // 预处理前缀积和后缀积
    int pre[k + 2], suf[k + 2]; // pre[i] = (n-1)(n-2)...(n-i), suf[i] = (n-i)(n-(i+1))...(n-k)
    pre[0] = 1;                 // 前缀积初始化
    suf[k + 1] = 1;             // 后缀积初始化

    // 计算前缀积：pre[i] = Π_{j=1}^i (n-j)
    for (int i = 1; i <= k; ++i)
    {
        pre[i] = 1ll * pre[i - 1] * (n - i) % p; // 递推计算前缀积
    }

    // 计算后缀积：suf[i] = Π_{j=i}^k (n-j)
    for (int i = k; i >= 1; --i)
    {
        suf[i] = 1ll * suf[i + 1] * (n - i) % p; // 递推计算后缀积
    }

    // 组合所有部分计算拉格朗日插值结果
    for (int i = 1; i <= k; ++i)
    {
        // 计算拉格朗日基函数L_i(n)的分子部分：pre[i-1] * suf[i+1]
        // 即 Π_{j≠i} (n-j) = (n-1)(n-2)...(n-(i-1)) * (n-(i+1))...(n-k)
        int numerator = 1ll * pre[i - 1] * suf[i + 1] % p;

        // 计算拉格朗日基函数的分母部分：fac[i-1] * fac[k-i] * (-1)^{k-i}
        // 其中fac[i]是i的阶乘，inv()是模逆元函数
        int denominator = 1ll * inv(fac[i - 1]) * inv(fac[k - i]) % p;

        // 根据(k-i)的奇偶性决定符号
        if ((k - i) & 1)
        {
            // 当(k-i)为奇数时，符号为负
            res = (res - 1ll * f[i] * numerator % p * denominator % p + p) % p;
        }
        else
        {
            // 当(k-i)为偶数时，符号为正
            res = (res + 1ll * f[i] * numerator % p * denominator % p + p) % p;
        }
    }

    return res; // 返回插值结果f(n)
}
```

### 原根表
```cpp
p=r×2^k+1
prime               r   k   g   
3                   1   1   2
5                   1   2   2
17                  1   4   3
97                  3   5   5
193                 3   6   5
257                 1   8   3
7681                15  9   17
12289               3   12  11
40961               5   13  3
65537               1   16  3
786433              3   18  10
5767169             11  19  3
7340033             7   20  3
23068673            11  21  3
104857601           25  22  3
167772161           5   25  3
469762049           7   26  3
1004535809          479 21  3
2013265921          15  27  31
2281701377          17  27  3
3221225473          3   30  5
75161927681         35  31  3
77309411329         9   33  7
206158430209        3   36  22
2061584302081       15  37  7
2748779069441       5   39  3
6597069766657       3   41  5
39582418599937      9   42  5
79164837199873      9   43  5
263882790666241     15  44  7
1231453023109121    35  45  3
1337006139375617    19  46  3
3799912185593857    27  47  5
4222124650659841    15  48  19
7881299347898369    7   50  6
31525197391593473   7   52  3
180143985094819841  5   55  6
1945555039024054273 27  56  5
4179340454199820289 29  57  3

```

### 多项式全家桶
```cpp
using ll = long long;

template <class T, T P>
class Polynomial : public std::vector<T>
{
    static constexpr int mul(const int &a, const int &b)
    {
        int res = 1ll * a * b % P;
        if (res < 0)
            res += P;
        return res;
    }
    static constexpr ll mul(const ll &a, const ll &b)
    {
        ll res = a * b - (ll)(1.L * a * b / P) * P;
        res %= P;
        if (res < 0)
        {
            res += P;
        }
        return res;
    }
    static constexpr T add(T a, const T &b)
    {
        a += b;
        a -= (a >= P ? P : 0);
        return a;
    }
    static constexpr T sub(T a, const T &b)
    {
        a -= b;
        a += (a < 0 ? P : 0);
        return a;
    }
    static constexpr T power(T a, ll b)
    {
        T res = 1;
        while (b)
        {
            if (b & 1)
                res = mul(res, a);
            a = mul(a, a);
            b >>= 1;
        }
        return res;
    }
    static std::vector<T> w;
    static void initW(int _log)
    {
        const int r = 1 << _log;
        if (w.size() >= r)
        {
            return;
        }
        w.assign(r, 0);
        w[r >> 1] = 1;
        T s = power(3, (P - 1) >> _log); // 3是原根

        for (int i = r / 2 + 1; i < r; i++)
        {
            w[i] = mul(w[i - 1], s);
        }

        for (int i = r / 2 - 1; i > 0; i--)
        {
            w[i] = w[i * 2];
        }
    }

public:
    using std::vector<T>::vector;

    friend void dft(Polynomial &a)
    {
        const int n = a.size();
        for (int k = n >> 1; k; k >>= 1)
        {
            for (int i = 0; i < n; i += k << 1)
            {
                for (int j = 0; j < k; j++)
                {
                    T v = a[i + j + k];
                    a[i + j + k] = mul(sub(a[i + j], v), w[k + j]);
                    a[i + j] = add(a[i + j], v);
                }
            }
        }
    }
    friend void idft(Polynomial &a)
    {
        const int n = a.size();
        for (int k = 1; k < n; k <<= 1)
        {
            for (int i = 0; i < n; i += k << 1)
            {
                for (int j = 0; j < k; j++)
                {
                    T u = a[i + j];
                    T v = mul(a[i + j + k], w[j + k]);
                    a[i + j + k] = sub(u, v);
                    a[i + j] = add(u, v);
                }
            }
        }
        T val = P - (P - 1) / n;
        for (int i = 0; i < n; i++)
        {
            a[i] = mul(a[i], val);
        }
        std::reverse(a.begin() + 1, a.end());
    }

    friend Polynomial operator*(Polynomial a, Polynomial b)
    {
        if (a.size() == 0 or b.size() == 0)
        {
            return Polynomial();
        }
        int n = a.size() + b.size() - 1;
        int _log = std::__lg(2 * n - 1);
        int s = 1 << _log;
        if (((P - 1) & (s - 1)) != 0 or std::min(a.size(), b.size()) < 128)
        {
            Polynomial res(n);
            for (int i = 0; i < a.size(); i++)
            {
                for (int j = 0; j < b.size(); j++)
                {
                    res[i + j] = add(res[i + j], mul(a[i], b[j]));
                }
            }
            return res;
        }

        initW(_log);
        a.resize(s), b.resize(s);
        dft(a), dft(b);
        for (int i = 0; i < s; i++)
        {
            a[i] = mul(a[i], b[i]);
        }
        idft(a);
        return a.resize(n), a;
    }
    friend Polynomial deriv(const Polynomial &a) // 求导
    {
        int n = a.size();
        if (n <= 1)
        {
            return Polynomial();
        }
        Polynomial p(n - 1);
        for (int i = 1; i < n; i++)
        {
            p[i - 1] = mul(i, a[i]);
        }
        return p;
    }
    friend Polynomial integr(const Polynomial &a)
    {
        int n = a.size();
        Polynomial p(n + 1);

        std::vector<int> _inv(n + 1);
        _inv[1] = 1;
        for (int i = 2; i <= n; i++)
        {
            _inv[i] = mul(_inv[P % i], (P - P / i));
        }
        for (int i = 0; i < n; ++i)
        {
            p[i + 1] = mul(a[i], _inv[i + 1]);
        }
        return p;
    }
    friend Polynomial inv(const Polynomial &a)
    {
        int n = a.size();
        if (n == 1)
        {
            return {power(a[0], P - 2)};
        }
        Polynomial half(a.begin(), a.begin() + (n + 1) / 2);
        Polynomial b = inv(half), c = a * b;
        for (auto &x : c)
        {
            x = (x == 0 ? 0 : P - x); // ?
        }
        c[0] = add(c[0], 2);
        c = c * b;
        c.resize(n);
        return c;
    }

    friend Polynomial ln(const Polynomial &a)
    {
        int n = a.size();

        Polynomial b(n, 0);
        for (int i = 1; i < n; i++)
        {
            b[i - 1] = mul(i, a[i]);
        }
        b = b * inv(a);
        b.resize(n);

        std::vector<T> _inv(n);
        _inv[1] = 1;
        for (int i = 2; i < n; i++)
        {
            _inv[i] = mul(P - P / i, _inv[P % i]);
        }
        for (int i = n - 1; i; i--)
        {
            b[i] = mul(b[i - 1], _inv[i]);
        }
        b[0] = 0;
        return b;
    }

    friend Polynomial exp(const Polynomial &a)
    {
        int n = a.size();
        if (n == 1)
        {
            return {1};
        }
        Polynomial half(a.begin(), a.begin() + (n + 1) / 2);
        Polynomial b = exp(half);
        b.resize(n);
        Polynomial c = ln(b);
        for (int i = 0; i < n; i++)
        {
            c[i] = sub(a[i], c[i]);
        }
        c[0] = add(c[0], 1);
        c = c * b;
        c.resize(n);
        return c;
    }

    friend Polynomial power(Polynomial &F, std::string s)
    {
        T k1 = 0;
        T k2 = 0;
        T k3 = 0;
        for (int i = 0; i < s.length(); ++i)
        {
            k1 = add(mul(k1, 10), s[i] - '0');
            k2 = (1ll * k2 * 10 + s[i] - '0') % (P - 1);
            if (i < 7)
            {
                k3 = k3 * 10 + s[i] - '0';
            }
        }
        int n = F.size();
        if (!F[0] and k3 >= F.size())
        {
            F.assign(n, 0);
            return F;
        }
        T pos = 0; // 处理移位
        for (int i = 0; i < n; ++i)
        {
            if (F[i])
            {
                pos = i;
                break;
            }
        }
        if (pos)
        {
            for (int i = pos; i < n; ++i)
            {
                F[i - pos] = F[i];
                F[i] = 0;
            }
        }
        T val = F[0];
        T cur = power(val, P - 2);
        for (int i = 0; i < F.size(); ++i)
        {
            F[i] = mul(F[i], cur);
        }
        F = ln(F);
        for (int i = 0; i < F.size(); ++i)
        {
            F[i] = mul(F[i], k1);
        }
        F = exp(F);
        cur = power(val, k2);
        for (int i = 0; i < F.size(); ++i)
        {
            F[i] = mul(F[i], cur);
        }
        if (pos)
        {
            pos = (1ll * pos * k1 < n ? pos * k1 : n);
            for (int i = n - 1; i >= 0; --i)
            {
                if (i + pos < n)
                {
                    F[i + pos] = F[i];
                }
                F[i] = 0;
            }
        }
        return F;
    }

    friend Polynomial power(const Polynomial &F, int b, int m) // m是目标的区间长度
    {
        Polynomial res = {1};
        Polynomial G = F;
        while (b)
        {
            if (b & 1)
            {
                res = res * G;
                if (res.size() > m)
                {
                    res.resize(m);
                }
            }
            G = G * G;
            if (G.size() > m)
            {
                G.resize(m);
            }
            b >>= 1;
        }
        return res;
    }
};
template <class T, T P>
std::vector<T> Polynomial<T, P>::w;
using Poly = Polynomial<int, 998244353>;
```

### 集合幂级数全家桶
```cpp
using ll = long long;

template <class T, T P>
class Polynomial : public std::vector<T>
{
    static constexpr int mul(const int &a, const int &b)
    {
        int res = 1ll * a * b % P;
        if (res < 0)
            res += P;
        return res;
    }
    static constexpr ll mul(const ll &a, const ll &b)
    {
        ll res = a * b - (ll)(1.L * a * b / P) * P;
        res %= P;
        if (res < 0)
        {
            res += P;
        }
        return res;
    }
    static constexpr T add(T a, const T &b)
    {
        a += b;
        a -= (a >= P ? P : 0);
        return a;
    }
    static constexpr T sub(T a, const T &b)
    {
        a -= b;
        a += (a < 0 ? P : 0);
        return a;
    }
    static constexpr T power(T a, ll b)
    {
        T res = 1;
        while (b)
        {
            if (b & 1)
                res = mul(res, a);
            a = mul(a, a);
            b >>= 1;
        }
        return res;
    }
    static std::vector<T> w;

public:
    using std::vector<T>::vector;
    friend void FWT_or(Polynomial &f, int op)
    {
        int n = std::__lg(f.size());
        for (int k = 0; k < n; ++k)
        {
            for (int i = 0; i < (1 << n); ++i)
            {
                if (i & (1 << k))
                {
                    f[i] = add(f[i], mul(op, f[i ^ (1 << k)]));
                }
            }
        }
    }

    friend Polynomial fwtOr(Polynomial &F, Polynomial &G) // H[i]=F[j]*G[k] if(j or k==i)
    {
        int n = std::max(F.size(), G.size());
        int s = std::__lg(n - 1);
        n = (1 << (s + 1));
        Polynomial H(n);
        F.resize(n), G.resize(n);
        FWT_or(F, 1);
        FWT_or(G, 1);
        for (int i = 0; i < n; ++i)
        {
            H[i] = mul(F[i], G[i]);
        }
        FWT_or(H, -1);
        FWT_or(F, -1);
        FWT_or(G, -1);
        return H;
    }

    friend void FWT_and(Polynomial &f, int op)
    {
        int n = std::__lg(f.size());
        for (int k = 0; k < n; ++k)
        {
            for (int i = 0; i < (1 << n); ++i)
            {
                if (!(i & (1 << k)))
                {
                    f[i] = add(f[i], mul(op, f[i ^ (1 << k)]));
                }
            }
        }
    }

    friend Polynomial fwtAnd(Polynomial &F, Polynomial &G) // H[i]=F[j]*G[k] if(j and k==i)
    {
        int n = std::max(F.size(), G.size());
        int s = std::__lg(n - 1);
        n = (1 << (s + 1));
        F.resize(n), G.resize(n);
        Polynomial H(n);
        FWT_and(F, 1);
        FWT_and(G, 1);
        for (int i = 0; i < n; ++i)
        {
            H[i] = mul(F[i], G[i]);
        }
        FWT_and(H, -1);
        FWT_and(F, -1);
        FWT_and(G, -1);
        return H;
    }

    friend void FWT_xor(Polynomial &f, int op)
    {
        int n = std::__lg(f.size());
        for (int d = 1; d < (1 << n); d <<= 1)
        {
            for (int i = 0; i < (1 << n); i += (d << 1)) // 从最小的二进制位地推上去
            {
                for (int j = 0; j < d; ++j)
                {
                    T x = f[i + j], y = f[i + d + j];
                    f[i + j] = add(x, y);
                    f[i + j + d] = sub(x, y);
                }
            }
        }
        if (op == -1)
        {
            T inv_n = power(1 << n, P - 2);
            for (int i = 0; i < (1 << n); ++i)
            {
                f[i] = mul(f[i], inv_n);
            }
        }
    }
    friend Polynomial fwtXor(Polynomial &F, Polynomial &G) // H[i]=F[j]*G[k] if(j xor k==i)
    {
        int n = std::max(F.size(), G.size());
        int s = std::__lg(n - 1);
        n = (1 << (s + 1));
        F.resize(n), G.resize(n);
        Polynomial H(n);
        FWT_xor(F, 1);
        FWT_xor(G, 1);
        for (int i = 0; i < n; ++i)
        {
            H[i] = mul(F[i], G[i]);
        }
        FWT_xor(H, -1);
        FWT_xor(F, -1);
        FWT_xor(G, -1);
        return H;
    }

    friend Polynomial SubsetConvol(Polynomial &F, Polynomial &G) // 子集卷积 H[i]=F[j]*G[k] if( j|k==i and j&k==0)
    {
        int n = std::max(F.size(), G.size());
        int bit = std::__lg(n - 1) + 1;
        n = (1 << bit);
        F.resize(n), G.resize(n);
        std::vector a(bit + 1, Polynomial(n));
        std::vector b(bit + 1, Polynomial(n));
        std::vector c(bit + 1, Polynomial(n));
        for (int i = 0; i < n; ++i)
        {
            a[__builtin_popcount(i)][i] = F[i];
            b[__builtin_popcount(i)][i] = G[i];
        }
        for (int i = 0; i <= bit; ++i)
        {
            FWT_or(a[i], 1);
            FWT_or(b[i], 1);
        }
        for (int i = 0; i <= bit; ++i)
        {
            for (int j = 0; i + j <= bit; ++j)
            {
                for (int k = 0; k < (1 << bit); ++k)
                {
                    c[i + j][k] = add(c[i + j][k], mul(a[i][k], b[j][k]));
                }
            }
        }
        for (int i = 0; i <= bit; ++i)
        {
            FWT_or(c[i], -1);
        }
        Polynomial H(n);
        for (int i = 0; i < n; ++i)
        {
            H[i] = c[__builtin_popcount(i)][i];
        }
        return H;
    }
};
template <class T, T P>
std::vector<T> Polynomial<T, P>::w;
using Poly = Polynomial<int, 998244353>;
```

### 分治NTT
给定一个序列 ![image](https://cdn.nlark.com/yuque/__latex/543342f51ab805eb25eef2a40431decd.svg) 求序列![image](https://cdn.nlark.com/yuque/__latex/c157b8dca511c7aec0cf9c45cd8025d0.svg) 其中 ![image](https://cdn.nlark.com/yuque/__latex/e2fd1c773909f6a986b34a7a002b2001.svg) 我们将给定边界![image](https://cdn.nlark.com/yuque/__latex/32a2d8b94b7dc5abb0ee5a96b323e225.svg)

我们不妨设 ![image](https://cdn.nlark.com/yuque/__latex/d3adf61210218504ac0ef84f3d790676.svg) 设![image](https://cdn.nlark.com/yuque/__latex/f4923a5e0397f264809c46298db38b5b.svg)

  那么![image](https://cdn.nlark.com/yuque/__latex/05f010ae3720b3787a74a1aee2421845.svg) 

因此 ![image](https://cdn.nlark.com/yuque/__latex/3f6d3fe2bce7a8fe3296720214170f7f.svg) 需要注意的是把![image](https://cdn.nlark.com/yuque/__latex/c6cf98cbe6afdd83139fea416013eba1.svg)

### Chirp-Z-Transform
假设我们有多项式![image](https://cdn.nlark.com/yuque/__latex/3dc3d14e36c97d92103823c542d83873.svg)，我们有常数![image](https://cdn.nlark.com/yuque/__latex/b891664b42113aee13f0bac25eb998e5.svg)和![image](https://cdn.nlark.com/yuque/__latex/4760e2f007e23d820825ba241c47ce3b.svg)，我们希望求出

![image](https://cdn.nlark.com/yuque/__latex/b9a3c0176f715d56c2a4e2ffc36d493b.svg)，暴力复杂度为![image](https://cdn.nlark.com/yuque/__latex/023710761254052f2b1fdef291bd2c43.svg),我们不妨设![image](https://cdn.nlark.com/yuque/__latex/f509bc472ae3fa67f17e4f4f0184f963.svg)

代入可知![image](https://cdn.nlark.com/yuque/__latex/f35ab362f5bc94943d589eedf4669b0c.svg),我们知道![image](https://cdn.nlark.com/yuque/__latex/1c5c8e124f1ccdcbc0354fe8f6b12121.svg)

化简以后可以定义![image](https://cdn.nlark.com/yuque/__latex/15f16098b563818222951fdfd3f8a9d0.svg)，![image](https://cdn.nlark.com/yuque/__latex/a9db66eb082be6fd76f8e251c3a07cb8.svg)

注意![image](https://cdn.nlark.com/yuque/__latex/558270b7f0a90c3c286b860273d106a0.svg)数组大小为![image](https://cdn.nlark.com/yuque/__latex/e04efa7c82e19cb4e2fc5922e3a477ff.svg)

我们有![image](https://cdn.nlark.com/yuque/__latex/690694f58edf3c6973c51dd1cd6d145d.svg)

也就是![image](https://cdn.nlark.com/yuque/__latex/ac7bc9d89e7e62cb4c50e7fcd938de3e.svg)

```cpp
    ll n, c, m;
    std::cin >> n >> c >> m;
    Poly a(n);
    for (auto &x : a)
    {
        std::cin >> x;
    }
    Poly s(n), t(n + m - 1);
    auto calc = [&](ll x) -> ll
    {
        return 1ll * x * (x - 1) / 2;
    };
    for (int i = 0; i < n; ++i)
    {
        s[i] = 1ll * a[n - 1 - i] * inv(qmi(c, calc(n - i - 1))) % P;
    }
    for (int i = 0; i < n + m - 1; ++i)
    {
        t[i] = qmi(c, calc(i));
    }
    s = s * t;
    for (int i = 0; i < m; ++i)
    {
        int ans = 1ll * inv(qmi(c, calc(i))) * s[n + i - 1] % P;
        std::cout << ans << " \n"[i + 1 == m];
    }
```

### 高精度运算
实现了高精度加法，乘法和减法。

其中高精度乘法分![image](https://cdn.nlark.com/yuque/__latex/9a4b19897e03daeb7e8beeecf02e82cc.svg)的![image](https://cdn.nlark.com/yuque/__latex/c6c95fed66f48dcb509d52dc3452c2aa.svg)优化版本和![image](https://cdn.nlark.com/yuque/__latex/f2d5f588234eb61a559ff90c41511b85.svg)的暴力版本

```cpp
// 假设Poly类和相关NTT实现已经存在
/**
 * @class bigInt
 * @brief 使用NTT优化的高精度计算器，支持加、减、乘运算
 *
 * 这个类封装了基于NTT(数论变换)的高效大整数算法，
 * 可以将用字符串表示的大整数进行加、减、乘运算。
 */
class bigInt
{
public:
    bigInt() = default;
    std::string nttMul(const std::string &a, const std::string &b)
    {
        if (a.empty() || b.empty())
        {
            return "0";
        }
        bool neg = false;
        std::string n1 = a, n2 = b;
        if (a[0] == '-')
        {
            neg = !neg;
            n1 = a.substr(1);
        }
        if (b[0] == '-')
        {
            neg = !neg;
            n2 = b.substr(1);
        }

        int n = n1.size(), m = n2.size();
        Poly a(n), b(m);
        for (int i = 0; i < n; ++i)
        {
            a[i] = n1[i] - '0';
        }
        for (int i = 0; i < m; ++i)
        {
            b[i] = n2[i] - '0';
        }
        Poly c = a * b;
        for (int i = c.size() - 1; i >= 1; --i)
        {
            c[i - 1] += c[i] / 10; // 向前进位
            c[i] %= 10;            // 保留个位数
        }
        std::string res = pToS(c);
        if (neg && res != "0")
        {
            res = "-" + res;
        }

        return res;
    }
    std::string mul(const std::string &a, const std::string &b)
    {
        if (a.empty() || b.empty())
        {
            return "0";
        }
        bool neg = false;
        std::string n1 = a, n2 = b;
        if (a[0] == '-')
        {
            neg = !neg;
            n1 = a.substr(1);
        }
        if (b[0] == '-')
        {
            neg = !neg;
            n2 = b.substr(1);
        }
        if (n1 == "0" || n2 == "0")
        {
            return "0";
        }
        int len1 = n1.size();
        int len2 = n2.size();
        std::vector<int> res(len1 + len2, 0);
        for (int i = len1 - 1; i >= 0; --i)
        {
            for (int j = len2 - 1; j >= 0; --j)
            {
                int c = (n1[i] - '0') * (n2[j] - '0');
                int sum = c + res[i + j + 1];

                res[i + j + 1] = sum % 10; // 当前位
                res[i + j] += sum / 10;    // 进位
            }
        }
        std::string ans;
        for (int a : res)
        {
            if (!(ans.empty() && a == 0))
            { // 跳过前导零
                ans += std::to_string(a);
            }
        }
        // 处理全零的情况（理论上不会发生）
        if (ans.empty())
        {
            return "0";
        }
        // 处理符号
        if (neg)
        {
            ans = "-" + ans;
        }
        return ans;
    }
    std::string add(const std::string &a, const std::string &b)
    {
        if (a.empty())
            return b;
        if (b.empty())
            return a;
        // 处理两个数都是负数的情况
        if (a[0] == '-' && b[0] == '-')
        {
            return "-" + add(a.substr(1), b.substr(1));
        }
        // 处理只有一个数是负数的情况（转换为减法）
        if (a[0] == '-')
        {
            return subtract(b, a.substr(1));
        }
        if (b[0] == '-')
        {
            return subtract(a, b.substr(1));
        }
        // 确保num1是较长的数字
        if (a.length() < b.length())
        {
            return add(b, a);
        }
        std::string res;
        int carry = 0;
        int diff = a.length() - b.length();
        // 从最低位开始相加
        for (int i = a.length() - 1; i >= 0; --i)
        {
            int d1 = a[i] - '0';
            int d2 = (i >= diff) ? b[i - diff] - '0' : 0;

            int sum = d1 + d2 + carry;
            carry = sum / 10;
            res.push_back(sum % 10 + '0');
        }
        if (carry > 0)
        {
            res.push_back(carry + '0');
        }
        // 反转结果字符串
        std::reverse(res.begin(), res.end());
        // 去除前导零
        return norm(res);
    }
    std::string subtract(const std::string &a, const std::string &b)
    {
        // 检查输入是否为空
        if (b.empty())
            return a;
        if (a.empty())
            return (b[0] == '-') ? b.substr(1) : "-" + b;
        // 处理两个数都是负数的情况
        if (a[0] == '-' && b[0] == '-')
        {
            return subtract(b.substr(1), a.substr(1));
        }
        // 处理被减数是负数的情况
        if (a[0] == '-')
        {
            return "-" + add(a.substr(1), b);
        }
        // 处理减数是负数的情况
        if (b[0] == '-')
        {
            return add(a, b.substr(1));
        }
        // 比较两个数的大小
        int cmp = compare(a, b);
        if (cmp == 0)
        {
            return "0";
        }
        bool neg = (cmp < 0);
        std::string ma = neg ? b : a;
        std::string mi = neg ? a : b;

        std::string res;
        int borrow = 0;
        int diff = ma.length() - mi.length();

        // 从最低位开始相减
        for (int i = ma.length() - 1; i >= 0; --i)
        {
            int d1 = ma[i] - '0' - borrow;
            int d2 = (i >= diff) ? mi[i - diff] - '0' : 0;

            borrow = 0;

            if (d1 < d2)
            {
                d1 += 10;
                borrow = 1;
            }
            res.push_back(d1 - d2 + '0');
        }
        // 反转结果字符串
        std::reverse(res.begin(), res.end());
        // 去除前导零
        res = norm(res);
        // 添加负号（如果需要）
        if (neg)
        {
            res = "-" + res;
        }
        return res;
    }

private:
    int compare(const std::string &a, const std::string &b) const
    {
        if (a.length() != b.length())
        {
            return a.length() > b.length() ? 1 : -1;
        }
        for (size_t i = 0; i < a.length(); ++i)
        {
            if (a[i] != b[i])
            {
                return a[i] > b[i] ? 1 : -1;
            }
        }
        return 0;
    }
    /**
     * @brief 去除字符串中的前导零
     * @param a 数字字符串
     * @return 去除前导零后的字符串
     */
    std::string norm(const std::string &a) const
    {
        size_t start = 0;
        while (start < a.length() - 1 && a[start] == '0')
        {
            start++;
        }
        return a.substr(start);
    }
    /**
     * @brief 将多项式转换为字符串
     * @param p 多项式
     * @return 转换后的字符串
     */
    std::string pToS(const Poly &p) const
    {
        std::string res;
        bool leadZero = true; // 标记是否还在处理前导零

        for (auto d : p)
        {
            if (d == 0 && leadZero)
            {
                continue; // 跳过前导零
            }
            leadZero = false;
            res += std::to_string(d);
        }
        // 如果结果全为零，返回"0"
        if (res.empty())
        {
            return "0";
        }
        return res;
    }
};
bigInt calc;

```

### 乘法卷积


我们考虑把乘法转化为普通的加法 我们不难想到在指数运算中乘法可以转为加法

但是如果![image](https://cdn.nlark.com/yuque/__latex/b7602a42d007a47845de4c04898b163a.svg)，那么![image](https://cdn.nlark.com/yuque/__latex/b80505729a6bcdb65f88952f28ff9be9.svg) 那么![image](https://cdn.nlark.com/yuque/__latex/d3e1cbb6a373de81e41979285e519cd3.svg)

于是我们需要一个![image](https://cdn.nlark.com/yuque/__latex/e9424f82b33766c5afe4889cad2e222e.svg)意义下的指数和对数映射 且要求是在整数域上的一 一映射

我们不难想到原根 对于质数![image](https://cdn.nlark.com/yuque/__latex/4760e2f007e23d820825ba241c47ce3b.svg)的原根![image](https://cdn.nlark.com/yuque/__latex/0e6ffe1e0d7fb2bbd7ec1ab1d0b2d22a.svg),有![image](https://cdn.nlark.com/yuque/__latex/dccfd3ad8b0e8a0df0c974d56d46f788.svg)在![image](https://cdn.nlark.com/yuque/__latex/08da13ccd70111bf4a2fbdb708cc9902.svg)意义下两两不同  
 于是我们把原来的数转化为对数 即![image](https://cdn.nlark.com/yuque/__latex/f83ae889bd96b4d3a59e2c92b5238035.svg)我们转化为对数的加法即可 



请注意我们在执行卷积的时候要循环卷积，特别的，在本算法中对于模数为![image](https://cdn.nlark.com/yuque/__latex/4760e2f007e23d820825ba241c47ce3b.svg)应该是对![image](https://cdn.nlark.com/yuque/__latex/e695869ab86fb7206de0b9dfed58fb7b.svg)进行循环卷积，因为转化之后模![image](https://cdn.nlark.com/yuque/__latex/4760e2f007e23d820825ba241c47ce3b.svg)乘法群只有![image](https://cdn.nlark.com/yuque/__latex/e695869ab86fb7206de0b9dfed58fb7b.svg)个元素。



如果我们需要原本乘积为![image](https://cdn.nlark.com/yuque/__latex/712ecf7894348e92d8779c3ee87eeeb0.svg)的位置的值，那我们应该访问转化后的![image](https://cdn.nlark.com/yuque/__latex/442b2104255c44dd997d8bf63db10176.svg)位置，其中![image](https://cdn.nlark.com/yuque/__latex/f421c9630300dab712200995d269df5a.svg)是我们建立的映射关系。

```cpp
/**
 * @class MultiplicativeConvolution
 * @brief 利用原根和对数表实现的乘法卷积类
 *
 * 这个类通过将数字转换到原根的对数域，将乘法操作转换为加法操作，
 * 然后使用多项式乘法(卷积)来实现高效的乘法卷积计算。
 * 特别适用于需要在特定模数下进行大量乘法卷积的场景。
 */
class MultiplicativeConvolution
{
private:
    int m; // 模数
    int G; // 模数m的原根
    /**
     * @brief 初始化对数表
     */
    void initLogTable()
    {
        log.resize(m);                         // 使用m而不是m-1，以便直接使用val作为索引
        std::fill(log.begin(), log.end(), -1); // 初始化为-1表示无效值

        // 构建对数表：log[G^i mod m] = i
        for (int i = 0, cur = 1; i < m - 1; ++i)
        {
            log[cur] = i;
            cur = cur * G % m;
        }
    }

public:
    /**
     * @brief 构造函数
     * @param modulus 模数m，必须是质数且存在原根
     */
    std::vector<int> log; // 对数表，log[val] = i 表示 val = G^i mod m
    explicit MultiplicativeConvolution(int modulus) : m(modulus)
    {
        G = findMinRoot(m); // 假设GetRoot函数已实现
        initLogTable();
    }

    /**
     * @brief 执行乘法卷积运算
     * @param input 输入序列，包含需要卷积的数值
     * @return 卷积结果的多项式表示
     *
     * 注意：输入中的0会被自动忽略，因为0在乘法群中没有对数表示
     */
    Poly computeConvolution(const std::vector<int> &input)
    {
        Poly a(m - 1); // 多项式大小为m-1，因为模m乘法群有m-1个元素
        // 将输入值转换到对数域
        for (int val : input)
        {
            if (val == 0)
            {
                continue; // 忽略0，因为0不在乘法群中
            }
            val %= m; // 确保值在模m范围内
            if (val < 0)
            {
                val += m; // 处理负数
            }
            a[log[val]]++; // 在对数域对应位置计数
        }
        return a;
    }

    // 执行循环卷积（需要确保Poly乘法是循环卷积）
    // 这里假设Poly类已经正确处理了循环卷积  请注意模数为m的循环卷积应该为m-1
};
```

### 循环卷积
也就是说我们需要的值在![image](https://cdn.nlark.com/yuque/__latex/b6b46372563ac129168a9598cf34758a.svg)意义下 我们需要把 ![image](https://cdn.nlark.com/yuque/__latex/149e41331fa5b427c8f7adff48d3830e.svg)位置的值加到![image](https://cdn.nlark.com/yuque/__latex/b6b46372563ac129168a9598cf34758a.svg)的对应位置

### NTT优化字符串通配符匹配
我们先讲常规的![image](https://cdn.nlark.com/yuque/__latex/42bfc06e1d8612f5cda72663cc5c28d2.svg)怎么用![image](https://cdn.nlark.com/yuque/__latex/c6c95fed66f48dcb509d52dc3452c2aa.svg)匹配

我们设长度为![image](https://cdn.nlark.com/yuque/__latex/8377449edd44d84f3384ba3e5c0e6233.svg)的模式串![image](https://cdn.nlark.com/yuque/__latex/26fdbf8e53cb0e48da5f4ddd4aaf5a5c.svg),长度为![image](https://cdn.nlark.com/yuque/__latex/df378375e7693bdcf9535661c023c02e.svg)的文本串![image](https://cdn.nlark.com/yuque/__latex/e3b1a1ba9d491cc6835e70607ead3750.svg),定义匹配函数![image](https://cdn.nlark.com/yuque/__latex/02a50a7cd22105b7d099db4aa7b50dba.svg)

再定义完美匹配函数![image](https://cdn.nlark.com/yuque/__latex/b06451bbdf5527919e89955d9075c680.svg)，根据定义不难发现没如果某个![image](https://cdn.nlark.com/yuque/__latex/7db4cee9e74865ab082228d786b31d61.svg)满足![image](https://cdn.nlark.com/yuque/__latex/2d9a78f9e64a6b2ba01e50b6e552e154.svg)那么我们称![image](https://cdn.nlark.com/yuque/__latex/d29c2e5f4926e5b0e9a95305650f6e54.svg)串以![image](https://cdn.nlark.com/yuque/__latex/712ecf7894348e92d8779c3ee87eeeb0.svg)结尾的长度为![image](https://cdn.nlark.com/yuque/__latex/4760e2f007e23d820825ba241c47ce3b.svg)的串和![image](https://cdn.nlark.com/yuque/__latex/26fdbf8e53cb0e48da5f4ddd4aaf5a5c.svg)匹配



我们把式子展开得到![image](https://cdn.nlark.com/yuque/__latex/e14b89e15d69ef7203ced932ba5f4ee3.svg)

再把a串翻转得到

![image](https://cdn.nlark.com/yuque/__latex/137b911d8437fad317f7bdaa8aaea801.svg)

再用![image](https://cdn.nlark.com/yuque/__latex/2443fbcfeb7e85e1d62b6f5e4f27207e.svg)代替![image](https://cdn.nlark.com/yuque/__latex/53bbcf230144b8b5bec3e9ccebf6cd8a.svg)

![image](https://cdn.nlark.com/yuque/__latex/3c23f148760060b5ddc6183b7b097223.svg)

我们展开

![image](https://cdn.nlark.com/yuque/__latex/e478e1e4f259ebeea12b0fec2727d753.svg)

我们发现第一项为定值，第二项可以前缀和处理，

第三项为卷积 于是我们在![image](https://cdn.nlark.com/yuque/__latex/4fdce66a3ca18398b05c1efc03c7aa4f.svg)时间内解决了这个问题



然后我们引进通配符![image](https://cdn.nlark.com/yuque/__latex/7c5166c911848b85d45ec456bddecaa3.svg)事实上我们只需要让通配符的值为![image](https://cdn.nlark.com/yuque/__latex/22d0feea96d3bb2fc273f7598ce748c1.svg)且改变匹配函数的定义即可

![image](https://cdn.nlark.com/yuque/__latex/d18336c191f98a13bd8eabd5a0648ee6.svg)

我们再次展开

![image](https://cdn.nlark.com/yuque/__latex/1c4e0ca92abb73b2b5bdb7caa3b20fca.svg)

变成了三个卷积，但无伤大雅

```cpp
/**
 * @class WildcardStringMatcher
 * @brief 使用NTT优化的通配符字符串匹配器
 *
 * 这个类实现了基于NTT的高效字符串匹配算法，能够处理包含通配符('*')的模式串和文本串。
 * 通过多项式乘法将字符串匹配问题转化为数值计算问题，利用NTT加速计算过程。
 */
class WildcardStringMatcher
{
private:
    int P; // 模数，用于NTT计算

public:
    /**
     * @brief 构造函数
     * @param P NTT使用的质数模数
     */
    explicit WildcardStringMatcher(int P) : P(P) {}

    /**
     * @brief 执行通配符字符串匹配
     * @param pattern 模式串，可以包含通配符'*'
     * @param text 文本串，可以包含通配符'*'
     * @return 匹配位置的索引列表(1-based)
     *
     * 算法原理：
     * 1. 将字符转换为数值('a'-'z'->1-26, '*'->0)
     * 2. 反转模式串以便多项式乘法
     * 3. 通过三次多项式乘法计算匹配度
     * 4. 匹配度为0的位置即为完全匹配位置
     */
    std::vector<int> match(const std::string &pattern, const std::string &text)
    {
        int m = pattern.size();
        int n = text.size();

        // 反转模式串以便多项式乘法
        std::string reversePattern = pattern;
        std::reverse(reversePattern.begin(), reversePattern.end());

        // 将字符转换为数值('a'-'z'->1-26, '*'->0)
        Poly S(m), T(n);
        for (int i = 0; i < m; ++i)
        {
            S[i] = (reversePattern[i] != '*') ? (reversePattern[i] - 'a' + 1) : 0;
        }
        for (int i = 0; i < n; ++i)
        {
            T[i] = (text[i] != '*') ? (text[i] - 'a' + 1) : 0;
        }

        // 计算三次多项式乘法的组合，用于匹配度计算
        std::vector<int> p = computeMatchingScore(S, T, m, n);

        // 收集所有匹配度为0的位置(完全匹配)
        std::vector<int> result;
        for (int i = m - 1; i < static_cast<int>(p.size()) - m + 1; ++i)
        {
            if (p[i] == 0)
            {
                result.push_back(i - m + 2); // 转换为1-based索引
            }
        }

        return result;
    }
    /**
     * @brief 从标准输入读取数据并执行匹配
     * @return 匹配位置的索引列表(1-based)
     *
     * 输入格式:
     * 第一行: m n (模式串长度和文本串长度)
     * 第二行: 模式串
     * 第三行: 文本串
     */

private:
    /**
     * @brief 计算字符串匹配度分数
     * @param S 模式串的多项式表示(已反转)
     * @param T 文本串的多项式表示
     * @param m 模式串长度
     * @param n 文本串长度
     * @return 匹配度分数向量，分数为0表示完全匹配
     */
    std::vector<int> computeMatchingScore(const Poly &S, const Poly &T, int m, int n)
    {
        Poly cur(m), tmp(n);
        std::vector<int> p;

        // 第一项: S^3 * T
        for (int i = 0; i < m; ++i)
        {
            cur[i] = 1ll * S[i] * S[i] % P * S[i] % P;
        }
        for (int i = 0; i < n; ++i)
        {
            tmp[i] = T[i];
        }
        cur = cur * tmp;
        p.assign(cur.size(), 0);
        for (int i = 0; i < static_cast<int>(cur.size()); ++i)
        {
            p[i] = (p[i] + cur[i]) % P;
        }

        // 第二项: -2 * S^2 * T^2
        cur.resize(m);
        for (int i = 0; i < m; ++i)
        {
            cur[i] = 1ll * S[i] * S[i] % P;
        }
        for (int i = 0; i < n; ++i)
        {
            tmp[i] = 1ll * T[i] * T[i] % P;
        }
        cur = cur * tmp;
        for (int i = 0; i < static_cast<int>(cur.size()); ++i)
        {
            p[i] = (p[i] - 2ll * cur[i] % P + P) % P;
        }

        // 第三项: S * T^3
        cur.resize(m);
        for (int i = 0; i < m; ++i)
        {
            cur[i] = S[i];
        }
        for (int i = 0; i < n; ++i)
        {
            tmp[i] = 1ll * T[i] * T[i] % P * T[i] % P;
        }
        cur = cur * tmp;
        for (int i = 0; i < static_cast<int>(cur.size()); ++i)
        {
            p[i] = (p[i] + cur[i]) % P;
        }

        return p;
    }
};

```

### NTT优化有限字符集的匹配
当我们的字符集数量有限且时间充裕时，我们可以考虑每次只匹配一个字符，然后对每个字符都跑一次匹配，累加起来便是答案。



这样做的好处是我们可以得到每个位置的匹配情况，即能有多少个位置匹配上.

具体的说，假设我们匹配字符![image](https://cdn.nlark.com/yuque/__latex/44f7dc40bf2619f2414884760f8cd0ff.svg),我们把两个串对应位置的权值设为![image](https://cdn.nlark.com/yuque/__latex/63c3949ecc12dfaa7950c0a21714386d.svg)然后直接把权值卷起来即可，注意我们仍然要翻转字符串![image](https://cdn.nlark.com/yuque/__latex/26fdbf8e53cb0e48da5f4ddd4aaf5a5c.svg)

复杂度![image](https://cdn.nlark.com/yuque/__latex/72b2e585eb5b235444be7d5027128541.svg)



# 博弈论
主要分为公平组合博弈和不公平游戏

分别有不同的考虑方法



### 公平组合游戏
即双方的可行操作集合相同



对于公平组合游戏，我们可以考虑![image](https://cdn.nlark.com/yuque/__latex/8a1be16bfc11a9c891fc57219b31b259.svg)定理，把组合游戏拆分成独立的小游戏，算出每个小游戏的![image](https://cdn.nlark.com/yuque/__latex/8a1be16bfc11a9c891fc57219b31b259.svg)函数值，它们的异或和为组合游戏的![image](https://cdn.nlark.com/yuque/__latex/8a1be16bfc11a9c891fc57219b31b259.svg)值，也称为![image](https://cdn.nlark.com/yuque/__latex/e7d265f9e53086c957faf40283729b0b.svg)和，其中![image](https://cdn.nlark.com/yuque/__latex/6598379422d5170f03f4407478bc4174.svg)，其中![image](https://cdn.nlark.com/yuque/__latex/a770a282bbfa0ae1ec474b7ed311656d.svg)表示![image](https://cdn.nlark.com/yuque/__latex/77c3adce895348f6083c425fe1ba2624.svg)能到达的状态。



如果不容易求![image](https://cdn.nlark.com/yuque/__latex/8a1be16bfc11a9c891fc57219b31b259.svg)函数或者不满足![image](https://cdn.nlark.com/yuque/__latex/8a1be16bfc11a9c891fc57219b31b259.svg)函数的条件，我们还可以考虑记忆化搜索的方法暴力求解，即后继态有必胜态的为必胜态，全为必败态的为必败态。

```cpp
sg[0] = 0; // 0是输 1是赢 初值根据题目变化
sg[1] = 1;
for (int i = 2; i <= N; i++)
{
    std::set<int> mex;
    int s = 0;
    for (int j = 1; j < i; j++)
    {
        if (满足条件) // 说明 i能到i-j
        {
            mex.insert(sg[i - j]);
        }
    }
    while (mex.count(s))
    {
        s++;
    }
    sg[i] = s;
}
for (int i = 1; i <= N; i += 1)
{
    cout << "sg " << i << ": " << sg(i) << "\n";
}
```

```cpp
    std::map<std::pair<int, int>, int> mp;
    mp[{0, 0}] = 1; // 赋初值
    mp[{0, 1}] = 1;
    mp[{1, 0}] = 1;
    mp[{1, 1}] = 1;
    auto check = [&](auto check, int x, int y) -> int
    {
        if (mp[{x, y}])
        {
            return mp[{x, y}];
        }
        for (int i = 1; i <= x / 2; ++i)
        {
            if (check(check, x - 2 * i, y + i) == 1)
            {
                mp[{x, y}] = 2;
                return 2;
            } // 前继状态
        }
        for (int i = 1; i <= y / 2; ++i)
        {
            if (check(check, x + i, y - 2 * i) == 1)
            {
                mp[{x, y}] = 2;
                return 2;
            } // 前继
        }
        mp[{x, y}] = 1;
        return 1;
    };
```

### 公平组合游戏下的经典模型
#### Nim游戏
给定![image](https://cdn.nlark.com/yuque/__latex/df378375e7693bdcf9535661c023c02e.svg)堆式子，第![image](https://cdn.nlark.com/yuque/__latex/2443fbcfeb7e85e1d62b6f5e4f27207e.svg)堆石子有![image](https://cdn.nlark.com/yuque/__latex/2dc649a10f2cddc4f17e401268418402.svg)个，两名玩家轮流行动，每次任选一堆取走任意多个石子，不能不取，取走最后一颗石子者获胜。

结论：定义![image](https://cdn.nlark.com/yuque/__latex/e7d265f9e53086c957faf40283729b0b.svg)和为![image](https://cdn.nlark.com/yuque/__latex/1dfa2bed189d7f34369f9ee7c4947bb9.svg)，若![image](https://cdn.nlark.com/yuque/__latex/e7d265f9e53086c957faf40283729b0b.svg)和为![image](https://cdn.nlark.com/yuque/__latex/22d0feea96d3bb2fc273f7598ce748c1.svg)，那么先手必败，否则先手必胜。

证明：

若当前![image](https://cdn.nlark.com/yuque/__latex/e7d265f9e53086c957faf40283729b0b.svg)和不为![image](https://cdn.nlark.com/yuque/__latex/22d0feea96d3bb2fc273f7598ce748c1.svg)，我一定可以使得下一步![image](https://cdn.nlark.com/yuque/__latex/e7d265f9e53086c957faf40283729b0b.svg)和为![image](https://cdn.nlark.com/yuque/__latex/22d0feea96d3bb2fc273f7598ce748c1.svg),也即必胜态以后一定有必败态。

若当前![image](https://cdn.nlark.com/yuque/__latex/e7d265f9e53086c957faf40283729b0b.svg)和为![image](https://cdn.nlark.com/yuque/__latex/22d0feea96d3bb2fc273f7598ce748c1.svg)，我一定找不到一种方法使得下一步![image](https://cdn.nlark.com/yuque/__latex/e7d265f9e53086c957faf40283729b0b.svg)和仍然为![image](https://cdn.nlark.com/yuque/__latex/22d0feea96d3bb2fc273f7598ce748c1.svg)，即必败态后都是必胜态

#### 巴什博奕
有一堆石子数量为![image](https://cdn.nlark.com/yuque/__latex/df378375e7693bdcf9535661c023c02e.svg),两名玩家轮流取，拿的个数范围是![image](https://cdn.nlark.com/yuque/__latex/1b876e3f827385895bce97a5a70dcfa9.svg)，取走最后一颗石子者获胜。

结论：若![image](https://cdn.nlark.com/yuque/__latex/76fab8ea85a3b17b1996b5559bc88e28.svg)，则先手必败。反之先手必胜。

![image](https://cdn.nlark.com/yuque/__latex/e575feb680f3e70d67ac014b8e222431.svg)

证明:

若![image](https://cdn.nlark.com/yuque/__latex/d453cdffefe88f3e1525329315730c41.svg)显然先手必胜，当![image](https://cdn.nlark.com/yuque/__latex/4bd8d51e5f359a65c5c46da70f138d48.svg)时显然先手必败，当![image](https://cdn.nlark.com/yuque/__latex/f05764ec956026a570baabe12d3354c7.svg)时，如果![image](https://cdn.nlark.com/yuque/__latex/df378375e7693bdcf9535661c023c02e.svg)是![image](https://cdn.nlark.com/yuque/__latex/d6f147b9f168e0b5fbec1db2ccaa315b.svg)的倍数，无论先手如何操作，都无法把必败态留给对方。反之，后手一定有办法再次使得![image](https://cdn.nlark.com/yuque/__latex/76fab8ea85a3b17b1996b5559bc88e28.svg)，也即把必败态留给先手。

#### 威佐夫博弈
有两堆石子，两人轮流取石子，每次可以在一堆中取，也可以在两堆中取走相同数量的石子。取走最后一个石子者获胜。

结论：记![image](https://cdn.nlark.com/yuque/__latex/2e6e6a559616a1b7f301b53082231e97.svg)为两堆石子个数，若![image](https://cdn.nlark.com/yuque/__latex/98d10afa916868d141dc1c12e248c680.svg)，那么先手必败，否则先手必胜。

证明略。

#### 斐波那契博弈
有一堆数量为![image](https://cdn.nlark.com/yuque/__latex/46c362865e7f456d061c8e09a8c5ea20.svg)的石子，两人轮流取，先手不能一次取完。如果前一个人取了![image](https://cdn.nlark.com/yuque/__latex/c0a0aac306bfd34228692a6442cb1cb2.svg)个石子，那么我取的石子数量范围为![image](https://cdn.nlark.com/yuque/__latex/3189d021ae1a2ecf1dfc734a4533947a.svg)，取走最后一个石子者获胜。

结论:若![image](https://cdn.nlark.com/yuque/__latex/df378375e7693bdcf9535661c023c02e.svg)为斐波那契数则先手必败，否则先手必胜。

#### 广义斐波那契博弈
即如果前一个人取了![image](https://cdn.nlark.com/yuque/__latex/c0a0aac306bfd34228692a6442cb1cb2.svg),我能取的范围变为![image](https://cdn.nlark.com/yuque/__latex/badd4b15e5e77478b6c2820cdcb93683.svg)，此时我们有广义的斐波那契数列![image](https://cdn.nlark.com/yuque/__latex/a2d1396f06b11108783025cc5105bb88.svg)，即![image](https://cdn.nlark.com/yuque/__latex/013e4864d82832f53a140bcad88e2894.svg)如果石子数量在该数列中，则先手必败。否则必胜

#### ![image](https://cdn.nlark.com/yuque/__latex/eebeba2797e0b01351ddef4c7d392aec.svg)博弈
在![image](https://cdn.nlark.com/yuque/__latex/e7d265f9e53086c957faf40283729b0b.svg)的基础上，每次可以从![image](https://cdn.nlark.com/yuque/__latex/df976ff7fcf17d60490267d18a1e3996.svg)堆石子取，每堆取的石子数量可以不同。

一堆石子的![image](https://cdn.nlark.com/yuque/__latex/8a1be16bfc11a9c891fc57219b31b259.svg)值为石子数，对每一个二进制位单独考虑，求每一个二进制位为![image](https://cdn.nlark.com/yuque/__latex/53072c2388d69edc65c2377681e4e87c.svg)的堆数，然后![image](https://cdn.nlark.com/yuque/__latex/68c3e6a5593376ca15c762149deee497.svg)，如果每个二进制的结果均为![image](https://cdn.nlark.com/yuque/__latex/22d0feea96d3bb2fc273f7598ce748c1.svg)则必败，否则必胜

#### ![image](https://cdn.nlark.com/yuque/__latex/181c708a1376089c40bbf4db5bef61fa.svg)博弈
即获胜条件改为不能取的一方获胜



必胜：![image](https://cdn.nlark.com/yuque/__latex/fa9a0700cc9b386bc3ef526070394856.svg)且至少有一堆石子数![image](https://cdn.nlark.com/yuque/__latex/19b16f74b979ae56e97ac3eba1ee3bee.svg),![image](https://cdn.nlark.com/yuque/__latex/772d5d54e1bed4d2f63bc247e174e846.svg)且每堆石子个数不超过1

其余均必败

#### ![image](https://cdn.nlark.com/yuque/__latex/41e4322449193c4abf1d6d150edc225b.svg)博弈
获胜条件改为不能移动的一方获胜

必胜：![image](https://cdn.nlark.com/yuque/__latex/fa9a0700cc9b386bc3ef526070394856.svg)且至少有一个游戏满足![image](https://cdn.nlark.com/yuque/__latex/b74513717f6c052d0ed8a88ddce815f0.svg),![image](https://cdn.nlark.com/yuque/__latex/772d5d54e1bed4d2f63bc247e174e846.svg)且每个游戏都满足![image](https://cdn.nlark.com/yuque/__latex/707130b35142dbcb1cf053aba4738632.svg)

其余均必败

#### ![image](https://cdn.nlark.com/yuque/__latex/924ad9a83bc326fe83e872a9ace45191.svg)博弈
阶梯博弈，每次可以从一个阶梯上拿掉任意数量石子放到下一个阶梯，不能操作者输

![image](https://cdn.nlark.com/yuque/__latex/8a1be16bfc11a9c891fc57219b31b259.svg)函数为奇数阶梯上的石子的异或和，如果移动偶数层的石子到奇数层，对手一定能把这些石子继续移动到偶数层，使其![image](https://cdn.nlark.com/yuque/__latex/8a1be16bfc11a9c891fc57219b31b259.svg)函数不变。

![image](https://cdn.nlark.com/yuque/__latex/7643c8480c883256184f48f9c01aad17.svg)则必败。否则必胜

#### ![image](https://cdn.nlark.com/yuque/__latex/fb32d5b7283cb9412f93fa8f15b0a2f2.svg)博弈
![image](https://cdn.nlark.com/yuque/__latex/df378375e7693bdcf9535661c023c02e.svg)堆石子，每次可以从一堆中取任意个石子，或者至少选择某堆至少为![image](https://cdn.nlark.com/yuque/__latex/2b89979f54ec02a7bf87aa0c1ea58ff9.svg)的石子，分成两堆非空石子。

![image](https://cdn.nlark.com/yuque/__latex/86d17925cb525ee241716df0ed3d09d5.svg)

对于![image](https://cdn.nlark.com/yuque/__latex/90a5e0ed1372304fd28ffe1f7ee9ba8d.svg),满足![image](https://cdn.nlark.com/yuque/__latex/e1083915f0ac5a901c61c6eaea50ae4c.svg),![image](https://cdn.nlark.com/yuque/__latex/6af54a6e413c3016c773a5a1c404678e.svg)

![image](https://cdn.nlark.com/yuque/__latex/771b104e21d449ec6123e1de00dd7b22.svg)

#### 树上删边博弈
给一个![image](https://cdn.nlark.com/yuque/__latex/df378375e7693bdcf9535661c023c02e.svg)个点的有根树，每次可以删掉一个子树。

叶子结点的![image](https://cdn.nlark.com/yuque/__latex/8a1be16bfc11a9c891fc57219b31b259.svg)为![image](https://cdn.nlark.com/yuque/__latex/22d0feea96d3bb2fc273f7598ce748c1.svg)，非叶子节点的![image](https://cdn.nlark.com/yuque/__latex/8a1be16bfc11a9c891fc57219b31b259.svg)为所有子节点的![image](https://cdn.nlark.com/yuque/__latex/458802e0d288412eb199a29ab54b9971.svg)的异或和

#### 无向图删边游戏
注意此时也需要一个参考点（也就是根），删去一条边后，不属于参考点所在的联通块会被舍去。

对于自环的处理

（把它连向一个新的点即可，或者让它自己的函数值异或![image](https://cdn.nlark.com/yuque/__latex/53072c2388d69edc65c2377681e4e87c.svg)）

我们考虑![image](https://cdn.nlark.com/yuque/__latex/5a309a58a010ec33df3d862d2c7aff04.svg)缩点，每个![image](https://cdn.nlark.com/yuque/__latex/5a309a58a010ec33df3d862d2c7aff04.svg)的![image](https://cdn.nlark.com/yuque/__latex/8a1be16bfc11a9c891fc57219b31b259.svg)值取决于![image](https://cdn.nlark.com/yuque/__latex/5a309a58a010ec33df3d862d2c7aff04.svg)内边的数量，如有偶数条边则为![image](https://cdn.nlark.com/yuque/__latex/22d0feea96d3bb2fc273f7598ce748c1.svg),否则为![image](https://cdn.nlark.com/yuque/__latex/53072c2388d69edc65c2377681e4e87c.svg)

然后套用树上删边博弈即可。

#### 一般图上博弈
关于二分图上博弈的内容在二分图中有介绍

给定无向图, 先手从起点开始走, 只能走相邻且未走过的点, 无法移动者输.

对该图求最大匹配, 若起点不一定在最大匹配中则先手必败, 否则先手必胜.

#### 翻硬币游戏
![image](https://cdn.nlark.com/yuque/__latex/df378375e7693bdcf9535661c023c02e.svg)枚硬币排成一排，有的正面朝上，有的反面朝上，给定一些翻硬币的约束（比如只能翻![image](https://cdn.nlark.com/yuque/__latex/53072c2388d69edc65c2377681e4e87c.svg)枚，比如只能翻连续几枚），但所翻的硬币中，最右边的必须是从正面翻到反面，不能行动者输。



有如下结论：局面的![image](https://cdn.nlark.com/yuque/__latex/8a1be16bfc11a9c891fc57219b31b259.svg)值等于局面中每个正面朝上的棋子单一存在时的![image](https://cdn.nlark.com/yuque/__latex/8a1be16bfc11a9c891fc57219b31b259.svg)值的异或和。（即只有该棋子正面，其他都是反面，根据它的位置![image](https://cdn.nlark.com/yuque/__latex/712ecf7894348e92d8779c3ee87eeeb0.svg)有一个![image](https://cdn.nlark.com/yuque/__latex/04d84851a1c6087222ef14ab1d8538d1.svg)）



情况![image](https://cdn.nlark.com/yuque/__latex/53072c2388d69edc65c2377681e4e87c.svg)，每次只能翻一个

![image](https://cdn.nlark.com/yuque/__latex/b06c214fb1ee032b5bb004bc33c0c1f3.svg)

情况![image](https://cdn.nlark.com/yuque/__latex/2b89979f54ec02a7bf87aa0c1ea58ff9.svg)，每次可以翻一个或两个(不要求相邻)

![image](https://cdn.nlark.com/yuque/__latex/e16f9e7a0e3f79b7a760f268b9665863.svg)

情况![image](https://cdn.nlark.com/yuque/__latex/a7720a85557fdd660de5e2da1dfa7c07.svg)，每次必须翻两个，且两个的距离在![image](https://cdn.nlark.com/yuque/__latex/aeca85472fab0aaab596f65e394053d3.svg)中，等价于巴什博奕

![image](https://cdn.nlark.com/yuque/__latex/2949c5e7c8bc9eb4700c7c4e7b5cc337.svg)

情况![image](https://cdn.nlark.com/yuque/__latex/afb0613a26341d701b3967ba170aa30c.svg)：每次必须翻连续的![image](https://cdn.nlark.com/yuque/__latex/4760e2f007e23d820825ba241c47ce3b.svg)个硬币

![image](https://cdn.nlark.com/yuque/__latex/712b127248049a9b7377a6ea0456c289.svg),其余为![image](https://cdn.nlark.com/yuque/__latex/22d0feea96d3bb2fc273f7598ce748c1.svg)

情况![image](https://cdn.nlark.com/yuque/__latex/b15983bcda2a67366d095cfeb326717a.svg)每次可以翻任意长度的连续一段硬币，![image](https://cdn.nlark.com/yuque/__latex/c4d3f018a7adbe27e1e47a9918a0d8b8.svg)

### 不公平游戏
 两名玩家轮流操作的博弈，每个局面下 双方可行的操作集合可能不同，或者某些动作只允许某一方使用。  
换句话说，玩家的可行动作不对称，我们称为不公平游戏。

#### **<font style="color:rgb(26, 28, 30);">超现实数 (Surreal Numbers)</font>**
超现实数类似于![image](https://cdn.nlark.com/yuque/__latex/8a1be16bfc11a9c891fc57219b31b259.svg)函数，用于解决不公平游戏问题

超现实数的不同游戏间的组合方法是相加

我们不妨用![image](https://cdn.nlark.com/yuque/__latex/f5e2395ebf52e7bc9f6bf94426c89d16.svg)来表示 

如果![image](https://cdn.nlark.com/yuque/__latex/140e6dd9bc1a8e149ef4e607bd724a86.svg) 那么左玩家必胜

如果![image](https://cdn.nlark.com/yuque/__latex/bb9886a665b8161895eedabce0592d82.svg)那么右玩家必胜

如果![image](https://cdn.nlark.com/yuque/__latex/13e41006b47de244368f91dacf6a25af.svg)那么后手必胜

单个游戏的值![image](https://cdn.nlark.com/yuque/__latex/f8df64a4bfdeb9bdcbc357668b6fb123.svg)被定义为![image](https://cdn.nlark.com/yuque/__latex/4c05e8041dd62939053494c939f40be1.svg),其中![image](https://cdn.nlark.com/yuque/__latex/c895173d3be4872abf206be4268a58cb.svg)是左玩家所有可能移动后到达的局面集合，![image](https://cdn.nlark.com/yuque/__latex/dd1caa3f2e1582dab2cf9bfdb21b7556.svg)同理。

#### ![image](https://cdn.nlark.com/yuque/__latex/75e9b2bc63ae7b2a80b1de833dd76726.svg)博弈
有若干个字符串仅有![image](https://cdn.nlark.com/yuque/__latex/54f5fb1b07a88521e7b036e3bc7a5e33.svg)和![image](https://cdn.nlark.com/yuque/__latex/a36915ecf0b5605493f5aeaf1480a9ac.svg)组成，小![image](https://cdn.nlark.com/yuque/__latex/c9b08ae6d9fed72562880f75720531bc.svg) 回合只能拿W，小![image](https://cdn.nlark.com/yuque/__latex/54f5fb1b07a88521e7b036e3bc7a5e33.svg)回合只能拿![image](https://cdn.nlark.com/yuque/__latex/54f5fb1b07a88521e7b036e3bc7a5e33.svg)，每次拿走一个字符后其后缀也会消失，最先不能操作者输。



首先这是一个不公平游戏，因为操作域不同，因此我们考虑对每个串计算它的![image](https://cdn.nlark.com/yuque/__latex/d401a44738c6936dcdc79546254c9ca5.svg)并求和，再根据上面结论判断即可。

在本题中可以证明，一个串的![image](https://cdn.nlark.com/yuque/__latex/d401a44738c6936dcdc79546254c9ca5.svg)值为![image](https://cdn.nlark.com/yuque/__latex/d507d60f49494b70d18747613509f0f5.svg)，

其中![image](https://cdn.nlark.com/yuque/__latex/8ac4b3a9cfa7ed5d720247b18fb3e7dd.svg)。



#### ![image](https://cdn.nlark.com/yuque/__latex/4d3c2056c49e884a2c642854fb1a3cc7.svg)
一个序列，两个人轮流从最左或者最右拿一个数，谁总和大谁胜。

转化成求最大差值，对于连续的三个数![image](https://cdn.nlark.com/yuque/__latex/c215f0ec3052f11cae0a540b42407af7.svg)，如果![image](https://cdn.nlark.com/yuque/__latex/b99b371503d7231718a0e2257189c408.svg) 且![image](https://cdn.nlark.com/yuque/__latex/bd5feedd46db94ba80856d53de0f3cad.svg)，那么可以将这三个数合并为![image](https://cdn.nlark.com/yuque/__latex/d0188844f88b692fcbfa8061f4094350.svg)。从左往右维护一个栈，每次新加入数的时候不断合并栈顶三个元素，那么最后栈是先递减再递增，此时贪心拿两侧最大的数即为最佳策略。

#### ![image](https://cdn.nlark.com/yuque/__latex/d16512ade77c5b49bf33500224f15b80.svg)
给出一列数，两人轮流从最左或者最右拿走一个数，如果目前轮到![image](https://cdn.nlark.com/yuque/__latex/de951302f41d4707b9d80ca1af34dd0f.svg)操作，这个序列单调不下降或者单调不上升，那么![image](https://cdn.nlark.com/yuque/__latex/de951302f41d4707b9d80ca1af34dd0f.svg)输。

每次询问在某个区间![image](https://cdn.nlark.com/yuque/__latex/371d3811de80d3e7a448b5cebe095023.svg) 玩游戏的结果。

我们考虑什么样的情况能判断结果

![image](https://cdn.nlark.com/yuque/__latex/53072c2388d69edc65c2377681e4e87c.svg)对于一个区间![image](https://cdn.nlark.com/yuque/__latex/371d3811de80d3e7a448b5cebe095023.svg)，若它是单调的，则显然先手必败。

![image](https://cdn.nlark.com/yuque/__latex/2b89979f54ec02a7bf87aa0c1ea58ff9.svg)若去掉![image](https://cdn.nlark.com/yuque/__latex/6945e109777fe3fd777e8254f0ec0f0c.svg) 或者![image](https://cdn.nlark.com/yuque/__latex/72cb3a229067770aeb6caa625a65a1a1.svg) 后变成了单调的，则显然先手必胜。

![image](https://cdn.nlark.com/yuque/__latex/a7720a85557fdd660de5e2da1dfa7c07.svg)若![image](https://cdn.nlark.com/yuque/__latex/96524466ce460f033fe1c967b28126d5.svg) 是单调的，那么同理先手必败。

![image](https://cdn.nlark.com/yuque/__latex/afb0613a26341d701b3967ba170aa30c.svg)若![image](https://cdn.nlark.com/yuque/__latex/2bb11eb2d8a926f93dbd3be3aa63ea96.svg) 是单调的，那么先手若取![image](https://cdn.nlark.com/yuque/__latex/72cb3a229067770aeb6caa625a65a1a1.svg)会导致后手必胜，后手同理，故两人会一直取![image](https://cdn.nlark.com/yuque/__latex/6945e109777fe3fd777e8254f0ec0f0c.svg)直到出现上面第一种或者第二种情况，可以根据奇偶性判断。

![image](https://cdn.nlark.com/yuque/__latex/b15983bcda2a67366d095cfeb326717a.svg)同理可以得出![image](https://cdn.nlark.com/yuque/__latex/b319cffb4b7d7e9b4468cb496b12a6b9.svg) 是单调的情形的处理方法。

除此之外，有![image](https://cdn.nlark.com/yuque/__latex/371d3811de80d3e7a448b5cebe095023.svg)的答案等于![image](https://cdn.nlark.com/yuque/__latex/96524466ce460f033fe1c967b28126d5.svg) 的答案，二分找到最小的k 满足![image](https://cdn.nlark.com/yuque/__latex/2ba3f67d9820ff4354fae89f2eca1fc3.svg)可以由上面方法直接判断出胜负即可。

#### ![image](https://cdn.nlark.com/yuque/__latex/7fcb28bc3a8bff59bbad04fc114b5eaa.svg)
给出一列数，两人轮流从最左或者最右拿走一个数，最后得分是拿过的数的异或和，谁高

谁赢，预测结果

![image](https://cdn.nlark.com/yuque/__latex/53072c2388d69edc65c2377681e4e87c.svg)首先如果所有数字异或和为![image](https://cdn.nlark.com/yuque/__latex/22d0feea96d3bb2fc273f7598ce748c1.svg)，一定平局

![image](https://cdn.nlark.com/yuque/__latex/2b89979f54ec02a7bf87aa0c1ea58ff9.svg)在除去![image](https://cdn.nlark.com/yuque/__latex/53072c2388d69edc65c2377681e4e87c.svg)的情况下，一定不会平局

![image](https://cdn.nlark.com/yuque/__latex/a7720a85557fdd660de5e2da1dfa7c07.svg)当![image](https://cdn.nlark.com/yuque/__latex/df378375e7693bdcf9535661c023c02e.svg)为偶数时，先手必胜，我们不妨给![image](https://cdn.nlark.com/yuque/__latex/df378375e7693bdcf9535661c023c02e.svg)个格子相邻黑白染色，不难发现先手可以选择拿所有的白色格子或者黑色格子，这两个选大的拿即可。

![image](https://cdn.nlark.com/yuque/__latex/afb0613a26341d701b3967ba170aa30c.svg)我们不妨考虑异或和![image](https://cdn.nlark.com/yuque/__latex/55fc237afbe535f7d8434985b848a6a7.svg)的最高二进制位![image](https://cdn.nlark.com/yuque/__latex/99afaeb9266d5f28e808cc468c8f26c7.svg),那么我们根据这一个数字是否有![image](https://cdn.nlark.com/yuque/__latex/99afaeb9266d5f28e808cc468c8f26c7.svg)这一位分为![image](https://cdn.nlark.com/yuque/__latex/22d0feea96d3bb2fc273f7598ce748c1.svg)或![image](https://cdn.nlark.com/yuque/__latex/53072c2388d69edc65c2377681e4e87c.svg)，那么拿到奇数个![image](https://cdn.nlark.com/yuque/__latex/53072c2388d69edc65c2377681e4e87c.svg)则必胜。如果![image](https://cdn.nlark.com/yuque/__latex/8660f383f32f37be95a65acf6f7573ff.svg)，那么后手模仿方案![image](https://cdn.nlark.com/yuque/__latex/a7720a85557fdd660de5e2da1dfa7c07.svg)即可取胜。否则先手一定会拿![image](https://cdn.nlark.com/yuque/__latex/53072c2388d69edc65c2377681e4e87c.svg),先手拿![image](https://cdn.nlark.com/yuque/__latex/53072c2388d69edc65c2377681e4e87c.svg)以后，必须模仿后手行动，即后手拿什么则先手拿什么，假如先手后手拿的不同，那么此时先手和后手手里的数字相同且轮到后手，后手仍然可以通过![image](https://cdn.nlark.com/yuque/__latex/a7720a85557fdd660de5e2da1dfa7c07.svg)必胜，因此我们判断能否模仿即可

![image](https://cdn.nlark.com/yuque/__latex/b15983bcda2a67366d095cfeb326717a.svg)如何判断能否模仿![image](https://cdn.nlark.com/yuque/__latex/154a2cc5295755366fa14e74af86d1f8.svg)，我们先不断删去首尾相同的数字，然后判断接下来两两是否相同即可

# 线性代数
### 矩阵与矩阵快速幂
十分需要注意的是 矩阵的幂由于不满足费马小定理 因此不能取模

```cpp
struct matrix
{
    int Mat[N + 1][N + 1];
    matrix()
    {
        memset(Mat, 0, sizeof Mat);
    }
};
matrix operator*(matrix x, matrix y)
{
    matrix t;
    for (int i = 1; i <= N; ++i)
    {
        for (int j = 1; j <= N; ++j)
        {
            for (int k = 1; k <= N; ++k)
            {
                t.Mat[i][j] = (t.Mat[i][j] + 1ll * x.Mat[i][k] * y.Mat[k][j] % p) % p;
            }
        }
    }
    return t;
}
matrix qmi(matrix a, int b)
{
    matrix res;
    for (int i = 1; i <= N; ++i)
    {
        res.Mat[i][i] = 1;
    }
    while (b)
    {
        if (b & 1)
        {
            res = res * a;
        }
        a = a * a;
        b >>= 1;
    }
    return res;
}
```

### 行列式
类似于高斯消元消成上三角形式，这里我们采用了辗转相减的方法，可以应对![image](https://cdn.nlark.com/yuque/__latex/e9424f82b33766c5afe4889cad2e222e.svg)数为非质数的情况

```cpp
int determinant(std::vector<std::vector<int>> a, int n)
{
    int res = 1, w = 1;
    for (int i = 1; i <= n; i++)
    {
        for (int j = i + 1; j <= n; ++j)
        {
            while (a[i][i])
            {
                int div = a[j][i] / a[i][i];
                for (int k = i; k <= n; ++k)
                {
                    a[j][k] = (a[j][k] - 1ll * div * a[i][k] % p + p) % p;
                }
                swap(a[i], a[j]);
                w = -w;
            } // 对第 i 行和第 j 行做辗转相减。不断交换次序相减
            swap(a[i], a[j]);
            w = -w;
        }
    }
    for (int i = 1; i <= n; i++) // 化成上三角
    {
        res = 1ll * a[i][i] * res % p; // 全部乘起来
    }
    res = 1ll * w * res;  // 正负问题
    return (res + p) % p; 
}

```

### 加法高斯消元
我们通过![image](https://cdn.nlark.com/yuque/__latex/a77815a52a2d0050828079fb142b1410.svg)的三重循环将增广矩阵消成上三角形式，再从末尾式子开始回代得到答案，其中若系数全都为![image](https://cdn.nlark.com/yuque/__latex/22d0feea96d3bb2fc273f7598ce748c1.svg)但解不为![image](https://cdn.nlark.com/yuque/__latex/22d0feea96d3bb2fc273f7598ce748c1.svg)，则说明无解。否则有解，如果存在自由元，那么有无穷多解，否则有唯一解

```cpp
const long double eps = 1e-8;
int gauss(std::vector<std::vector<long double>> &a, int n)
{
    int col, row;
    for (col = 0, row = 0; col < n; col++) // 注意下标是从0开始的 n是未知数的个数
    {
        int tmp = row;
        for (int i = row; i < n; i++)
        {
            if (fabs(a[i][col]) > fabs(a[tmp][col]))
            {
                tmp = i;
            }
        }
        if (fabs(a[tmp][col]) < eps) // 为0
        {
            continue;
        }
        // tmp是绝对值最大的位置
        // row是最上面的位置
        // 把这两行完全交换
        for (int i = col; i <= n; i++)
        {
            std::swap(a[tmp][i], a[row][i]);
        }
        for (int i = n; i >= col; i--)
        {
            a[row][i] /= a[row][col];
        }
        for (int i = row + 1; i < n; i++)
        {
            if (fabs(a[i][col]) > eps)
            {
                for (int j = n; j >= col; j--)
                {
                    a[i][j] -= a[row][j] * a[i][col];
                }
            }
        }
        row++;
    } // 这个循环的作用是消成上三角
    for (int i = n - 1; i >= 0; i--)
    {
        for (int j = i + 1; j < n; j++)
        {
            a[i][n] -= a[i][j] * a[j][n]; // 得到正确的解
        }
    }
    if (row < n) // 这里说明[row,n-1]的行已经没系数了
    {
        for (int i = row; i < n; i++)
        {
            if (fabs(a[i][n]) > eps) // 此刻还有值就是无解
            {
                return -1; // 无解
            }
        }
        return 1; // 有无穷多组解 因为存在自由元
    }
    return 0; // 有唯一解  a[i][n]为各个解(i从0到n-1)
}

```

### 异或高斯消元
复杂度为![image](https://cdn.nlark.com/yuque/__latex/bcc9e579b6c3dfd20312f2f5eeb1a39b.svg)，做法和加法类似，使用![image](https://cdn.nlark.com/yuque/__latex/759411de49355c93f91977786e8ef4a6.svg)优化。

```cpp
const int N = 1001;
std::vector<int> Gauss(std::vector<std::bitset<N>> &equation, std::vector<int> &res, int n)
{
    int m = equation.size();
    std::vector<int> ans(n, 0);
    int row = 0;

    // 前向消元
    for (int col = 0; col < n && row < m; ++col)
    {
        // 寻找主元
        int pivot = -1;
        for (int i = row; i < m; ++i)
        {
            if (equation[i][col])
            {
                pivot = i;
                break;
            }
        }

        if (pivot == -1)
            continue; // 自由元

        // 交换行
        if (pivot != row)
        {
            std::swap(equation[row], equation[pivot]);
            std::swap(res[row], res[pivot]);
        }

        // 消去其他行
        for (int i = 0; i < m; ++i)
        {
            if (i != row && equation[i][col])
            {
                equation[i] ^= equation[row];
                res[i] ^= res[row];
            }
        }

        ++row;
    }

    // 检查无解情况
    for (int i = row; i < m; ++i)
    {
        if (res[i])
        {
            return {-1}; // 无解
        }
    }

    // 回代求解
    for (int i = 0; i < n; ++i)
    {
        ans[i] = -1; // 初始化为自由元
    }

    for (int i = row - 1; i >= 0; --i)
    {
        // 找到主元列
        int col = 0;
        while (col < n && !equation[i][col])
            ++col;

        if (col >= n)
            continue; // 全零行

        ans[col] = res[i];
        // 标记非自由元
        for (int j = col + 1; j < n; ++j)
        {
            if (equation[i][j])
            {
                if (ans[j] == -1)
                {
                    // 自由元可以任意取值，这里设为0
                    ans[j] = 0;
                }
                ans[col] ^= ans[j];
            }
        }
    }
    // 处理自由元（设为0）
    for (int i = 0; i < n; ++i)
    {
        if (ans[i] == -1)
        {
            ans[i] = 0;
        }
    }

    return ans;
}
```

### 动态维护异或方程组
我们考虑维护一个长度为方程组长度的线性基即可

# 计算几何
我们设两个点![image](https://cdn.nlark.com/yuque/__latex/a77cb6a83e517d67ba17ffc8c51c876a.svg)

两点的曼哈顿距离:![image](https://cdn.nlark.com/yuque/__latex/4377f1eb5689050132b716241c297957.svg)

两点的切比雪夫距离:![image](https://cdn.nlark.com/yuque/__latex/caa5d3dfdfcd103236881e70fef07c6a.svg)

两点的欧几里得距离:![image](https://cdn.nlark.com/yuque/__latex/149f511ac8ed950d82d5c22faac3fcd7.svg)

曼哈顿与切比雪夫距离的转化:

曼哈顿![image](https://cdn.nlark.com/yuque/__latex/94eac656a749d4e9739edc91b6091036.svg)切比雪夫 :![image](https://cdn.nlark.com/yuque/__latex/a907d788b5c2e16bb66c89eeb042026f.svg)

切比雪夫![image](https://cdn.nlark.com/yuque/__latex/94eac656a749d4e9739edc91b6091036.svg)曼哈顿 :![image](https://cdn.nlark.com/yuque/__latex/14f97dd98fc0a4b207a872a2f0e019e1.svg)

### 平面几何
![image](https://cdn.nlark.com/yuque/__latex/4bfdb493a8427137226d53b3370bdd88.svg)返回对应三角函数值，有![image](https://cdn.nlark.com/yuque/__latex/cad58d457be0cf254a86927529b21428.svg)三种返回值，和传参的类型相同。注意一定是![image](https://cdn.nlark.com/yuque/__latex/51e6bc21290de218273dc8e8c7d047f9.svg)前缀下的函数

注意![image](https://cdn.nlark.com/yuque/__latex/f321ef81167ac6398e53f14e70be50c1.svg)的传参范围是![image](https://cdn.nlark.com/yuque/__latex/e3df4a9071091f59883ac4edb91796f2.svg)注意不要越界，![image](https://cdn.nlark.com/yuque/__latex/0eb27c3c46ab0e2811034634ea2224d5.svg)不能传入![image](https://cdn.nlark.com/yuque/__latex/1f9d27fa7ca80ae0d907f96faf0d4bca.svg)

注意![image](https://cdn.nlark.com/yuque/__latex/46f2a0d403cad87920e86f22a2ab5752.svg)的返回值在![image](https://cdn.nlark.com/yuque/__latex/182c241327653ebd9f90dc83d6598f95.svg),<font style="color:rgb(64, 64, 64);"> 返回的是 </font><font style="color:rgb(64, 64, 64);">从正 x 轴到点 </font>`<font style="color:rgb(64, 64, 64);background-color:rgb(236, 236, 236);">(x, y)</font>`<font style="color:rgb(64, 64, 64);"> 的夹角</font><font style="color:rgb(64, 64, 64);">（弧度）</font>

<font style="color:rgb(64, 64, 64);">具体的说，若点</font>![image](https://cdn.nlark.com/yuque/__latex/a969cab25db24b7b40ddd3064d3ab658.svg)<font style="color:rgb(64, 64, 64);">在第一二象限则返回值为正，返回值按逆时针方向绝对值逐渐增大</font>

<font style="color:rgb(64, 64, 64);">否则返回值为负，返回值按顺时针方向绝对值逐渐增大。</font>

```cpp
#include <bits/stdc++.h>

using ll = long long;
using ld = long double;  // 浮点数类型
const ld eps = 1e-10;    // 浮点精度阈值
const ld pi = acosl(-1); // π
using pld = std::pair<ld, ld>;
using pii = std::pair<int, int>;
using pll = std::pair<ll, ll>;

// 符号函数：返回x的符号（1/0/-1）
int sgn(ld x)
{
    if (x > eps)
        return 1;
    if (x < -eps)
        return -1;
    return 0;
}
// 基础二维点/向量结构
template <class T>
struct Point
{
    T x, y;
    // 向量运算
    bool operator==(const Point &a) const { return (fabs(x - a.x) <= eps && fabs(y - a.y) <= eps); }
    bool operator<(const Point &a) const
    {
        if (fabs(x - a.x) <= eps)
            return y < a.y - eps;
        return x < a.x - eps;
    }
    bool operator>(const Point &a) const { return !(*this < a || *this == a); }
    Point operator+(const Point &a) const { return {x + a.x, y + a.y}; } // 向量加
    Point operator-(const Point &a) const { return {x - a.x, y - a.y}; } // 向量减
    Point operator-() const { return {-x, -y}; }                         // 向量取反
    Point operator*(const T k) const { return {k * x, k * y}; }
    Point operator/(const T k) const { return {x / k, y / k}; }
    // 点积（*）、叉积（%）
    T operator*(const Point &a) const { return x * a.x + y * a.y; }                                                    // 点积
    T operator%(const Point &a) const { return x * a.y - y * a.x; }                                                    // 叉积
    T len2() const { return (*this) * (*this); }                                                                       // 向量长度的平方
    T dis2(const Point &a) const { return (a - (*this)).len2(); }                                                      // 两点距离的平方
    ld len() const { return sqrtl(len2()); }                                                                           // 向量长度
    ld dis(const Point &a) const { return sqrtl(dis2(a)); }                                                            // 两点距离
    ld ang(const Point &a) const { return acosl(std::max(-1.0l, std::min(1.0l, ((*this) * a) / (len() * a.len())))); } // 向量夹角
    int toleft(const Point &a) const
    {
        const auto t = (*this) % a;
        return (t > eps) - (t < -eps);
    } // to-left 测试
    // 检查a向量在this的哪一测 >0逆时针 <0顺时针 =0同向

    // 旋转：90度逆时针
    Point rotate90() const { return {-y, x}; } // 逆时针旋转90°
    Point rotate(ld theta) const
    {
        ld c = cosl(theta), s = sinl(theta);
        return {
            (x * c - y * s),
            (x * s + y * c)};
    }
    Point rotate(const ld cosr, const ld sinr) const { return {x * cosr - y * sinr, x * sinr + y * cosr}; } // 逆时针旋转（给定角度的正弦与余弦）
};
// 极角排序
template <class T>
struct argcmp
{
    bool operator()(const Point<T> &a, const Point<T> &b) const
    {
        const auto quad = [](const Point<T> &a)
        {
            if (a.y < -eps)
                return 1;
            if (a.y > eps)
                return 4;
            if (a.x < -eps)
                return 5;
            if (a.x > eps)
                return 3;
            return 2;
        };
        const int qa = quad(a), qb = quad(b);
        if (qa != qb)
            return qa < qb;
        const auto t = a % b;
        if (fabs(t) <= eps)
            return a * a < b * b - eps; // 不同长度的向量需要分开
        return t > eps;
    }
};
template <class T>
struct Line // 直线
{
    Point<T> p, v; // p 为直线上一点，v 为方向向量

    bool operator==(const Line &a) const { return v.toleft(a.v) == 0 && v.toleft(p - a.p) == 0; }
    int toleft(const Point<T> &a) const { return v.toleft(a - p); } // to-left 测试 点a和该直线的位置关系
    bool operator<(const Line &a) const                             // 半平面交算法定义的排序
    {
        if (fabs(v % a.v) <= eps && v * a.v >= -eps)
            return toleft(a.p) == -1;
        return argcmp<T>()(v, a.v);
    }
    // 涉及浮点数
    ld dis(const Point<T> &a) const { return fabs(v % (a - p)) / v.len(); } // 点到直线距离
    // -------------------------------
    // 求两直线交点
    // 返回值: 是否有唯一交点
    //   false: 平行或重合
    //   true : 有交点
    // -------------------------------
    bool isCross(const Line &a) const // 是否有交
    {
        ld d = v % a.v;
        return sgn(d) ? 1 : 0;
    }
    Point<T> inter(const Line &a) const // 求交
    {
        ld d = v % a.v;
        ld t = (a.v % (p - a.p)) / d;
        return p + v * t;
    }
    // -------------------------------
    // 点到直线的垂足
    // 参数: q 点
    // 返回: q 在直线上的投影点（垂足）
    // -------------------------------
    Point<T> foot(const Point<T> &q) const // 垂足
    {
        // 向量 p->q
        Point<T> u = q - p;
        // 投影系数: t = (u·v) / (v·v)
        ld t = 1.L * (u * v) / (v * v);
        return p + v * t;
    }
    // 点a关于直线bc的对称点
    Point<T> symmetry(Point<T> a) const
    {
        // 先求垂足
        Point<T> f = foot(a);
        // 对称点: f + (f - a) = 2f - a
        return f * 2 - a;
    }
};
template <class T>
struct Segment
{
    Point<T> a, b;
    // 判断点a是否在线段bc上
    //-1在端点上 0不在 1在线段中间
    int onSeg(Point<T> p) const
    {
        if (p == a || p == b)
            return -1;
        return (p - a).toleft(p - b) == 0 && (p - a) * (p - b) < -eps;
    }
    // 判断线段直线是否相交
    // -1 直线经过线段端点 | 0 线段和直线不相交 | 1 线段和直线严格相交
    int isCross1(const Line<T> &c) const
    {
        if (c.toleft(a) == 0 || c.toleft(b) == 0)
        {
            return -1;
        }
        return c.toleft(a) != c.toleft(b);
    }
    Point<T> inter1(const Line<T> &c) const // 需要保证有交
    {
        if (c.toleft(a) == 0)
        {
            return a;
        }
        if (c.toleft(b) == 0)
        {
            return b;
        }
        ld cur = 1.L * (c.v % (c.p - a)) / (c.v % (b - a));
        return a + cur * (b - a);
    }
    // 判断两线段是否相交
    // -1 在某一线段端点处相交 | 0 两线段不相交 | 1 两线段严格相交
    int isCross2(const Segment &s) const
    {
        if (onSeg(s.a) || onSeg(s.b) || s.onSeg(a) || s.onSeg(b))
        {
            return -1;
        }
        Line<T> l{a, b - a}, ls{s.a, s.b - s.a};
        return l.toleft(s.a) * l.toleft(s.b) == -1 && ls.toleft(a) * ls.toleft(b) == -1;
    }
    Point<T> inter2(const Segment &s) const // 需要保证有交
    {
        if (onSeg(s.a))
        {
            return s.a;
        }
        if (onSeg(s.b))
        {
            return s.b;
        }
        if (s.onSeg(a))
        {
            return a;
        }
        if (s.onSeg(b))
        {
            return b;
        }
        Point<T> u = b - a;     // 向量 AB
        Point<T> v = s.b - s.a; // 向量 CD
        Point<T> w = s.a - a;   // 向量 AC
        // t = (AC × v) / (u × v)
        ld t = 1.L * (w % v) / (u % v);
        return a + t * u;
    }
    // 点到线段距离
    ld dis(const Point<T> &p) const
    {
        if ((p - a) * (b - a) < -eps || (p - b) * (a - b) < -eps)
        {
            return std::min(p.dis(a), p.dis(b));
        }
        const Line<T> l{a, b - a};
        return l.dis(p);
    }
    // 两线段间最近两点的距离
    ld dis(const Segment &s) const
    {
        if (isCross2(s))
        {
            return 0;
        }
        return std::min({dis(s.a), dis(s.b), s.dis(a), s.dis(b)});
    }
};
template <class T>
struct Polygon
{
    std::vector<Point<T>> p;
    int nxt(int t) const
    {
        return t == p.size() - 1 ? 0 : t + 1;
    }
    int pre(int t) const
    {
        return t == 0 ? p.size() - 1 : t - 1;
    }
    std::pair<bool, int> winding(const Point<T> &a) const
    {
        int cnt = 0;
        for (int i = 0; i < p.size(); i++)
        {
            const Point<T> u = p[i], v = p[nxt(i)];
            if (fabs((a - u) % (a - v)) <= eps && (a - u) * (a - v) <= eps)
                return {true, 0};
            if (fabs(u.y - v.y) <= eps)
                continue;
            const Line<T> uv = {u, v - u};
            if (u.y < v.y - eps && uv.toleft(a) <= 0)
                continue;
            if (u.y > v.y + eps && uv.toleft(a) >= 0)
                continue;
            if (u.y < a.y - eps && v.y >= a.y - eps)
                cnt++;
            if (u.y >= a.y - eps && v.y < a.y - eps)
                cnt--;
        }
        return {false, cnt};
    }

    // 0表示在上面  -1表示在外面 1表示在里面
    int operator()(const Point<T> &a) const // 点是否在多边形内 回转数法
    {
        auto [onEdge, cnt] = winding(a);
        if (onEdge)
            return 0;
        return (cnt != 0 ? 1 : -1);
    }
    // 多边形面积的两倍
    // 可用于判断点的存储顺序是顺时针或逆时针
    T area() const
    {
        T sum = 0;
        for (int i = 0; i < p.size(); i++)
            sum += p[i] % p[nxt(i)];
        return sum;
    }
    // 多边形的周长
    ld circ() const
    {
        ld sum = 0;
        for (int i = 0; i < p.size(); i++)
            sum += p[i].dis(p[nxt(i)]);
        return sum;
    }
};

template <class T>
struct Convex
{
    std::vector<Point<T>> p;
    int size() const
    {
        return p.size();
    }
    int nxt(int t) const
    {
        return t == p.size() - 1 ? 0 : t + 1;
    }
    int pre(int t) const
    {
        return t == 0 ? p.size() - 1 : t - 1;
    }
    Convex operator+(const Convex &c) const
    {
        const auto &p = this->p;
        std::vector<Segment<T>> e1(p.size()), e2(c.p.size()), edge(p.size() + c.p.size());
        std::vector<Point<T>> res;
        res.reserve(p.size() + c.p.size());
        const auto cmp = [](const Segment<T> &u, const Segment<T> &v)
        { return argcmp<T>()(u.b - u.a, v.b - v.a); };
        for (int i = 0; i < p.size(); i++)
            e1[i] = {p[i], p[this->nxt(i)]};
        for (int i = 0; i < c.p.size(); i++)
            e2[i] = {c.p[i], c.p[c.nxt(i)]};
        std::rotate(e1.begin(), std::min_element(e1.begin(), e1.end(), cmp), e1.end());
        std::rotate(e2.begin(), std::min_element(e2.begin(), e2.end(), cmp), e2.end());
        std::merge(e1.begin(), e1.end(), e2.begin(), e2.end(), edge.begin(), cmp);
        const auto check = [](const std::vector<Point<T>> &res, const Point<T> &u)
        {
            const auto b1 = res.back(), b2 = *std::prev(res.end(), 2);
            return (b1 - b2).toleft(u - b1) == 0 && (b1 - b2) * (u - b1) >= -eps;
        };
        auto u = e1[0].a + e2[0].a;
        for (const auto &v : edge)
        {
            while (res.size() > 1 && check(res, u))
                res.pop_back();
            res.push_back(u);
            u = u + v.b - v.a;
        }
        if (res.size() > 1 && check(res, res[0]))
            res.pop_back();
        return {res};
    }
    // 旋转卡壳
    // func 为更新答案的函数，可以根据题目调整位置
    template <typename F>
    void rotcaliper(const F &func) const
    {
        const auto &p = this->p;
        const auto area = [](const Point<T> &u, const Point<T> &v, const Point<T> &w)
        { return (w - u) % (w - v); };
        for (int i = 0, j = 1; i < p.size(); i++)
        {
            const auto nxti = this->nxt(i);
            func(p[i], p[nxti], p[j]);
            while (area(p[this->nxt(j)], p[i], p[nxti]) >= area(p[j], p[i], p[nxti]))
            {
                j = this->nxt(j);
                func(p[i], p[nxti], p[j]);
            }
        }
    }

    // 凸多边形的直径的平方
    T diameter2() const
    {
        const auto &p = this->p;
        if (p.size() == 1)
            return 0;
        if (p.size() == 2)
            return p[0].dis2(p[1]);
        T ans = 0;
        auto func = [&](const Point<T> &u, const Point<T> &v, const Point<T> &w)
        {
            ans = std::max({ans, w.dis2(u), w.dis2(v)});
        };
        rotcaliper(func);
        return ans;
    }
    // 判断点是否在凸多边形内
    // 复杂度 O(logn)
    // -1 点在多边形边上 | 0 点在多边形外 | 1 点在多边形内
    int operator()(const Point<T> &a) const
    {
        const auto &p = this->p;
        if (p.size() == 1)
            return a == p[0] ? -1 : 0;
        if (p.size() == 2)
            return Segment<T>{p[0], p[1]}.onSeg(a) ? -1 : 0;
        if (a == p[0])
            return -1;
        if ((p[1] - p[0]).toleft(a - p[0]) == -1 || (p.back() - p[0]).toleft(a - p[0]) == 1)
            return 0;
        const auto cmp = [&](const Point<T> &u, const Point<T> &v)
        { return (u - p[0]).toleft(v - p[0]) == 1; };
        const int i = std::lower_bound(p.begin() + 1, p.end(), a, cmp) - p.begin();
        if (i == 1)
            return Segment<T>{p[0], p[i]}.onSeg(a) ? -1 : 0;
        if (i == p.size() - 1 && Segment<T>{p[0], p[i]}.onSeg(a))
            return -1;
        if (Segment<T>{p[i - 1], p[i]}.onSeg(a))
            return -1;
        return (p[i] - p[i - 1]).toleft(a - p[i - 1]) > 0;
    }

    // 凸多边形关于某一方向的极点
    // 复杂度 O(logn)
    // 参考资料：https://codeforces.com/blog/entry/48868
    template <typename F>
    int extreme(const F &dir) const
    {
        const auto &p = this->p;
        const auto check = [&](const int i)
        { return dir(p[i]).toleft(p[this->nxt(i)] - p[i]) >= 0; };
        const auto dir0 = dir(p[0]);
        const auto check0 = check(0);
        if (!check0 && check(p.size() - 1))
            return 0;
        const auto cmp = [&](const Point<T> &v)
        {
            const int vi = &v - p.data();
            if (vi == 0)
                return 1;
            const auto checkv = check(vi);
            const auto t = dir0.toleft(v - p[0]);
            if (vi == 1 && checkv == check0 && t == 0)
                return 1;
            return checkv % (checkv == check0 && t <= 0);
        };
        return std::partition_point(p.begin(), p.end(), cmp) - p.begin();
    }

    // 过凸多边形外一点求凸多边形的切线，返回切点下标
    // 复杂度 O(logn)
    // 必须保证点在多边形外
    std::pair<int, int> tangent(const Point<T> &a) const
    {
        const int i = extreme([&](const Point<T> &u)
                              { return u - a; });
        const int j = extreme([&](const Point<T> &u)
                              { return a - u; });
        return {i, j};
    }

    // 求平行于给定直线的凸多边形的切线，返回切点下标
    // 复杂度 O(logn)
    std::pair<int, int> tangent(const Line<T> &a) const
    {
        const int i = extreme([&](...)
                              { return a.v; });
        const int j = extreme([&](...)
                              { return -a.v; });
        return {i, j};
    }
};
// 点集的凸包
// Andrew 算法，复杂度 O(nlogn)
template <class T>
std::vector<Point<T>> convexhull(std::vector<Point<T>> p)
{
    std::vector<Point<T>> st;
    if (p.empty())
    {
        return std::vector<Point<T>>{};
    }
    std::sort(p.begin(), p.end());
    const auto check = [](const std::vector<Point<T>> &st, const Point<T> &u)
    {
        const auto b1 = st.back(), b2 = *prev(st.end(), 2);
        return (b1 - b2).toleft(u - b1) <= 0;
    };
    for (const auto &u : p)
    {
        while (st.size() > 1 && check(st, u))
            st.pop_back();
        st.push_back(u);
    }
    int k = st.size();
    p.pop_back();
    std::reverse(p.begin(), p.end());
    for (const auto &u : p)
    {
        while (st.size() > k && check(st, u))
            st.pop_back();
        st.push_back(u);
    }
    st.pop_back();
    return st;
}
template <class T>
struct Circle
{
    Point<T> c;
    T r;
    bool operator==(const Circle &a) const { return c == a.c && fabs(r - a.r) <= eps; }
    ld circ() const { return 2 * pi * r; } // 周长
    ld area() const { return pi * r * r; } // 面积

    // 点与圆的关系
    // -1 圆上 | 0 圆外 | 1 圆内
    int is_in(const Point<T> &p) const
    {
        const ld d = p.dis(c);
        return fabs(d - r) <= eps ? -1 : d < r - eps;
    }
    // 直线与圆关系
    // 0 相离 | 1 相切 | 2 相交
    int relation(const Line<T> &l) const
    {
        const ld d = l.dis(c);
        if (d > r + eps)
            return 0;
        if (fabs(d - r) <= eps)
            return 1;
        return 2;
    }
    // 圆与圆关系
    // -1 相同 | 0 相离 | 1 外切 | 2 相交 | 3 内切 | 4 内含
    int relation(const Circle<T> &a) const
    {
        if (*this == a)
            return -1;
        const ld d = c.dis(a.c);
        if (d > r + a.r + eps)
            return 0;
        if (fabs(d - r - a.r) <= eps)
            return 1;
        if (fabs(d - fabs(r - a.r)) <= eps)
            return 3;
        if (d < fabs(r - a.r) - eps)
            return 4;
        return 2;
    }

    // 直线与圆的交点
    std::vector<Point<T>> inter(const Line<T> &l) const
    {
        const ld d = l.dis(c);
        const Point<T> p = l.foot(c);
        const int t = relation(l);
        if (t == 0)
            return std::vector<Point<T>>();
        if (t == 1)
            return std::vector<Point<T>>{p};
        const ld k = sqrtl(r * r - d * d);
        return std::vector<Point<T>>{p - (l.v / l.v.len()) * k, p + (l.v / l.v.len()) * k};
    }
    // 圆与圆交点
    std::vector<Point<T>> inter(const Circle &a) const
    {
        const ld d = c.dis(a.c);
        const int t = relation(a);
        if (t == -1 || t == 0 || t == 4)
            return std::vector<Point<T>>();
        Point<T> e = a.c - c;
        e = e / e.len() * r;
        if (t == 1 || t == 3)
        {
            if (r * r + d * d - a.r * a.r >= -eps)
                return std::vector<Point<T>>{c + e};
            return std::vector<Point<T>>{c - e};
        }
        const ld costh = (r * r + d * d - a.r * a.r) / (2 * r * d), sinth = sqrtl(1 - std::min(1.l, costh * costh));
        return std::vector<Point<T>>{c + e.rotate(costh, -sinth), c + e.rotate(costh, sinth)};
    }
    // 圆与圆交面积
    ld inter_area(const Circle &a) const
    {
        const ld d = c.dis(a.c);
        const int t = relation(a);
        if (t == -1)
            return area();
        if (t < 2)
            return 0;
        if (t > 2)
            return std::min(area(), a.area());
        const ld costh1 = (r * r + d * d - a.r * a.r) / (2 * r * d), costh2 = (a.r * a.r + d * d - r * r) / (2 * a.r * d);
        const ld sinth1 = sqrtl(1 - std::min(costh1 * costh1, 1.l)), sinth2 = sqrtl(1 - std::min(costh2 * costh2, 1.l));
        const ld th1 = acosl(costh1), th2 = acosl(costh2);
        return r * r * (th1 - costh1 * sinth1) + a.r * a.r * (th2 - costh2 * sinth2);
    }
    // 过圆外一点圆的切线
    std::vector<Line<T>> tangent(const Point<T> &a) const
    {
        const int t = is_in(a);
        if (t == 1)
            return std::vector<Line<T>>();
        if (t == -1)
        {
            const Point<T> v = {-(a - c).y, (a - c).x};
            return std::vector<Line<T>>{{a, v}};
        }
        Point<T> e = a - c;
        e = e / e.len() * r;
        const long double costh = r / c.dis(a), sinth = sqrtl(1 - std::min(costh * costh, 1.l));
        const Point<T> t1 = c + e.rotate(costh, -sinth), t2 = c + e.rotate(costh, sinth);
        return std::vector<Line<T>>{{a, t1 - a}, {a, t2 - a}};
    }
    // 两圆的公切线
    std::vector<Line<T>> tangent(const Circle &a) const
    {
        const int t = relation(a);
        std::vector<Line<T>> lines;
        if (t == -1 || t == 4)
            return lines;
        if (t == 1 || t == 3)
        {
            const Point<T> p = inter(a)[0], v = {-(a.c - c).y, (a.c - c).x};
            lines.push_back({p, v});
        }
        const ld d = c.dis(a.c);
        const Point<T> e = (a.c - c) / (a.c - c).len();
        if (t <= 2)
        {
            const ld costh = (r - a.r) / d, sinth = sqrtl(1 - std::min(costh * costh, 1.l));
            const Point<T> d1 = e.rotate(costh, -sinth), d2 = e.rotate(costh, sinth);
            const Point<T> u1 = c + d1 * r, u2 = c + d2 * r, v1 = a.c + d1 * a.r, v2 = a.c + d2 * a.r;
            lines.push_back({u1, v1 - u1});
            lines.push_back({u2, v2 - u2});
        }
        if (t == 0)
        {
            const ld costh = (r + a.r) / d, sinth = sqrtl(1 - std::min(costh * costh, 1.l));
            const Point<T> d1 = e.rotate(costh, -sinth), d2 = e.rotate(costh, sinth);
            const Point<T> u1 = c + d1 * r, u2 = c + d2 * r, v1 = a.c - d1 * a.r, v2 = a.c - d2 * a.r;
            lines.push_back({u1, v1 - u1});
            lines.push_back({u2, v2 - u2});
        }
        return lines;
    }
    // 直线的圆反演
    std::tuple<int, Circle, Line<T>> inverse(const Line<T> &l) const
    {
        const Circle null_c = {{0.0, 0.0}, 0.0};
        const Line<T> null_l = {{0.0, 0.0}, {0.0, 0.0}};
        if (l.toleft(c) == 0)
            return {2, null_c, l};
        const Point<T> v = l.toleft(c) == 1 ? Point<T>{l.v.y, -l.v.x} : Point<T>{-l.v.y, l.v.x};
        const ld d = r * r / l.dis(c);
        const Point<T> p = c + v / v.len() * d;
        return {1, {(c + p) / 2, d / 2}, null_l};
    }
    // 圆的圆反演
    std::tuple<int, Circle, Line<T>> inverse(const Circle &a) const
    {
        const Circle null_c = {{0.0, 0.0}, 0.0};
        const Line<T> null_l = {{0.0, 0.0}, {0.0, 0.0}};
        const Point<T> v = a.c - c;
        if (a.is_in(c) == -1)
        {
            const ld d = r * r / (a.r + a.r);
            const Point<T> p = c + v / v.len() * d;
            return {2, null_c, {p, {-v.y, v.x}}};
        }
        if (c == a.c)
            return {1, {c, r * r / a.r}, null_l};
        const ld d1 = r * r / (c.dis(a.c) - a.r), d2 = r * r / (c.dis(a.c) + a.r);
        const Point<T> p = c + v / v.len() * d1, q = c + v / v.len() * d2;
        return {1, {(p + q) / 2, p.dis(q) / 2}, null_l};
    }
};

// 圆与多边形面积交
template <class T>
ld area(const Circle<T> &circ, const Polygon<T> &poly)
{
    const auto cal = [](const Circle<T> &circ, const Point<T> &a, const Point<T> &b)
    {
        if ((a - circ.c).toleft(b - circ.c) == 0)
            return 0.0l;
        const auto ina = circ.is_in(a), inb = circ.is_in(b);
        const Line<T> ab = {a, b - a};
        if (ina && inb)
            return ((a - circ.c) % (b - circ.c)) / 2;
        if (ina && !inb)
        {
            const auto t = circ.inter(ab);
            const Point<T> p = t.size() == 1 ? t[0] : t[1];
            const ld ans = ((a - circ.c) % (p - circ.c)) / 2;
            const ld th = (p - circ.c).ang(b - circ.c);
            const ld d = circ.r * circ.r * th / 2;
            if ((a - circ.c).toleft(b - circ.c) == 1)
                return ans + d;
            return ans - d;
        }
        if (!ina && inb)
        {
            const Point p = circ.inter(ab)[0];
            const ld ans = ((p - circ.c) % (b - circ.c)) / 2;
            const ld th = (a - circ.c).ang(p - circ.c);
            const ld d = circ.r * circ.r * th / 2;
            if ((a - circ.c).toleft(b - circ.c) == 1)
                return ans + d;
            return ans - d;
        }
        const auto p = circ.inter(ab);
        if (p.size() == 2 && Segment<T>{a, b}.dis(circ.c) <= circ.r + eps)
        {
            const ld ans = ((p[0] - circ.c) % (p[1] - circ.c)) / 2;
            const ld th1 = (a - circ.c).ang(p[0] - circ.c), th2 = (b - circ.c).ang(p[1] - circ.c);
            const ld d1 = circ.r * circ.r * th1 / 2, d2 = circ.r * circ.r * th2 / 2;
            if ((a - circ.c).toleft(b - circ.c) == 1)
                return ans + d1 + d2;
            return ans - d1 - d2;
        }
        const ld th = (a - circ.c).ang(b - circ.c);
        if ((a - circ.c).toleft(b - circ.c) == 1)
            return circ.r * circ.r * th / 2;
        return -circ.r * circ.r * th / 2;
    };

    ld ans = 0;
    for (int i = 0; i < poly.p.size(); i++)
    {
        const Point<T> a = poly.p[i], b = poly.p[poly.nxt(i)];
        ans += cal(circ, a, b);
    }
    return ans;
}

// 多边形面积并
// 轮廓积分，复杂度 O(n^2logn)，n为边数
// ans[i] 表示被至少覆盖了 i+1 次的区域的面积
template <class T>
std::vector<ld> area(const std::vector<Polygon<T>> &polys)
{
    const int siz = polys.size();
    std::vector<std::vector<std::pair<Point<T>, Point<T>>>> segs(siz);
    const auto check = [](const Point<T> &u, const Segment<T> &e)
    { return !((u < e.a && u < e.b) || (u > e.a && u > e.b)); };

    auto cut_edge = [&](const Segment<T> &e, const int i)
    {
        const Line<T> le{e.a, e.b - e.a};
        std::vector<std::pair<Point<T>, int>> evt;
        evt.push_back({e.a, 0});
        evt.push_back({e.b, 0});
        for (int j = 0; j < polys.size(); j++)
        {
            if (i == j)
                continue;
            const auto &pj = polys[j];
            for (int k = 0; k < pj.p.size(); k++)
            {
                const Segment<T> s = {pj.p[k], pj.p[pj.nxt(k)]};
                if (le.toleft(s.a) == 0 && le.toleft(s.b) == 0)
                {
                    evt.push_back({s.a, 0});
                    evt.push_back({s.b, 0});
                }
                else if (s.isCross1(le))
                {
                    const Line<T> ls{s.a, s.b - s.a};
                    const Point<T> u = le.inter(ls);
                    if (le.toleft(s.a) < 0 && le.toleft(s.b) >= 0)
                        evt.push_back({u, -1});
                    else if (le.toleft(s.a) >= 0 && le.toleft(s.b) < 0)
                        evt.push_back({u, 1});
                }
            }
        }
        std::sort(evt.begin(), evt.end());
        if (e.a > e.b)
            std::reverse(evt.begin(), evt.end());
        int sum = 0;
        for (int i = 0; i < evt.size(); i++)
        {
            sum += evt[i].second;
            const Point<T> u = evt[i].first, v = evt[i + 1].first;
            if (!(u == v) && check(u, e) && check(v, e))
                segs[sum].push_back({u, v});
            if (v == e.b)
                break;
        }
    };

    for (int i = 0; i < polys.size(); i++)
    {
        const auto &pi = polys[i];
        for (int k = 0; k < pi.p.size(); k++)
        {
            const Segment<T> ei = {pi.p[k], pi.p[pi.nxt(k)]};
            cut_edge(ei, i);
        }
    }
    std::vector<ld> ans(siz);
    for (int i = 0; i < siz; i++)
    {
        ld sum = 0;
        std::sort(segs[i].begin(), segs[i].end());
        for (int j = 0; j < segs[i].size();)
        {
            int k = j;
            while (k < segs[i].size() && segs[i][k] == segs[i][j])
            {
                k++;
            }
            int count = k - j;
            sum += segs[i][j].first % segs[i][j].second;
            // 将多余的 count-1 个线段传递到下一层
            if (i + 1 < siz && count > 1)
            {
                for (int l = 0; l < count - 1; ++l)
                {
                    segs[i + 1].push_back(segs[i][j]);
                }
            }
            j = k;
        }
        ans[i] = sum / 2;
    }
    return ans;
}

// 圆面积并
// 轮廓积分，复杂度 O(n^2logn)
// ans[i] 表示被至少覆盖了 i+1 次的区域的面积
template <class T>
std::vector<ld> area(const std::vector<Circle<T>> &circs)
{
    const int siz = circs.size();
    using arc_t = std::tuple<Point<T>, ld, ld, ld>;
    std::vector<std::vector<arc_t>> arcs(siz);
    const auto eq = [](const arc_t &u, const arc_t &v)
    {
        const auto [u1, u2, u3, u4] = u;
        const auto [v1, v2, v3, v4] = v;
        return u1 == v1 && fabs(u2 - v2) <= eps && fabs(u3 - v3) <= eps && fabs(u4 - v4) <= eps;
    };

    auto cut_circ = [&](const Circle<T> &ci, const int i)
    {
        std::vector<std::pair<ld, int>> evt;
        evt.push_back({-pi, 0});
        evt.push_back({pi, 0});
        int init = 0;
        for (int j = 0; j < circs.size(); j++)
        {
            if (i == j)
                continue;
            const Circle<T> &cj = circs[j];
            if (ci.r < cj.r - eps && ci.relation(cj) >= 3)
                init++;
            const auto inters = ci.inter(cj);
            if (inters.size() == 1)
                evt.push_back({atan2l((inters[0] - ci.c).y, (inters[0] - ci.c).x), 0});
            if (inters.size() == 2)
            {
                const Point<T> dl = inters[0] - ci.c, dr = inters[1] - ci.c;
                long double argl = atan2l(dl.y, dl.x), argr = atan2l(dr.y, dr.x);
                if (fabs(argl + pi) <= eps)
                    argl = pi;
                if (fabs(argr + pi) <= eps)
                    argr = pi;
                if (argl > argr + eps)
                {
                    evt.push_back({argl, 1});
                    evt.push_back({pi, -1});
                    evt.push_back({-pi, 1});
                    evt.push_back({argr, -1});
                }
                else
                {
                    evt.push_back({argl, 1});
                    evt.push_back({argr, -1});
                }
            }
        }
        std::sort(evt.begin(), evt.end());
        int sum = init;
        for (int i = 0; i < evt.size(); i++)
        {
            sum += evt[i].second;
            if (fabs(evt[i].first - evt[i + 1].first) > eps)
                arcs[sum].push_back({ci.c, ci.r, evt[i].first, evt[i + 1].first});
            if (fabs(evt[i + 1].first - pi) <= eps)
                break;
        }
    };

    const auto oint = [](const arc_t &arc)
    {
        const auto [cc, cr, l, r] = arc;
        if (fabs(r - l - pi - pi) <= eps)
            return 2.0l * pi * cr * cr;
        return cr * cr * (r - l) + cc.x * cr * (sinl(r) - sinl(l)) - cc.y * cr * (cosl(r) - cosl(l));
    };

    for (int i = 0; i < circs.size(); i++)
    {
        const auto &ci = circs[i];
        cut_circ(ci, i);
    }
    std::vector<ld> ans(siz);
    for (int i = 0; i < siz; i++)
    {
        ld sum = 0;
        std::sort(arcs[i].begin(), arcs[i].end());
        for (int j = 0; j < arcs[i].size();)
        {
            int k = j;
            while (k < arcs[i].size() && eq(arcs[i][k], arcs[i][j]))
            {
                k++;
            }
            int count = k - j;
            sum += oint(arcs[i][j]);

            // 将多余的 count-1 个圆弧传递到下一层
            if (i + 1 < siz && count > 1)
            {
                for (int l = 0; l < count - 1; ++l)
                {
                    arcs[i + 1].push_back(arcs[i][j]);
                }
            }
            j = k;
        }
        ans[i] = sum / 2;
    }
    return ans;
}

// 半平面交
// 排序增量法，复杂度 O(nlogn)
// 输入与返回值都是用直线表示的半平面集合

// 有向线段的左边作为合法的半平面
template <class T>
std::vector<Line<T>> halfinter(std::vector<Line<T>> l, const ld lim = 1e18)
{
    const auto check = [](const Line<T> &a, const Line<T> &b, const Line<T> &c)
    { return a.toleft(b.inter(c)) < 0; };
    // // 无精度误差的方法，但注意取值范围会扩大到三次方
    // const auto check = [](const Line<T> &a, const Line<T> &b, const Line<T> &c)
    // {
    //     const Point<T> p = a.v * (b.v % c.v), q = b.p * (b.v % c.v) + b.v * (c.v % (b.p - c.p)) - a.p * (b.v % c.v);
    //     return p.toleft(q) < 0;
    // };
    l.push_back({{-lim, 0}, {0, -1}});
    l.push_back({{0, -lim}, {1, 0}});
    l.push_back({{lim, 0}, {0, 1}});
    l.push_back({{0, lim}, {-1, 0}});
    std::sort(l.begin(), l.end());
    std::deque<Line<T>> q;
    for (int i = 0; i < l.size(); i++)
    {
        if (i > 0 && l[i - 1].v.toleft(l[i].v) == 0 && l[i - 1].v * l[i].v > eps)
            continue;
        while (q.size() > 1 && check(l[i], q.back(), q[q.size() - 2]))
            q.pop_back();
        while (q.size() > 1 && check(l[i], q[0], q[1]))
            q.pop_front();
        if (!q.empty() && q.back().v.toleft(l[i].v) <= 0)
            return std::vector<Line<T>>();
        q.push_back(l[i]);
    }
    while (q.size() > 1 && check(q[0], q.back(), q[q.size() - 2]))
        q.pop_back();
    while (q.size() > 1 && check(q.back(), q[0], q[1]))
        q.pop_front();
    return std::vector<Line<T>>(q.begin(), q.end());
}

// 点集形成的最小最大三角形
// 极角序扫描线，复杂度 O(n%2logn)
// 最大三角形问题可以使用凸包与旋转卡壳做到 O(n%2)
template <class T>
std::pair<ld, ld> minmax_triangle(const std::vector<Point<T>> &vec)
{
    if (vec.size() <= 2)
        return {0, 0};
    std::vector<std::pair<int, int>> evt;
    evt.reserve(vec.size() * vec.size());
    ld maxans = 0, minans = std::numeric_limits<ld>::max();
    for (int i = 0; i < vec.size(); i++)
    {
        for (int j = 0; j < vec.size(); j++)
        {
            if (i == j)
                continue;
            if (vec[i] == vec[j])
                minans = 0;
            else
                evt.push_back({i, j});
        }
    }
    std::sort(evt.begin(), evt.end(), [&](const std::pair<int, int> &u, const std::pair<int, int> &v)
              {
        const Point du=vec[u.second]-vec[u.first],dv=vec[v.second]-vec[v.first];
        return argcmp<T>()({du.y,-du.x},{dv.y,-dv.x}); });
    std::vector<int> vx(vec.size()), pos(vec.size());
    for (int i = 0; i < vec.size(); i++)
        vx[i] = i;
    std::sort(vx.begin(), vx.end(), [&](int x, int y)
              { return vec[x] < vec[y]; });
    for (int i = 0; i < vx.size(); i++)
        pos[vx[i]] = i;
    for (auto [u, v] : evt)
    {
        const int i = pos[u], j = pos[v];
        const int l = std::min(i, j), r = std::max(i, j);
        const Point vecu = vec[u], vecv = vec[v];
        if (l > 0)
            minans = std::min(minans, fabs((vec[vx[l - 1]] - vecu) % (vec[vx[l - 1]] - vecv)));
        if (r < vx.size() - 1)
            minans = std::min(minans, fabs((vec[vx[r + 1]] - vecu) % (vec[vx[r + 1]] - vecv)));
        maxans = std::max({maxans, fabs((vec[vx[0]] - vecu) % (vec[vx[0]] - vecv)), fabs((vec[vx.back()] - vecu) % (vec[vx.back()] - vecv))});
        if (i < j)
            std::swap(vx[i], vx[j]), pos[u] = j, pos[v] = i;
    }
    return {minans, maxans};
}

// 判断多条线段是否两两之间没有交点？
// 只要有任意一个交点 返回true 否则返回false(即两两都没有交)
// 扫描线，复杂度 O(nlogn)

// 可能存在精度问题 下面有更稳定的迭代器版本
template <class T>
bool inter(const std::vector<Segment<T>> &segs)
{
    if (segs.empty())
        return false;
    using seq_t = std::tuple<ld, int, Segment<T>>;
    const auto seqcmp = [](const seq_t &u, const seq_t &v)
    {
        const auto [u0, u1, u2] = u;
        const auto [v0, v1, v2] = v;
        if (fabs(u0 - v0) <= eps)
            return std::make_pair(u1, u2) < std::make_pair(v1, v2);
        return u0 < v0 - eps;
    };
    std::vector<seq_t> seq;
    for (auto seg : segs)
    {
        if (seg.a.x > seg.b.x + eps)
            std::swap(seg.a, seg.b);
        seq.push_back({seg.a.x, 0, seg});
        seq.push_back({seg.b.x, 1, seg});
    }
    std::sort(seq.begin(), seq.end(), seqcmp);
    ld x_now;
    auto cmp = [&](const Segment<T> &u, const Segment<T> &v)
    {
        if (fabs(u.a.x - u.b.x) <= eps || fabs(v.a.x - v.b.x) <= eps)
            return u.a.y < v.a.y - eps;
        return ((x_now - u.a.x) * (u.b.y - u.a.y) + u.a.y * (u.b.x - u.a.x)) * (v.b.x - v.a.x) < ((x_now - v.a.x) * (v.b.y - v.a.y) + v.a.y * (v.b.x - v.a.x)) * (u.b.x - u.a.x) - eps;
    };
    std::multiset<Segment<T>, decltype(cmp)> s{cmp};
    for (const auto [x, o, seg] : seq)
    {
        x_now = x;
        const auto it = s.lower_bound(seg);
        if (o == 0)
        {
            if (it != s.end() && seg.isCross2(*it))
                return true;
            if (it != s.begin() && seg.isCross2(*std::prev(it)))
                return true;
            s.insert(seg);
        }
        else
        {
            if (std::next(it) != s.end() && it != s.begin() && (*std::prev(it)).isCross2(*std::next(it)))
                return true;
            s.erase(it);
        }
    }
    return false;
}
// // 判断多条线段是否两两之间存在交点（Lambda Map 最终版）
// template <class T>
// bool inter(const std::vector<Segment<T>> &segs)
// {
//     if (segs.empty())
//         return false;
//     using seq_t = std::tuple<ld, int, Segment<T>>;

//     // 1. 事件点创建和排序 (不变)
//     std::vector<seq_t> seq;
//     for (auto seg : segs)
//     {
//         if (seg.a.x > seg.b.x + eps)
//             std::swap(seg.a, seg.b);
//         seq.push_back({seg.a.x, 0, seg});
//         seq.push_back({seg.b.x, 1, seg});
//     }
//     std::sort(seq.begin(), seq.end(), [](const seq_t &u, const seq_t &v)
//               {
//         if (fabs(std::get<0>(u) - std::get<0>(v)) <= eps)
//             return std::get<1>(u) < std::get<1>(v);
//         return std::get<0>(u) < std::get<0>(v) - eps; });

//     ld x_now;
//     // 2. multiset 的比较器 (不变)
//     auto cmp = [&](const Segment<T> &u, const Segment<T> &v)
//     {
//         if (fabs(u.a.x - u.b.x) <= eps || fabs(v.a.x - v.b.x) <= eps)
//             return u.a.y < v.a.y - eps;
//         return ((x_now - u.a.x) * (u.b.y - u.a.y) + u.a.y * (u.b.x - u.a.x)) * (v.b.x - v.a.x) < ((x_now - v.a.x) * (v.b.y - v.a.y) + v.a.y * (v.b.x - v.a.x)) * (u.b.x - u.a.x) - eps;
//     };
//     std::multiset<Segment<T>, decltype(cmp)> s{cmp};

//     auto C = [](const Segment<T> &l, const Segment<T> &r)
//     {
//         // 使用 std::tie 提供一个稳定的、唯一的排序规则
//         return std::tie(l.a.x, l.a.y, l.b.x, l.b.y) <
//                std::tie(r.a.x, r.a.y, r.b.x, r.b.y);
//     };

//     // 【改动 2】: 声明 map 时，将 lambda 的类型作为模板参数，
//     //             并将 lambda 对象本身作为构造函数参数
//     using m_iter = typename std::multiset<Segment<T>, decltype(cmp)>::iterator;
//     std::map<Segment<T>, m_iter, decltype(C)> seg_iters(C);

//     // ^^^^^^^^^^^^^^^^ 【核心修改在这里】 ^^^^^^^^^^^^^^^^

//     for (const auto &[x, o, seg] : seq)
//     {
//         x_now = x;
//         if (o == 0) // 处理左端点
//         {
//             auto it = s.insert(seg);
//             seg_iters[seg] = it; // map 现在可以正常工作

//             if (it != s.begin() && seg.isCross2(*std::prev(it)))
//                 return true;
//             if (std::next(it) != s.end() && seg.isCross2(*std::next(it)))
//                 return true;
//         }
//         else // 处理右端点
//         {
//             auto it = seg_iters.find(seg)->second; // 精确查找

//             auto prev_it = (it == s.begin()) ? s.end() : std::prev(it);
//             auto next_it = std::next(it);

//             if (prev_it != s.end() && next_it != s.end() && (*prev_it).isCross2(*next_it))
//             {
//                 return true;
//             }
//             s.erase(it); // 精确删除
//             seg_iters.erase(seg);
//         }
//     }
//     return false;
// }
// 推荐的 inCircle 实现 大整数实现
// 返回值:
// > 0: d在圆外
// < 0: d在圆内
// = 0: d在圆上
__int128 det(__int128 a, __int128 b, __int128 c,
             __int128 d, __int128 e, __int128 f,
             __int128 g, __int128 h, __int128 i)
{
    return a * (e * i - f * h) - b * (d * i - f * g) + c * (d * h - e * g);
}
template <class T>
int inCircle(Point<T> a, Point<T> b, Point<T> c, Point<T> d)
{
    // 平移 d 到原点，减少数值大小
    a = a - d;
    b = b - d;
    c = c - d;
    auto val = det(
        a.x, a.y, dis2(a),
        b.x, b.y, dis2(b),
        c.x, c.y, dis2(c));

    // 计算 a,b,c 的方向
    ll orient = (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);
    if (orient < 0)
        val = -val; // 若顺时针则反转符号

    return (val > 0) - (val < 0); // 统一返回 -1/0/1
}

```

### 自适应辛普森法
 自适应辛普森法的用途主要是高精度数值积分，即计算积分值。

```cpp
using ld = long double;

// ===================== 非递归自适应辛普森法 =====================
// F: 被积函数类型
// a, b: 积分区间
// eps: 精度要求（可选）
template <typename F>
ld adaptiveSimpsonIter(F f, ld a, ld b, ld eps = 1e-12)
{
    struct Node
    {
        ld l, r; // 区间 [l, r]
        ld S;    // 该区间辛普森积分
        ld eps;  // 当前误差要求
    };

    auto simpson = [&](ld l, ld r) -> ld
    {
        ld m = (l + r) / 2;
        return (r - l) / 6 * (f(l) + 4 * f(m) + f(r));
    };

    std::stack<Node> stk;
    ld result = 0;

    // 初始化区间
    stk.push({a, b, simpson(a, b), eps});

    while (!stk.empty())
    {
        Node cur = stk.top();
        stk.pop();

        ld l = cur.l, r = cur.r, S = cur.S, e = cur.eps;
        ld m = (l + r) / 2;
        ld Sleft = simpson(l, m);
        ld Sright = simpson(m, r);

        // 精度满足，累加积分
        if (std::abs(Sleft + Sright - S) <= 15 * e)
        {
            result += Sleft + Sright + (Sleft + Sright - S) / 15.0;
        }
        else
        {
            // 左右子区间继续细分，误差按比例分配
            stk.push({m, r, Sright, e / 2});
            stk.push({l, m, Sleft, e / 2});
        }
    }

    return result;
}

// ===================== 示例使用 =====================
int main()
{
    auto f = [](ld x)
    { 
        return std::sin(x); 
    };
    ld res = adaptiveSimpsonIter(f, 0, acosl(-1));
    std::cout << std::setprecision(20) << res << "\n"; // 理论值为 2
}

```

### 平面最近点对
```cpp
static inline ll sq(ll v) { return v * v; }
// 计算两点平方距离
static inline ll dist2(const Point &a, const Point &b)
{
    return sq(a.x - b.x) + sq(a.y - b.y);
}
void solve(std::vector<std::pair<int, int>> &p)
{
    int n = p.size();
    // idx: 以 x 优先、y 次之排序后的点编号（用于按 x 分治的“切分边界”）
    std::vector<int> idx(n);
    std::iota(idx.begin(), idx.end(), 0);
    std::sort(idx.begin(), idx.end(), [&](int i, int j)
              {
        if (p[i].x != p[j].x) return p[i].x < p[j].x;
        return p[i].y < p[j].y; });

    // ord: 与 idx 同一集合，但每段在递归返回时保持按 y 升序
    std::vector<int> ord = idx;
    // 分治：在 [l, r) 这段（元素集合等于 idx[l..r)），返回最小平方距离；
    // 递归结束时，保证 ord[l..r) 按 y 升序，便于父层用 inplace_merge 合并
    std::function<ll(int, int)> dc = [&](int l, int r) -> ll
    {
        int mlen = r - l;
        if (mlen <= 25)
        { // 小块直接暴力 + 就地按 y 排序
            std::sort(ord.begin() + l, ord.begin() + r, [&](int i, int j)
                      {
                if (p[i].y != p[j].y) return p[i].y < p[j].y;
                return p[i].x < p[j].x; });
            ll best = 9e18;
            for (int i = l; i < r; ++i)
                for (int j = i + 1; j < r; ++j)
                {
                    // 利用 y 排序做个小剪枝
                    ll dy = p[ord[j]].y - p[ord[i]].y;
                    if (dy * dy >= best)
                        break;
                    best = std::min(best, dist2(p[ord[i]], p[ord[j]]));
                }
            return best;
        }
        int m = (l + r) >> 1;
        // 中线 x（按 idx 的中点划分）
        ll midx = p[idx[m]].x;

        ll dl = dc(l, m);
        ll dr = dc(m, r);
        ll best = std::min(dl, dr);

        // 合并子段的“按 y 升序”到父段：用内置 inplace_merge
        std::inplace_merge(ord.begin() + l, ord.begin() + m, ord.begin() + r, [&](int i, int j)
                           {
            if (p[i].y != p[j].y) return p[i].y < p[j].y;
            return p[i].x < p[j].x; });

        // 构建条带：ord[l..r) 已按 y 升序
        std::vector<int> strip;
        strip.reserve(r - l);
        for (int k = l; k < r; ++k)
        {
            int id = ord[k];
            if (sq(p[id].x - midx) < best)
            {
                // 只需与前面最多 7~8 个候选比
                for (int t = (int)strip.size() - 1, cnt = 0; t >= 0 && cnt < 8; --t, ++cnt)
                {
                    best = std::min(best, dist2(p[id], p[strip[t]]));
                }
                strip.push_back(id);
            }
        }
        return best;
    };
    return dc(0, n);
}
```

### 最小圆覆盖和最小球覆盖
```cpp

using ll = long long;
using ld = long double;

const ld PI = acosl(-1);
const ld EPS = 1e-12;

struct Point
{
    ld x, y;
    // 向量加减
    Point operator+(const Point &o) const { return {x + o.x, y + o.y}; }
    Point operator-(const Point &o) const { return {x - o.x, y - o.y}; }
    Point operator*(ld k) const { return {x * k, y * k}; }
    Point operator/(ld k) const { return {x / k, y / k}; }
};
// 向量叉积
inline ld cross(const Point &a, const Point &b) { return a.x * b.y - a.y * b.x; }
// 向量旋转
inline Point rotate(const Point &a, ld ang)
{
    return {a.x * cosl(ang) - a.y * sinl(ang), a.x * sinl(ang) + a.y * cosl(ang)};
}
// 距离
inline ld dist(const Point &a, const Point &b)
{
    return std::hypotl(a.x - b.x, a.y - b.y);
}
struct Circle
{
    Point c; // 圆心
    ld r;    // 半径
};
// 直线交点：a + t*u 与 b + s*v
Point line_intersection(Point a, Point u, Point b, Point v)
{
    ld t = cross(b - a, v) / cross(u, v);
    return a + u * t;
}
std::pair<Point, Point> midperp(const Point &a, const Point &b)
{
    return {(a + b) / 2.0L, rotate(b - a, PI / 2)};
}
// 两点圆
Circle circle_from(const Point &a, const Point &b)
{
    return {(a + b) / 2.0L, dist(a, b) / 2.0L};
}
// 三点外接圆
Circle circle_from(const Point &a, const Point &b, const Point &c)
{
    auto u = midperp(a, b);
    auto v = midperp(a, c);
    Point o = line_intersection(u.first, u.second, v.first, v.second);
    return {o, dist(o, a)};
}
// 随机增量法
Circle work(std::vector<Point> &p)
{
    std::mt19937_64 rng((unsigned long long)(new char));
    std::shuffle(p.begin(), p.end(), rng);
    Circle C{p[0], 0};
    int n = (int)p.size();
    for (int i = 1; i < n; ++i)
    {
        if (dist(C.c, p[i]) <= C.r + EPS)
            continue;
        C = {p[i], 0};
        for (int j = 0; j < i; ++j)
        {
            if (dist(C.c, p[j]) <= C.r + EPS)
                continue;
            C = circle_from(p[i], p[j]);
            for (int k = 0; k < j; ++k)
            {
                if (dist(C.c, p[k]) <= C.r + EPS)
                    continue;
                C = circle_from(p[i], p[j], p[k]);
            }
        }
    }
    return C;
}

```

```cpp

using ll = long long;
using ld = long double;

const ld EPS = 1e-12;

struct P
{
    ld x, y, z;
    P operator+(const P &o) const { return {x + o.x, y + o.y, z + o.z}; }
    P operator-(const P &o) const { return {x - o.x, y - o.y, z - o.z}; }
    P operator*(ld k) const { return {x * k, y * k, z * k}; }
    P operator/(ld k) const { return {x / k, y / k, z / k}; }
};
inline ld dot(const P &a, const P &b)
{
    return a.x * b.x + a.y * b.y + a.z * b.z;
}
inline P cross(const P &a, const P &b)
{
    return {a.y * b.z - a.z * b.y,
            a.z * b.x - a.x * b.z,
            a.x * b.y - a.y * b.x};
}
inline ld norm2(const P &a) { return dot(a, a); }
inline ld dist(const P &a, const P &b) { return std::sqrt(norm2(a - b)); }
struct Sphere
{
    P c;
    ld r;
};
inline bool check(const Sphere &s, const P &p)
{
    return dist(s.c, p) <= s.r + EPS;
}
// 两点球
Sphere calc(const P &a, const P &b)
{
    P o = (a + b) / 2.0L;
    return {o, dist(a, b) / 2.0L};
}

// 三点球（唯一确定一个外接圆，球心在平面内）
Sphere calc(const P &a, const P &b, const P &c)
{
    P ab = b - a, ac = c - a;
    P abXac = cross(ab, ac);
    ld d = 2 * norm2(abXac);
    if (d < EPS)
    { // 三点共线
        Sphere s1 = calc(a, b);
        Sphere s2 = calc(a, c);
        Sphere s3 = calc(b, c);
        Sphere res = s1;
        if (s2.r > res.r)
            res = s2;
        if (s3.r > res.r)
            res = s3;
        return res;
    }
    P ab_mid = (a + b) / 2.0L;
    P ac_mid = (a + c) / 2.0L;
    P n = abXac;

    // 球心计算公式
    P num = cross(abXac, ab) * norm2(ac) - cross(abXac, ac) * norm2(ab);
    P o = a + num / d;
    return {o, dist(o, a)};
}

// 四点外接球
Sphere calc(const P &a, const P &b, const P &c, const P &d)
{
    ld a1 = b.x - a.x, a2 = b.y - a.y, a3 = b.z - a.z;
    ld b1 = c.x - a.x, b2 = c.y - a.y, b3 = c.z - a.z;
    ld c1 = d.x - a.x, c2 = d.y - a.y, c3 = d.z - a.z;

    ld a_len = norm2(b) - norm2(a);
    ld b_len = norm2(c) - norm2(a);
    ld c_len = norm2(d) - norm2(a);

    ld det = a1 * (b2 * c3 - b3 * c2) - a2 * (b1 * c3 - b3 * c1) + a3 * (b1 * c2 - b2 * c1);

    if (fabsl(det) < EPS)
    {
        // 退化成三点球
        Sphere s1 = calc(a, b, c);
        if (!check(s1, d))
        {
            Sphere s2 = calc(a, b, d);
            if (!check(s2, c))
            {
                Sphere s3 = calc(a, c, d);
                if (!check(s3, b))
                {
                    return calc(b, c, d);
                }
                return s3;
            }
            return s2;
        }
        return s1;
    }
    P o;
    o.x = (a_len * (b2 * c3 - b3 * c2) - b_len * (a2 * c3 - a3 * c2) + c_len * (a2 * b3 - a3 * b2)) / (2 * det);
    o.y = (a_len * (b3 * c1 - b1 * c3) - b_len * (a3 * c1 - a1 * c3) + c_len * (a3 * b1 - a1 * b3)) / (2 * det);
    o.z = (a_len * (b1 * c2 - b2 * c1) - b_len * (a1 * c2 - a2 * c1) + c_len * (a1 * b2 - a2 * b1)) / (2 * det);

    return {o, dist(o, a)};
}
// 随机增量法
Sphere work(std::vector<P> pts)
{
    std::mt19937_64 rng((unsigned long long)(new char));
    std::shuffle(pts.begin(), pts.end(), rng);
    Sphere s{pts[0], 0};
    int n = pts.size();
    for (int i = 1; i < n; ++i)
    {
        if (check(s, pts[i]))
            continue;
        s = {pts[i], 0};
        for (int j = 0; j < i; ++j)
        {
            if (check(s, pts[j]))
                continue;
            s = calc(pts[i], pts[j]);
            for (int k = 0; k < j; ++k)
            {
                if (check(s, pts[k]))
                    continue;
                s = calc(pts[i], pts[j], pts[k]);
                for (int l = 0; l < k; ++l)
                {
                    if (check(s, pts[l]))
                        continue;
                    s = calc(pts[i], pts[j], pts[k], pts[l]);
                }
            }
        }
    }
    return s;
}
```

### 单峰函数与三分
常见单峰函数：

二次函数：其最值在对称轴取得

绝对值函数：

![image](https://cdn.nlark.com/yuque/__latex/fa4fbcd3f01e2a11d286ac2b40c27f8e.svg)是单峰函数，其最值在所有![image](https://cdn.nlark.com/yuque/__latex/5d496a3b872073b90e3b920cacfc3dc6.svg)的中位数取得

整数三分

```cpp
int calc(int x)
{
   
}
int search(int l, int r)
{
    const int corner = 2;
    while (r - l > corner)
    { // 精度到达三分间隔时停止
        int m1 = l + (r - l) / 3;
        int m2 = r - (r - l) / 3;

        if (calc(m1) > calc(m2))
        {
            r = m2; // 左侧更优
        }
        else
        {
            l = m1; // 右侧更优
        }
    }
    int res = l;
    for (int i = l + 1; i <= r; ++i)
    {
        if (calc(i) > calc(res))
        {
            res = i;
        }
    }
    return res;
}
```

实数三分

```cpp
long double calc(long double x)
{
}

long double search(long double l, long double r, long double epsilon = 1e-9)
{
    while (r - l > epsilon)
    {
        long double m1 = l + (r - l) / 3;
        long double m2 = r - (r - l) / 3;
        if (calc(m1) > calc(m2))
        {
            r = m2; // 左侧更优
        }
        else
        {
            l = m1; // 右侧更优
        }
    }
    return (l + r) / 2; // 返回最优点
}
```

三分套三分

使用场景往往是面向二元函数![image](https://cdn.nlark.com/yuque/__latex/e881f7c9ce8a35fff199e6aeeec433f1.svg),满足在固定![image](https://cdn.nlark.com/yuque/__latex/712ecf7894348e92d8779c3ee87eeeb0.svg)时![image](https://cdn.nlark.com/yuque/__latex/e881f7c9ce8a35fff199e6aeeec433f1.svg)随![image](https://cdn.nlark.com/yuque/__latex/bf98c0ddcbe9c1e535f767c78c3aa813.svg)变化是单峰的，那么我们对固定的![image](https://cdn.nlark.com/yuque/__latex/712ecf7894348e92d8779c3ee87eeeb0.svg)，可三分出最优的![image](https://cdn.nlark.com/yuque/__latex/bf98c0ddcbe9c1e535f767c78c3aa813.svg)。同时我们定义![image](https://cdn.nlark.com/yuque/__latex/5209d7274ec2cc3fedfb2262d1ae2c26.svg)，如果![image](https://cdn.nlark.com/yuque/__latex/55ba3b4ecaffd878543e762f3ce0d49b.svg)也是单峰的，即对于每个![image](https://cdn.nlark.com/yuque/__latex/712ecf7894348e92d8779c3ee87eeeb0.svg)在取到最优的![image](https://cdn.nlark.com/yuque/__latex/bf98c0ddcbe9c1e535f767c78c3aa813.svg)以后仍然保持单峰，那么就可以采用三分套三分。



结论：多个下凸函数的![image](https://cdn.nlark.com/yuque/__latex/e73a4bbeae47057f73628a1f8e32a605.svg)仍然是下凸函数，多个上凸函数的![image](https://cdn.nlark.com/yuque/__latex/8a93d856ced2a133a990fa45a2130524.svg)仍然是上凸函数


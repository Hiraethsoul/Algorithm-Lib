### 字符串哈希
注意哈希传入的字符串都是![image](https://cdn.nlark.com/yuque/__latex/c12dad7f4e4424a267734b6c183bffe4.svg)

#### 有序字符串哈希
我们考虑哈希函数为![image](https://cdn.nlark.com/yuque/__latex/af47edb0a331c1d4a1c9f81ee76331aa.svg),那么假设我们预处理出了所有的位置![image](https://cdn.nlark.com/yuque/__latex/4dd004c812cd8d82d0efed94734dd4da.svg)对应的![image](https://cdn.nlark.com/yuque/__latex/d947b22dc4cc29ab1b8e4c4bc5f993f9.svg),

那么![image](https://cdn.nlark.com/yuque/__latex/371d3811de80d3e7a448b5cebe095023.svg)的哈希值为![image](https://cdn.nlark.com/yuque/__latex/c32e72d4df1d949e8835d1a15be47be6.svg)

```cpp
struct StringHash
{
    int n;
    std::vector<int> Hash;
    std::vector<int> H;
    int Base, P;
    StringHash(const std::string &s, int Base, int P) : n(s.size()), Hash(n), H(n), Base(Base), P(P) // 默认字符串加了前导字符
    {
        Hash.assign(n, 0);
        H.assign(n, 0);
        Hash[0] = 1;
        for (int i = 1; i <= n - 1; ++i)
        {
            Hash[i] = Hash[i - 1] * Base % P;
        }
        for (int i = 1; i <= n - 1; ++i)
        {
            H[i] = (H[i - 1] * Base % P + s[i]) % P;
        }
    }
    int operator()(int l, int r)
    {
        return (H[r] - H[l - 1] * Hash[r - l + 1] % P + P) % P;
    }
};
```

#### 无序字符串哈希
我们考虑哈希函数为![image](https://cdn.nlark.com/yuque/__latex/9d3d9ed3ca122f158e205f70f61e4624.svg)，其中![image](https://cdn.nlark.com/yuque/__latex/6376e2934f3282e5b03eb695928ebfe5.svg)是一个随机的函数，只要保证![image](https://cdn.nlark.com/yuque/__latex/712ecf7894348e92d8779c3ee87eeeb0.svg)相同时![image](https://cdn.nlark.com/yuque/__latex/6376e2934f3282e5b03eb695928ebfe5.svg)相同即可

```cpp
struct StringHash
{
    int n;
    std::vector<int> Hash;
    std::vector<int> H;
    int Base, P;
    StringHash(std::vector<int> &a, int max, int Base, int P) : n(a.size()), Base(Base), P(P) // 无序哈希
    {
        Hash.assign(max + 1, 0);
        H.assign(n, 0);
        Hash[0] = 1;
        for (int i = 1; i <= max; ++i)
        {
            Hash[i] = Hash[i - 1] * Base % P;
        }
        for (int i = 1; i <= n - 1; ++i)
        {
            H[i] = (H[i - 1] + Hash[a[i]]) % P;
        }
    }
    int operator()(int l, int r)
    {
        return (H[r] - H[l - 1] + P) % P;
    }
};
```

#### 二维有序字符串哈希
```cpp
using u64 = unsigned long long;
struct Hash
{
    int n, m;
    std::vector<u64> hX;//预处理行的Base次幂数组
    std::vector<u64> hY;//预处理列的Base次幂数组
    std::vector<std::vector<u64>> A;//哈希数组
    int P, Q;//两个Base 分别为行和列

    Hash(const std::vector<std::vector<char>> &a, int n, int m, int P, int Q) : n(n), m(m), hX(n + 1), hY(m + 1), P(P), Q(Q)
    {
        A.assign(n + 1, std::vector<u64>(m + 1, 0));
        hX[0] = 1;
        hY[0] = 1;
        for (int i = 1; i <= n; ++i)
        {
            hX[i] = hX[i - 1] * P;
        }
        for (int i = 1; i <= m; ++i)
        {
            hY[i] = hY[i - 1] * Q; 
        }
        for (int i = 1; i <= n; ++i)
        {
            for (int j = 1; j <= m; ++j)
            {
                A[i][j] = A[i][j - 1] * Q + A[i - 1][j] * P - A[i - 1][j - 1] * P * Q + (a[i][j] - 'a' + 1);
            }
        }
    }

    u64 query(int x1, int y1, int x2, int y2)
    {
        return A[x2][y2] - A[x2][y1 - 1] * hY[y2 - y1 + 1] - A[x1 - 1][y2] * hX[x2 - x1 + 1] + A[x1 - 1][y1 - 1] * hX[x2 - x1 + 1] * hY[y2 - y1 + 1];
    }
};
```

### 最小表示法
返回一个字符串字典序最小的循环同构串。

```cpp
std::vector<int> minimalString(std::vector<int> &a)
{
       int n = a.size();
       int i = 0, j = 1, k = 0;
       while (k < n and i < n and j < n)
       {
              if (a[(i + k) % n] == a[(j + k) % n])
              {
                     k++;
              }
              else
              {
                     (a[(i + k) % n] > a[(j + k) % n] ? i : j) += k + 1;
                     i += (i == j);
                     k = 0;
              }
       }
       k = std::min(i, j);
       std::vector<int> ans(n);
       for (int i = 0; i < n; i++)
       {
              ans[i] = a[(i + k) % n];
       }
       return ans;
}
// 直接返回字典序最小循环同构串
```

小Trick：如果我们有一个字符串数组，我们希望按特定的顺序拼起来，使得其字典序最小，我们只需要重载排序函数，方法是![image](https://cdn.nlark.com/yuque/__latex/88a37842de2a162151f3828f4edc040c.svg)，其中![image](https://cdn.nlark.com/yuque/__latex/8a92b607130b5be247860cc37d34eca7.svg)都是字符串类型。

### KMP
对于字符串![image](https://cdn.nlark.com/yuque/__latex/55fc237afbe535f7d8434985b848a6a7.svg)，我们通过![image](https://cdn.nlark.com/yuque/__latex/8937a2ecdb91320a694d849733fd3df3.svg)求出一个![image](https://cdn.nlark.com/yuque/__latex/4672bb69bc81d7837130f5be4679a702.svg)数组，其中![image](https://cdn.nlark.com/yuque/__latex/741446d70d045da1f57be7cab441c1ea.svg)表示该字符串以![image](https://cdn.nlark.com/yuque/__latex/2443fbcfeb7e85e1d62b6f5e4f27207e.svg)为结尾的前缀串的最长公共前后缀中前缀的结尾位置，其存在的意义是在匹配失败时不要从头开始匹配，例如![image](https://cdn.nlark.com/yuque/__latex/de3d16145fe42726958a81c8f97e8082.svg)中![image](https://cdn.nlark.com/yuque/__latex/396b16b1a112ac97be4672970a44dce5.svg)，代表我们在5位置匹配失败后可以从2位置继续匹配

但是如果我们有求出![image](https://cdn.nlark.com/yuque/__latex/4672bb69bc81d7837130f5be4679a702.svg)的办法我们可以用更简单的方法进行字符串匹配，

只需要原串+特殊字符+匹配串，那么如果![image](https://cdn.nlark.com/yuque/__latex/fde24d32cf15eba61e66dc96744c24cb.svg)等于原串长度，那么匹配成功

```cpp

class KMP
{

public:
    KMP() {}
    std::vector<int> getPreFunction(std::string &s)
    {
        return kmp(s);
    }
    std::vector<int> getMatchPos(std::string &s, std::string &t)
    {
        std::vector<int> pos;
        auto link = kmp(t + "#" + s); // 在s中找t
        for (int i = t.size() + 1; i < link.size(); i++)
        {
            if (link[i] == t.size())
            {
                pos.push_back(i - 2 * t.size() + 1);
            }
        }
        return pos;
    }

private:
    std::vector<int> kmp(const std::string &s)
    {
        int n = s.size();
        std::vector<int> link(n);
        for (int i = 1, j = 0; i < n; i++)
        {
            while (j and s[i] != s[j])
            {
                j = link[j - 1];
            }
            j += (s[i] == s[j]);
            link[i] = j;
        }
        return link;
    }
};

```

### Z函数（扩展KMP）
对于字符串![image](https://cdn.nlark.com/yuque/__latex/55fc237afbe535f7d8434985b848a6a7.svg)，我们可以通过![image](https://cdn.nlark.com/yuque/__latex/f02d5fef344ac332f124cc9e815e9b69.svg)求出一个![image](https://cdn.nlark.com/yuque/__latex/ca9972fb0e732f9a939604a4b2e0f4c0.svg)数组，其中![image](https://cdn.nlark.com/yuque/__latex/8c8dd75c474be37633ad145ba7ca8302.svg)表示以![image](https://cdn.nlark.com/yuque/__latex/2443fbcfeb7e85e1d62b6f5e4f27207e.svg)为起点的后缀和原串的最长公共前缀，原理是通过维护一个![image](https://cdn.nlark.com/yuque/__latex/baa71954462d3ae393b4bbfdcb3654fd.svg)加速转移

需要注意到的是![image](https://cdn.nlark.com/yuque/__latex/02bab26178a0cd05dae15ad487830237.svg)函数的返回值中![image](https://cdn.nlark.com/yuque/__latex/208d0909c2849e44c907a02b5ae0bf19.svg)



具体的说：对于![image](https://cdn.nlark.com/yuque/__latex/2443fbcfeb7e85e1d62b6f5e4f27207e.svg)，我们称区间![image](https://cdn.nlark.com/yuque/__latex/cd4794a31b7d57294227477adb4e4494.svg)为![image](https://cdn.nlark.com/yuque/__latex/2443fbcfeb7e85e1d62b6f5e4f27207e.svg)的![image](https://cdn.nlark.com/yuque/__latex/eaecb7b2e3e7ef97c202b68e49ae24b5.svg)，在算法执行过程中我们维护右端点最右的匹配段，我们记作![image](https://cdn.nlark.com/yuque/__latex/371d3811de80d3e7a448b5cebe095023.svg)，根据定义![image](https://cdn.nlark.com/yuque/__latex/371d3811de80d3e7a448b5cebe095023.svg)是原串的一个前缀。初始时![image](https://cdn.nlark.com/yuque/__latex/c92bc04765e48e0e51719b28e381aa32.svg)。

我们从小到大计算![image](https://cdn.nlark.com/yuque/__latex/493ca0decdcdcf04e411d9afa15b340a.svg)，注意![image](https://cdn.nlark.com/yuque/__latex/208d0909c2849e44c907a02b5ae0bf19.svg)。

如果![image](https://cdn.nlark.com/yuque/__latex/cedd93dc33b32f6d4e2fdffbe0807960.svg)，根据定义有![image](https://cdn.nlark.com/yuque/__latex/f245225fd69f27affe6b30b90f4ac718.svg),所以![image](https://cdn.nlark.com/yuque/__latex/945f652d53591b4d4243a8efe352780c.svg)，那么若![image](https://cdn.nlark.com/yuque/__latex/75704f68916da65b56e6dfdea14f4900.svg)，![image](https://cdn.nlark.com/yuque/__latex/1adb08de021f859e2ec37d1f045e2f20.svg)。否则我们让![image](https://cdn.nlark.com/yuque/__latex/e2227c2656b7f81e4018eb56c20d6b72.svg),然后我们不断向后暴力拓展。

如果![image](https://cdn.nlark.com/yuque/__latex/e15170064ab39644011d2cd2b4fe3ffe.svg)，我们直接暴力匹配求出![image](https://cdn.nlark.com/yuque/__latex/493ca0decdcdcf04e411d9afa15b340a.svg)

在求出每一个![image](https://cdn.nlark.com/yuque/__latex/493ca0decdcdcf04e411d9afa15b340a.svg)后，若![image](https://cdn.nlark.com/yuque/__latex/7ed167aec4eda2b082c09e1d6563243e.svg)，我们更新![image](https://cdn.nlark.com/yuque/__latex/371d3811de80d3e7a448b5cebe095023.svg)为![image](https://cdn.nlark.com/yuque/__latex/cd4794a31b7d57294227477adb4e4494.svg)

```cpp
class ZFunction
{
public:
    ZFunction() {}

    std::vector<int> getZFunction(const std::string &s)
    // 得到单个字符串的z函数值
    {
        return zFunction(s);
    }
    std::vector<int> getMatch(const std::string &s, const std::string &t)
    // 得到字符串s的每一个后缀和t的前缀的匹配结果
    {
        auto z = zFunction(t + "#" + s);
        return std::vector(z.begin() + t.size() + 1, z.end());
    }

private:
    std::vector<int> zFunction(const std::string &s)
    {
        int n = s.size();
        std::vector<int> z(n);
        for (int i = 1, l = 0, r = 0; i < n; i++)
        {
            if (i < r) // 在Z-box内
            {
                z[i] = std::min(z[i - l], r - i);
            }
            while (i + z[i] < n and s[i + z[i]] == s[z[i]]) // 暴力
            {
                z[i]++;
            }
            if (i + z[i] > r) // 更新Z-box
            {
                l = i, r = i + z[i];
            }
        }
        return z;
    }
};

```

### Manacher
类似于![image](https://cdn.nlark.com/yuque/__latex/07eadc3a40241c20bb7e4e78aabd2268.svg)的求法，我们同样维护一个加速盒子来加速我们的转移

可以求出字符串每个位置的回文半径长度

```cpp
std::vector<int> manacher(std::string s)
{
    std::string t = "#";
    for (auto c : s)
    {
        t += c;
        t += '#';
    }
    int n = t.size();
    std::vector<int> r(n);
    for (int i = 0, j = 0; i < n; i++)
    {
        if (2 * j - i >= 0 && j + r[j] > i)
        {
            r[i] = std::min(r[2 * j - i], j + r[j] - i);
        }
        while (i - r[i] >= 0 && i + r[i] < n && t[i - r[i]] == t[i + r[i]])
        {
            r[i] += 1;
        }
        if (i + r[i] > j + r[j])
        {
            j = i;
        }
    }
    for (auto &i : r)
    {
        i--;
    }
    return r;
}
```

### 最小循环节
判断一个串是否有长度为![image](https://cdn.nlark.com/yuque/__latex/56c1b0cb7a48ccf9520b0adb3c8cb2e8.svg)的循环节，我们只需要判断![image](https://cdn.nlark.com/yuque/__latex/090f6963ed2642fd3c6b76d3aef06ea3.svg)和![image](https://cdn.nlark.com/yuque/__latex/9f88e2a15eaa3a825f32d2debfd3ece4.svg)处的串是否相同即可，其中![image](https://cdn.nlark.com/yuque/__latex/6945e109777fe3fd777e8254f0ec0f0c.svg)表示左端点，![image](https://cdn.nlark.com/yuque/__latex/72cb3a229067770aeb6caa625a65a1a1.svg)表示右端点。

如果要找到最小的循环节，我们考虑到答案一定是![image](https://cdn.nlark.com/yuque/__latex/b3a83f2cda0f662e3eb121e0d06d2f7f.svg)的一个因数，并且由唯一分解定理一定可以表示为![image](https://cdn.nlark.com/yuque/__latex/afef3522f5d3d683a0d2a8af4651e09d.svg)，那么我们对![image](https://cdn.nlark.com/yuque/__latex/b3a83f2cda0f662e3eb121e0d06d2f7f.svg)不断除去它的最小质因数（用欧拉筛处理），同时判断![image](https://cdn.nlark.com/yuque/__latex/b6c262a1ae972f9d5c381d97ef1bf515.svg)除去该质因数是否满足即可，在实现哈希函数后，复杂度为![image](https://cdn.nlark.com/yuque/__latex/8cb8a71c68903ee92266697bb696e343.svg)，即所有质因数的幂之和

```cpp
int findMinimalCycle(std::string s)
{
    int len = s.length();
    s = ' ' + s;
    int l = 1, r = len;
    StringHash hash(s, 13331, 998244353);
    int ans = len;
    while (len != 1)
    {
        int d = ans / minPrimeFactor(len);
        if (hash(l, r - d) == hash(l + d, r))
        {
            ans = d;
        }
        len /= minPrimeFactor(len);
    }
    return ans;
}

```

### Lyndon分解
我们先介绍![image](https://cdn.nlark.com/yuque/__latex/3305c78535a7916a79c99fcb68daae9d.svg)串，为了方便我们用![image](https://cdn.nlark.com/yuque/__latex/79ce3c7a71877c2ff01695e38ade43ca.svg)表示字符串。其定义是![image](https://cdn.nlark.com/yuque/__latex/79ce3c7a71877c2ff01695e38ade43ca.svg)的字典序严格小于![image](https://cdn.nlark.com/yuque/__latex/79ce3c7a71877c2ff01695e38ade43ca.svg)的所有后缀。

我们称一个字符串![image](https://cdn.nlark.com/yuque/__latex/79ce3c7a71877c2ff01695e38ade43ca.svg)的![image](https://cdn.nlark.com/yuque/__latex/3305c78535a7916a79c99fcb68daae9d.svg)分解是指![image](https://cdn.nlark.com/yuque/__latex/7db81d663268d14285fbe42d3f414681.svg)，其中每个![image](https://cdn.nlark.com/yuque/__latex/c9b08ae6d9fed72562880f75720531bc.svg)均为![image](https://cdn.nlark.com/yuque/__latex/3305c78535a7916a79c99fcb68daae9d.svg)串且字典序非严格单调减少。

可以证明这样的分解方式存在且唯一。

```cpp
std::vector<int> Lyndon(std::string s) // 分成k个串 满足对每个串满足S(i)>=S(i+1)
// 每个S[i]都是其所有后缀中字典序最小的  也就是所有循环同构串中的最小串
{
    std::vector<int> res; // 存每个串的右端点
    int n = s.length();
    s = ' ' + s;
    for (int i = 1; i <= n;)
    {
        int j = i, k = i + 1; // 初始化
        while (k <= n and s[j] <= s[k])
        {
            if (s[j] < s[k])
            {
                j = i; // 合并为一整个
            }
            else
            {
                j++; // 保持循环不变式
            }
            k++;
        }
        while (i <= j) // 从v的开头重新开始
        {
            res.push_back(i + k - j - 1);
            i += k - j;
        }
    }
    return res;
}
```

### 子序列自动机
子序列自动机即预处理出所有的![image](https://cdn.nlark.com/yuque/__latex/69e48b02e9c3e435c9875c395232abf9.svg),其中![image](https://cdn.nlark.com/yuque/__latex/2443fbcfeb7e85e1d62b6f5e4f27207e.svg)表示位置，![image](https://cdn.nlark.com/yuque/__latex/b891664b42113aee13f0bac25eb998e5.svg)表示字符集，朴素做法的复杂度为![image](https://cdn.nlark.com/yuque/__latex/43bbf861f525e64ba3c33dc475bc6b34.svg)

```cpp
template <int Z, char Base>
struct SubSequenceAutomaton // 每个位置后面每个字母第一次出现的位置
{

    std::vector<std::array<int, Z>> next;
    int n;
    SubSequenceAutomaton(std::string s) : n(s.size() - 1) // 默认s是加过前缀空字符的
    {
        next.resize(n + 1);

        for (int i = 0; i < Z; ++i)
        {
            next[n][i] = n + 1;
        }
        for (int i = n - 1; i >= 0; --i)
        {
            next[i] = next[i + 1];
            next[i][s[i + 1] - Base] = i + 1;
        }
    }
    int getNextPos(int pos, char c)
    {
        return next[pos][c - Base];
    }
};
```

不难发现子序列自动机中每个位置只会有一个字符的值被修改，这启发我们使用主席树优化，这适用于字符集![image](https://cdn.nlark.com/yuque/__latex/b891664b42113aee13f0bac25eb998e5.svg)很大时，同样的我们的查询也会由![image](https://cdn.nlark.com/yuque/__latex/a2006f1ac61cb1902beacb3e29fff089.svg)变成为![image](https://cdn.nlark.com/yuque/__latex/1b0fce2bd1f5925667628ba7a81a4635.svg)

```cpp
struct PresidentTree
{
    int idx = 0;
    int n;
    std::vector<int> root, lc, rc;
    std::vector<int> sum;

    void pushup(int u)
    {
        sum[u] = sum[lc[u]] + sum[rc[u]];
    }
    PresidentTree(const std::vector<int> &a, int len) : n(a.size()), root(len + 1), lc(len * 40), rc(len * 40), sum(len * 40)
    { // 传入的a实际上是值域
        std::function<void(int &, int, int)> build = [&](int &u, int l, int r)
        {
            u = ++idx;
            if (l == r)
            {
                sum[u] = a[l];
                return;
            }
            int mid = l + r >> 1;
            build(lc[u], l, mid);
            build(rc[u], mid + 1, r);
            pushup(u);
        };
        build(root[len], 1, n - 1); //  倒着建树 
    }
    void insert(int &u, int v, int l, int r, int pos, int x) // 要插入新版本 所以idx必须++
    {
        u = ++idx; // 一定是直接加 不用判断是不是0
        lc[u] = lc[v];
        rc[u] = rc[v];
        sum[u] = sum[v];
        if (l == r)
        {
            sum[u] = x;
            return;
        }
        int mid = l + r >> 1;
        if (pos <= mid)
        {
            insert(lc[u], lc[v], l, mid, pos, x);
        }
        else
        {
            insert(rc[u], rc[v], mid + 1, r, pos, x);
        }
        pushup(u);
    }

    void insert(int now, int pre, int pos, int x)
    {
        insert(root[now], root[pre], 1, n - 1, pos, x);
    }

    int query(int u, int l, int r, int pos)
    {
        if (l == r)
        {
            return sum[u];
        }
        int mid = l + r >> 1;
        if (pos <= mid)
        {
            return query(lc[u], l, mid, pos);
        }
        else
        {
            return query(rc[u], mid + 1, r, pos);
        }
    }
    int query(int t, int pos)
    {
        return query(root[t], 1, n - 1, pos);
    }
};

// 子序列自动机

struct SubsequenceAutomaton
{
    const std::vector<int> &val;
    PresidentTree Tree;
    int n;
    SubsequenceAutomaton(const std::vector<int> &a, std::vector<int> &init) : val(a), n(a.size() - 1), Tree(init, a.size() - 1)
    {
        for (int i = n - 1; i >= 0; --i)
        {
            Tree.insert(i, i + 1, val[i + 1], i + 1); // 更新子序列自动机
        }
    }
    int query(int pos, int val) // pos后面第一个val的位置
    {
        return Tree.query(pos, val);
    }
};

```

### AC自动机
AC自动机即在![image](https://cdn.nlark.com/yuque/__latex/a9219c92963c9a0e4bfb2685e31c9959.svg)树的基础上补成一个![image](https://cdn.nlark.com/yuque/__latex/a9219c92963c9a0e4bfb2685e31c9959.svg)有向图，并求出![image](https://cdn.nlark.com/yuque/__latex/4672bb69bc81d7837130f5be4679a702.svg)指针，![image](https://cdn.nlark.com/yuque/__latex/a9219c92963c9a0e4bfb2685e31c9959.svg)图的意义在于，它借助![image](https://cdn.nlark.com/yuque/__latex/4672bb69bc81d7837130f5be4679a702.svg)指针补上了能继续匹配下去的边，![image](https://cdn.nlark.com/yuque/__latex/4672bb69bc81d7837130f5be4679a702.svg)指针的意义是指向最长的相等后缀，如果我们当前![image](https://cdn.nlark.com/yuque/__latex/3177ca791b095af3834891d1bfdeee24.svg)没有出边，我们就考虑![image](https://cdn.nlark.com/yuque/__latex/228cc11fb30502388051e177ae78edea.svg)即可。

![image](https://cdn.nlark.com/yuque/__latex/4672bb69bc81d7837130f5be4679a702.svg)树的意义在于，如果节点![image](https://cdn.nlark.com/yuque/__latex/4017e75c6550e3645061935c09a70240.svg)出现过那么所有的![image](https://cdn.nlark.com/yuque/__latex/4672bb69bc81d7837130f5be4679a702.svg)也将出现，注意我们的![image](https://cdn.nlark.com/yuque/__latex/4672bb69bc81d7837130f5be4679a702.svg)树和![image](https://cdn.nlark.com/yuque/__latex/a9219c92963c9a0e4bfb2685e31c9959.svg)树共用所有点但不共用边，换句话说，![image](https://cdn.nlark.com/yuque/__latex/4672bb69bc81d7837130f5be4679a702.svg)树独立在![image](https://cdn.nlark.com/yuque/__latex/1dc9d086360300d42e73101b41a80941.svg)图以外 

我们考虑一个串在![image](https://cdn.nlark.com/yuque/__latex/a9219c92963c9a0e4bfb2685e31c9959.svg)图上走的意义，首先建图方式保证了我们走图的最优性，什么叫最优性呢，也就是说在走不下去时会找到最长的后缀继续走下去。我们每走到一个点，该点在![image](https://cdn.nlark.com/yuque/__latex/4672bb69bc81d7837130f5be4679a702.svg)树上的每个祖先都会出现一次，由于最优性保证了不重不漏。因此多模式匹配的做法就是，先在![image](https://cdn.nlark.com/yuque/__latex/a9219c92963c9a0e4bfb2685e31c9959.svg)图上跑完整个串，对于每个到达的节点都标记一次贡献。然后我们利用![image](https://cdn.nlark.com/yuque/__latex/3554585ecb04a4bf73b5938d239b0fe5.svg)或者![image](https://cdn.nlark.com/yuque/__latex/b5f22ec0da2df646c07aa27c4d912f72.svg)的方式自下而上合并，把所有贡献合并给其祖先即可，此时每个节点的权值就代表了它出现的次数。

```cpp
template <int Z, char Base>
struct AcAutomaton
{
    std::vector<int> fail; // fail指针
    std::vector<std::vector<int>> ch;
    std::vector<std::vector<int>> ID;
    int idx = 0;
    int sum = 0;
    int n;

    AcAutomaton(std::vector<std::string> &s) : n(s.size())
    {
        for (auto x : s)
        {
            sum += x.size();
        }
        ch.assign(sum + 1, std::vector<int>(Z, 0));
        fail.resize(sum + 1);
        ID.resize(sum + 1);
        for (int i = 0; i < n; ++i)
        {
            insert(i, s[i]);
        }
        build();
    }

    void insert(int id, std::string s)
    {
        int p = 0;
        for (auto j : s)
        {
            j -= Base;
            if (!ch[p][j])
            {
                ch[p][j] = ++idx;
            }
            p = ch[p][j];
        }
        ID[p].push_back(id);
    }

    void build()
    {
        std::queue<int> q;
        for (int i = 0; i < 26; ++i)
        {
            if (ch[0][i])
            {
                q.push(ch[0][i]);
            }
        }
        while (q.size())
        {
            int u = q.front();
            q.pop();
            for (int i = 0; i < 26; ++i)
            {
                int v = ch[u][i];
                if (v)
                {
                    fail[v] = ch[fail[u]][i]; // fail指针回跳边
                    q.push(v);
                }
                else
                {
                    ch[u][i] = ch[fail[u]][i]; // 横插边
                }
            }
        }
    }
};

```

### 后缀自动机
后缀自动机是一个![image](https://cdn.nlark.com/yuque/__latex/74b421a9a3c40d7ff8700ba55614b5a1.svg)树,我们假设![image](https://cdn.nlark.com/yuque/__latex/cc4d9e051486ebc19bcada12293e9687.svg)为初始状态，![image](https://cdn.nlark.com/yuque/__latex/cc4d9e051486ebc19bcada12293e9687.svg)到每个结束节点都是原串的一个后缀，原串的每个子串都可以通过![image](https://cdn.nlark.com/yuque/__latex/cc4d9e051486ebc19bcada12293e9687.svg)到某个节点得到。可以证明，![image](https://cdn.nlark.com/yuque/__latex/9df28e6c003e00b85bd18ce2c83acf05.svg)等价类要么包含要么完全不交，我们![image](https://cdn.nlark.com/yuque/__latex/4672bb69bc81d7837130f5be4679a702.svg)指针的意义是，指向最长的后缀且满足![image](https://cdn.nlark.com/yuque/__latex/9df28e6c003e00b85bd18ce2c83acf05.svg)类是我的超集,![image](https://cdn.nlark.com/yuque/__latex/b3a83f2cda0f662e3eb121e0d06d2f7f.svg)是当前节点代表的最长串，在![image](https://cdn.nlark.com/yuque/__latex/4672bb69bc81d7837130f5be4679a702.svg)树上，父节点代表的最长串是子节点最短串的最长后缀



我们需要注意的是

![image](https://cdn.nlark.com/yuque/__latex/433b8a66a6efa08fd812b9e20c8af568.svg)数组只有在加新字符才更新，但分裂节点是不更新的，所以cnt数组实际上是个01数组

我们通过![image](https://cdn.nlark.com/yuque/__latex/3554585ecb04a4bf73b5938d239b0fe5.svg)![image](https://cdn.nlark.com/yuque/__latex/4672bb69bc81d7837130f5be4679a702.svg)树合并![image](https://cdn.nlark.com/yuque/__latex/433b8a66a6efa08fd812b9e20c8af568.svg)数组得到![image](https://cdn.nlark.com/yuque/__latex/9df28e6c003e00b85bd18ce2c83acf05.svg)的大小

特别的当字符集很大时，我们把![image](https://cdn.nlark.com/yuque/__latex/7d8b27142fb430036db27e12d11343b5.svg)换成哈希表



我们考虑题目的两种处理方法，即考虑![image](https://cdn.nlark.com/yuque/__latex/9386275861ba80286f7177a8bef403ab.svg)数组或者考虑![image](https://cdn.nlark.com/yuque/__latex/4672bb69bc81d7837130f5be4679a702.svg)树，换句话说分为考虑路径和考虑点，因为![image](https://cdn.nlark.com/yuque/__latex/fa19270340385d0ec45ae7e3097d9f8f.svg)和树都具有很好的性质

第一种情况，我们考虑路径，也就是说我们的所有子串都是一个固定起点的路径，我们可以在![image](https://cdn.nlark.com/yuque/__latex/8bca7aa7adef4d08a4a69af78d62516c.svg)上![image](https://cdn.nlark.com/yuque/__latex/cdaf04cddf57ae63edeafceb53eb4044.svg)出想要的信息，例如我们求一个节点经过的不同子串数量实际上是DAG后继路径的数量，如果求经过这个点的所有子串数量，那么就是后继路径![image](https://cdn.nlark.com/yuque/__latex/cb1fea67458a5adad2e285835f225130.svg)的和，用于处理子串第![image](https://cdn.nlark.com/yuque/__latex/6a6b811a2879516d7418f3d7325a142d.svg)大相关问题

第二种情况，我们考虑点，在![image](https://cdn.nlark.com/yuque/__latex/4672bb69bc81d7837130f5be4679a702.svg)树上我们的子串信息被高度压缩,每个节点代表![image](https://cdn.nlark.com/yuque/__latex/9df28e6c003e00b85bd18ce2c83acf05.svg)相同的一类长度连续的子串，也就是说，他们从小到大是彼此的后缀。

```cpp
template <int Z, char Base>
struct Sam
{
    // 转移函数，ch[u][c]表示从状态u经过字符c转移到的状态
    std::vector<std::array<int, Z>> ch;

    std::vector<std::vector<int>> g;
    // fail指针(后缀链接)，len[u]表示状态u代表的最长子串长度
    std::vector<int> fail, len;
    // 点u表示的串长范围是 [len[fail[u]]+1,len[u]]

    // 如果我们在fail树上dfs合并cnt[u],那么cnt[u]表示状态u的endpos集合大小,也就是串的出现次数
    std::vector<long long> cnt;

    int last;      // 上一个添加的状态
    int tot;       // 总状态数
    long long num; // 不同子串的数量

    // 构造函数，预分配空间
    Sam(int n) : ch((n + 1) << 1), fail((n + 1) << 1), len((n + 1) << 1), g(n + 1 << 1)
    {
        cnt.assign((n + 1) << 1, 0);
        last = tot = 1; // 初始状态为1
        fail[1] = -1;   // 根节点的fail指针设为-1
        num = 0;
    }

    // 从字符串构造SAM
    Sam(const std::string &s) : Sam(s.size())
    {
        for (char c : s)
        {
            add(c);
        }
        for (int i = 2; i <= tot; ++i)
        {
            g[fail[i]].push_back(i); // fail树
        }
    }

    // 向SAM中添加一个字符
    void add(char c)
    {
        c -= Base; // 将字符映射到[0,Z)范围

        // 创建新状态cur
        int cur = ++tot;
        len[cur] = len[last] + 1;         // 新状态代表的最长子串长度
        cnt[cur] = 1;                     // 新状态的endpos集合大小为1
        num += len[cur] - len[fail[cur]]; // 更新不同子串数量

        // 从last状态开始，沿着fail指针向上跳转
        int v = last;
        while (v != -1 && !ch[v][c])
        {
            ch[v][c] = cur; // 设置转移
            v = fail[v];    // 跳转到fail指针指向的状态
        }

        if (v == -1)
        {
            // 如果跳转到了初始状态，设置fail指针为根状态1
            fail[cur] = 1;
        }
        else
        {
            int q = ch[v][c];
            if (len[v] + 1 == len[q])
            {
                // 如果q正好是v的直接扩展，直接设置fail指针
                fail[cur] = q;
            }
            else
            {
                // 否则需要克隆状态q
                int clone = ++tot;
                len[clone] = len[v] + 1;
                ch[clone] = ch[q];     // 复制转移函数
                fail[clone] = fail[q]; // 复制fail指针

                // 更新所有指向q的转移
                while (v != -1 && ch[v][c] == q)
                {
                    ch[v][c] = clone;
                    v = fail[v];
                }

                // 更新q和cur的fail指针
                fail[q] = fail[cur] = clone;
            }
        }

        last = cur; // 更新last状态
    }
};
```

#### 动态树维护后缀自动机
因为![image](https://cdn.nlark.com/yuque/__latex/efc541079b45080327affad8793c1d7f.svg)可以动态维护树的形态，我们常常用![image](https://cdn.nlark.com/yuque/__latex/efc541079b45080327affad8793c1d7f.svg)来维护![image](https://cdn.nlark.com/yuque/__latex/4672bb69bc81d7837130f5be4679a702.svg)树。由于![image](https://cdn.nlark.com/yuque/__latex/efc541079b45080327affad8793c1d7f.svg)可以维护链上信息，也可维护子树信息，也分两种写法，主要在于如何正确修改![image](https://cdn.nlark.com/yuque/__latex/7230bbd072a13e429c09e931db5786af.svg)中的![image](https://cdn.nlark.com/yuque/__latex/2a11d10e5f1c1b171f06c38c6dfadab6.svg)函数

##### 维护链上信息
十分重要的是在这种做法下我们在分裂节点时需要![image](https://cdn.nlark.com/yuque/__latex/57aaf376a0ea2e346a3b5005976ed476.svg),然后把这个点的信息![image](https://cdn.nlark.com/yuque/__latex/1c9af8c924975d5dd2d20c34c296d44a.svg)到分裂出的新节点上，为什么呢？因为我们之前链加到该点的信息在克隆新点后，对新点仍然有效，于是不能丢失

```cpp
    //把fail树的根节点调为1
    void add(char c)
    {
        c -= Base;
        int cur = ++tot;
        // 在此对 cur 加信息
        len[cur] = len[last] + 1; // 节点代表的字符串长度的取值范围是(len[fa[i]],len[i]] 且每个长度都出现一次 endpos等价类
        int v = last;
        while (v != -1 and !ch[v][c])
        {
            ch[v][c] = cur, v = fail[v];
        }

        if (v == -1)
        {
            fail[cur] = 1;
            lct.link(cur, fail[cur]);
        }
        else
        {
            int q = ch[v][c];
            if (len[v] + 1 == len[q])
            {
                fail[cur] = q;
                lct.link(cur, fail[cur]);
            }
            else
            {
                int cl = ++tot;
                len[cl] = len[v] + 1;
                fail[cl] = fail[q];
                ch[cl] = ch[q];
                lct.link(cl, fail[cl]);

                lct.splay(q);           // clone节点时要保存lct的信息
                lct.tr[cl] = lct.tr[q]; // 如果是链加我需要保存节点信息

                while (v != -1 and ch[v][c] == q)
                {
                    ch[v][c] = cl, v = fail[v];
                }
                fail[cur] = cl;
                lct.link(cur, fail[cur]);

                lct.cut(q, fail[q]);
                fail[q] = cl;
                lct.link(q, fail[q]);
            }
        }
        last = cur;
        //在链上加信息，lct.add(1, cur, 1);//直接链加，查询就是单点查
    }
};
```

##### 维护子树信息
在维护子树和的情况下，我们直接把![image](https://cdn.nlark.com/yuque/__latex/d3093a8a6cb6377fce07cafb7dea6630.svg)中的连边断边改为![image](https://cdn.nlark.com/yuque/__latex/efc541079b45080327affad8793c1d7f.svg)即可，不需要在![image](https://cdn.nlark.com/yuque/__latex/0f00f5192dd4ccabf630201ec485bd11.svg)节点时维护额外的信息

我们把链加做法中的![image](https://cdn.nlark.com/yuque/__latex/d9180d989de84f593ebc476a7530f562.svg)删去即可

### 广义后缀自动机
广义后缀自动机是为了解决多个串的信息而出现的，其本质是在![image](https://cdn.nlark.com/yuque/__latex/686ea93c8b27e96b9c39885a6834950f.svg)树上建后缀自动机

```cpp
template <int Z, char Base>
struct ExSam
{
    std::vector<std::array<int, Z>> ch;       // 转移数组，存储每个状态的字符转移（大小为字符集Z）
    std::vector<int> len, fail;               // len: 状态代表的最长子串长度；fail: 失败指针（后缀链接）
    std::vector<std::vector<int>> ID;         // ID[p][i]: 状态p在第i个字符串中的出现次数
    std::vector<std::vector<int>> g;          // fail树的邻接表（用于后续DFS统计）
    int cnt;                                  // 字符串数量

    int tot = 0, last = 0;                    // tot: 总状态数；last: 当前最后一个状态
    long long num = 0;                        // 总不同子串数（未在代码中完全使用）

    // 构造函数：接收多个字符串，构建扩展后缀自动机
    ExSam(const std::vector<std::string> &S)
    {
        cnt = S.size();                        // 字符串数量
        int LEN = 0;
        for (const auto &str : S)              // 计算所有字符串总长度（预估空间）
        {
            LEN += str.size();
        }

        // 初始化数组大小（预分配足够空间）
        len.resize(LEN << 1);                  // 长度设为总长度2倍，避免动态扩容
        fail.resize(LEN << 1);
        fail[0] = -1;                          // 初始状态的fail指针设为-1（根节点）
        ch.resize(LEN << 1);
        g.resize(LEN << 1);
        // 初始化每个状态在各字符串中的出现次数（初始为0）
        for (int i = 0; i < LEN << 1; i++) {
            ID.emplace_back(cnt, 0);
        }

        for (int i = 0; i < S.size(); i++)     // 逐个处理每个字符串
        {
            last = 0;                           // 每个字符串处理时，从根节点开始
            for (char c : S[i])                 // 逐个字符添加到后缀自动机
            {
                exadd(c, i);                    // 核心添加字符函数，i为当前字符串索引
            }
        }
    }

    // 深度优先搜索fail树，统计每个状态在各字符串中的出现次数（自底向上累加）
    void dfs(int u)
    {
        for (auto v : g[u])                    // 遍历u的所有子节点（fail树的子节点）
        {
            dfs(v);                             // 递归处理子节点
            // 将子节点v的统计结果累加到父节点u
            for (int i = 0; i < cnt; ++i)
            {
                ID[u][i] += ID[v][i];
            }
        }
    }

    // 检查状态p是否在所有字符串中出现过（即每个字符串的ID[p][i]均非零）
    bool check(int p) 
    {
        for (int i = 0; i < cnt; ++i)
        {
            if (!ID[p][i])                     // 只要有一个字符串未出现，返回false
            {
                return false;
            }
        }
        return true;
    }

    // 查询多个字符串的最长公共子串长度（参数s可任选其中一个字符串）
    int querylen(std::string s) 
    {
        // 构建fail树的邻接表（每个节点的fail指针指向父节点）
        for (int i = 1; i <= tot; ++i)
        {
            g[fail[i]].push_back(i);           // fail[i]是i的父节点，添加边fail[i]->i
        }
        dfs(0);                                // 从根节点开始DFS，统计各状态的出现次数

        int p = 0, now = 0, res = 0;           // p: 当前状态；now: 当前匹配长度；res: 最长匹配长度
        for (auto c : s)                       // 遍历字符串s的每个字符
        {
            c -= Base;                          // 字符映射到0~Z-1的范围（与模板参数Base一致）

            // 情况1：当前状态p存在字符c的转移，且该转移状态在所有字符串中出现过
            if (check(ch[p][c]))               
            {
                p = ch[p][c];                   // 转移到子状态
                now++;                          // 匹配长度+1
            }
            else                                // 情况2：不存在合法转移，需跳fail指针
            {
                // 沿着fail指针回溯，直到找到合法转移或根节点
                while (p != -1 && !check(ch[p][c]))
                {
                    p = fail[p];
                }
                if (p == -1)                    // 回溯到根节点仍无合法转移，重置匹配长度
                {
                    now = 0;
                    p = 0;
                }
                else                            // 找到合法转移，更新匹配长度为当前状态长度+1
                {
                    now = len[p] + 1;
                    p = ch[p][c];
                }
            }
            res = std::max(res, now);           // 更新最长匹配长度
        }
        return res;
    }

private:
    // 给状态cur标记属于字符串id（出现次数+1）
    void assign(int cur, int id)
    {
        ID[cur][id]++;                         // 记录状态cur在第id个字符串中出现过
    }

    // 核心函数：向后缀自动机中添加字符c（属于字符串id）
    void exadd(char c, int id)
    {
        c -= Base;                             // 字符映射

        // 情况1：当前last状态存在c的转移
        if (ch[last][c])
        {
            int v = last;                      // v = last
            int q = ch[v][c];                  // q是v通过c转移的目标状态

            // 如果q的长度不等于v的长度+1（说明q是克隆节点）
            if (len[q] != len[v] + 1)
            {
                // 创建克隆节点cl（复制q的属性，但长度为v+1）
                int cl = ++tot;
                len[cl] = len[v] + 1;          // 克隆节点的长度为v的长度+1
                fail[cl] = fail[q];            // 克隆节点的fail指向q的fail
                ch[cl] = ch[q];                // 克隆节点的转移复制q的转移

                // 将v及其祖先中所有指向q的转移改为指向cl
                while (v != -1 && ch[v][c] == q)
                {
                    ch[v][c] = cl;
                    v = fail[v];
                }
                fail[q] = cl;                  // q的fail指向克隆节点cl
                q = cl;                        // q更新为克隆节点
            }
            // 更新last为q，并标记q属于当前字符串id
            int cur = last = q;
            assign(cur, id);
            return;
        }

        // 情况2：当前last状态不存在c的转移，创建新状态cur
        int cur = ++tot;                       // 新建状态cur
        len[cur] = len[last] + 1;              // cur的长度为last的长度+1
        assign(cur, id);                       // 标记cur属于当前字符串id

        int v = last;                          // v = last，从last开始回溯
        // 沿着fail指针找到第一个存在c转移的状态v，或根节点
        while (v != -1 && ch[v][c] == 0)
        {
            ch[v][c] = cur;                    // 设置v到cur的转移
            v = fail[v];                       // 回溯到v的fail
        }
        if (v == -1)                           // 回溯到根节点，cur的fail指向根节点（0）
        {
            fail[cur] = 0;
        }
        else                                    // 找到存在c转移的状态v，其转移目标为q
        {
            int q = ch[v][c];
            if (len[q] == len[v] + 1)          // q是正常扩展的状态，cur的fail指向q
            {
                fail[cur] = q;
            }
            else                                // q是旧状态，需要创建克隆节点cl
            {
                int cl = ++tot;
                len[cl] = len[v] + 1;          // 克隆节点cl的长度为v的长度+1
                fail[cl] = fail[q];            // cl的fail指向q的fail
                ch[cl] = ch[q];                // cl的转移复制q的转移

                // 将v及其祖先中所有指向q的转移改为指向cl
                while (v != -1 && ch[v][c] == q)
                {
                    ch[v][c] = cl;
                    v = fail[v];
                }
                fail[q] = fail[cur] = cl;       // q和cur的fail均指向cl
            }
        }
        last = cur;                            // 更新last为当前新状态cur
        num += len[cur] - len[fail[cur]];      // 统计新增的不同子串数（未在查询中使用）
    }
};
```

### 回文自动机
为了分别表示奇回文串和偶回文串，回文自动机是两棵树加![image](https://cdn.nlark.com/yuque/__latex/4672bb69bc81d7837130f5be4679a702.svg)指针的结构。我们不妨设左树维护偶回文串，根节点为![image](https://cdn.nlark.com/yuque/__latex/22d0feea96d3bb2fc273f7598ce748c1.svg)，右树维护奇回文串，根节点为![image](https://cdn.nlark.com/yuque/__latex/f5c91774886192157cf2ef03c17dcfc2.svg)。特别的，![image](https://cdn.nlark.com/yuque/__latex/22d0feea96d3bb2fc273f7598ce748c1.svg)的![image](https://cdn.nlark.com/yuque/__latex/4672bb69bc81d7837130f5be4679a702.svg)指针指向![image](https://cdn.nlark.com/yuque/__latex/53072c2388d69edc65c2377681e4e87c.svg)

自动机上每个节点都代表一个回文串，如果![image](https://cdn.nlark.com/yuque/__latex/2443fbcfeb7e85e1d62b6f5e4f27207e.svg)点代表的串为![image](https://cdn.nlark.com/yuque/__latex/55fc237afbe535f7d8434985b848a6a7.svg)，那么点![image](https://cdn.nlark.com/yuque/__latex/2443fbcfeb7e85e1d62b6f5e4f27207e.svg)经字符![image](https://cdn.nlark.com/yuque/__latex/b891664b42113aee13f0bac25eb998e5.svg)的边到达的节点为![image](https://cdn.nlark.com/yuque/__latex/7ea529f3bd67babf335c81bdcb7f72f5.svg)，其中![image](https://cdn.nlark.com/yuque/__latex/4672bb69bc81d7837130f5be4679a702.svg)指向最长的回文后缀。

```cpp
template <int Z, char Base>
struct Pam
{
    std::vector<std::array<int, Z>> ch;   // 转移数组，存储每个节点的子节点
    std::vector<int> fail, len, dep, cnt; // fail指针数组，回文长度数组，深度数组，计数器
    std::string s;                        // 存储添加的字符

    int cur = 0, tot = 1; // 当前节点和总节点数，初始有两个节点：0（偶长度根）和1（奇长度根）

    // 构造函数，初始化数组大小
    Pam(int n) : ch(n + 2), fail(n + 2), len(n + 2), dep(n + 2), cnt(n + 2)
    {
        fail[0] = 1; // 偶长度根的fail指向奇长度根
        len[1] = -1; // 奇长度根的回文长度为-1，作为特殊标记
    }

    // 用字符串初始化的构造函数
    Pam(const std::string &s) : Pam(s.size())
    {
        for (int i = 0; i < s.size(); i++)
        {
            add(i, s[i]); // 逐个添加字符
        }
    }

    // 节点计数函数，可用于统计每个回文子串的出现次数
    void assign(int cur, int id)
    {
        cnt[cur]++;
    }

    // 获取当前节点的fail指针
    int getfail(int x, int i)
    {
        // 循环找到第一个满足条件的fail节点
        while (i - len[x] - 1 < 0 or s[i - len[x] - 1] != s[i])
        {
            x = fail[x];
        }
        return x;
    }

    // 添加字符到PAM
    void add(int i, char c)
    {
        c -= Base;      // 字符映射到0-Z范围内
        s.push_back(c); // 添加到字符串

        int v = getfail(cur, i); // 获取当前节点的fail节点

        // 如果该转移不存在，则创建新节点
        if (!ch[v][c])
        {
            fail[++tot] = ch[getfail(fail[v], i)][c]; // 设置新节点的fail指针
            ch[v][c] = tot;                           // 设置转移
            len[tot] = len[v] + 2;                    // 新节点的回文长度
            dep[tot] = dep[fail[tot]] + 1;            // 新节点的深度
        }

        cur = ch[v][c]; // 更新当前节点
        assign(cur, i); // 更新计数
    }

    // 获取fail树的邻接表表示，根节点为1
    auto getfailTree() const
    {
        std::vector e(tot + 1, std::vector<int>());
        for (int i = 0; i <= tot; i++)
        {
            if (i != 1) // 跳过根节点
            {
                e[fail[i]].emplace_back(i); // 添加边
            }
        }
        return e;
    }
};
```

### 后缀数组
后缀数组的三个核心函数：![image](https://cdn.nlark.com/yuque/__latex/f5f984929117005a694e7dabb1e5a75d.svg)，![image](https://cdn.nlark.com/yuque/__latex/393e1b5695f9739d983203cbc566a78c.svg)表示排名为![image](https://cdn.nlark.com/yuque/__latex/2443fbcfeb7e85e1d62b6f5e4f27207e.svg)的后缀编号，![image](https://cdn.nlark.com/yuque/__latex/ee42375af8bd52f96d9abbe7a4dc5950.svg)表示编号为![image](https://cdn.nlark.com/yuque/__latex/2443fbcfeb7e85e1d62b6f5e4f27207e.svg)的后缀排名，不难发现![image](https://cdn.nlark.com/yuque/__latex/99efaae18e9c43fae499768969ff8e38.svg)和![image](https://cdn.nlark.com/yuque/__latex/13b4eff04139cbd41071f72d62d1f880.svg)互为反函数。![image](https://cdn.nlark.com/yuque/__latex/ac47e11d42ea814604fbbd807ee02383.svg)![image](https://cdn.nlark.com/yuque/__latex/eb7f12f17cd8caedb33366b6d5d4acb5.svg),即两个排名相邻的后缀的![image](https://cdn.nlark.com/yuque/__latex/40d984f1a6cde8eefc078319eb2162ad.svg)。

我们利用倍增+计数排序可以在![image](https://cdn.nlark.com/yuque/__latex/9a4b19897e03daeb7e8beeecf02e82cc.svg)的时间内算出![image](https://cdn.nlark.com/yuque/__latex/f5f984929117005a694e7dabb1e5a75d.svg)

重要性质(常见用法)：

两个后缀的最长公共前缀：![image](https://cdn.nlark.com/yuque/__latex/aa4de461d02091c2ceca4ade206c0ae0.svg)

不同子串数目![image](https://cdn.nlark.com/yuque/__latex/0bac746e0bd6c9f009dc244d3e66436f.svg)，即所有子串数目减去重复子串数目

查找子串及其出现次数：可以在![image](https://cdn.nlark.com/yuque/__latex/763007ec2960297a6f8a75fa1b00c351.svg)数组上二分，复杂度![image](https://cdn.nlark.com/yuque/__latex/68beadb65f90d056f02726f3b7dcf2d5.svg)，

最长重复子串（重叠或不重叠）：利用![image](https://cdn.nlark.com/yuque/__latex/aeb93b257f1c702f3cece3864ddab901.svg)可以直接求得

字符串匹配问题：我们把模式串和匹配串用空格拼在一起，利用![image](https://cdn.nlark.com/yuque/__latex/763007ec2960297a6f8a75fa1b00c351.svg)即可。

最长公共子串：仍然考虑把串拼在一起，利用![image](https://cdn.nlark.com/yuque/__latex/aeb93b257f1c702f3cece3864ddab901.svg)求解

```cpp
struct SuffixArray
{
    const int n; // 字符串长度
    std::vector<int> sa, rk, h; // 后缀数组、排名数组、高度数组

    template <class T>
    SuffixArray(const T &s): n(s.size()), sa(n), rk(n), id(n), tmp(n)
    {
        // 初始化id数组为0~n-1（用于排序下标）
        std::iota(begin(id), end(id), 0); 
        // 初始排名为字符ASCII值
        for (int i = 0; i < n; i++) {
            rk[i] = s[i];
        }
        countSort(); // 第一次计数排序
        
        // 倍增法主循环（按双关键字排序）
        for (int w = 1;; w <<= 1) {
            // 处理长度为w的后缀，构建次关键字（起始位置>=w的后缀，次关键字为前w位的排名）
            std::iota(begin(id), begin(id) + w + 1, n - w); // 初始化次关键字下标（末尾w个元素优先）
            for (int i = 0, p = w; i < n; i++) { // 收集主关键字下标（起始位置<w的后缀，主关键字为当前排名）
                if (sa[i] >= w) { // sa[i]是当前已排序的后缀起始位置
                    id[p++] = sa[i] - w; // 次关键字为sa[i]-w位置的排名（主关键字+w的排名）
                }
            }
            countSort(); // 按双关键字排序
            
            oldrk = rk; // 保存上一轮排名
            
            // 重新计算新排名
            rk[sa[0]] = 0;
            for (int i = 1, p = 0; i < n; i++) {
                // 判断两个后缀是否相等（考虑长度w的双关键字）
                rk[sa[i]] = equal(sa[i], sa[i - 1], w) ? p : ++p;
            }
            
            // 所有排名唯一时终止（已完成所有后缀排序）
            if (rk[sa.back()] + 1 == n) {
                break;
            }
        }
        
        calcHeight(s); // 计算高度数组
    }

private:
    std::vector<int> oldrk, id, tmp, cnt; // 临时数组（旧排名、下标数组、临时存储、计数数组）

    template <class T>
    inline void calcHeight(const T &s)
    {
        h.assign(n, 0); // 初始化高度数组
        for (int i = 0, k = 0; i < n; i++) {
            if (rk[i] == 0) { // 排名为0的后缀是最大的，无前驱后缀
                continue;
            }
            k -= bool(k); // 避免k为0时减1（等价于k = k > 0 ? k-1 : 0）
            // 计算后缀i与前一名后缀（sa[rk[i]-1]）的最长公共前缀
            while (s[i + k] == s[sa[rk[i] - 1] + k]) { // 逐个字符比较
                k += 1;
            }
            h[rk[i]] = k; // 高度数组存储排名为rk[i]的后缀与前一名的LCP
        }
    }

    // 计数排序（用于双关键字排序）
    inline void countSort()
    {
        int m = *std::max_element(begin(rk), end(rk)); // 获取当前最大排名值
        cnt.assign(m + 1, 0); // 计数数组大小为最大排名+1
        // 统计每个排名的出现次数（tmp存储当前下标的排名）
        for (int i = 0; i < n; i++) {
            cnt[tmp[i] = rk[id[i]]] += 1;
        }
        // 计算前缀和（确定排序后位置）
        for (int i = 1; i < cnt.size(); i++) {
            cnt[i] += cnt[i - 1];
        }
        // 逆序填充sa数组（稳定排序）
        for (int i = n - 1; i >= 0; i--) {
            sa[--cnt[tmp[i]]] = id[i]; // 根据排名和计数确定位置
        }
    }

    // 判断两个后缀的前w个字符是否相等（基于旧排名）
    inline bool equal(int x, int y, int w)
    {
        // 获取x和y位置的后缀，长度为w的双关键字排名
        int rkx = (x + w < n ? oldrk[x + w] : -1); // 若越界，视为排名-1（小于任何有效排名）
        int rky = (y + w < n ? oldrk[y + w] : -1);
        // 主关键字（前w长度）和次关键字（后w长度）均相等时视为相等
        return oldrk[x] == oldrk[y] && rkx == rky;
    }
    /**
     * sa[i] -> 第i小的后缀（起始下标）
     * rk[i] -> 后缀i的排名（0~n-1）
     */
};
```


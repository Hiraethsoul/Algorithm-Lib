### 字符串哈希
注意哈希传入的字符串都是$ 1-index $

#### 有序字符串哈希
我们考虑哈希函数为$ f(n)=\sum_{i=1}^{n}s[i]*Base^{n-i} $,那么假设我们预处理出了所有的位置$ i
 $对应的$ f(i) $,

那么$ [l,r] $的哈希值为$ f[r]-f[l-1]*Base^{r-l+1} $

```cpp
struct StringHash
{
    int n;
    std::vector<int> Hash;
    std::vector<int> H;
    int Base, P;
    StringHash(const std::string &s, int Base, int P) : n(s.size()), Hash(n), H(n), Base(Base), P(P) // 默认字符串加了前导字符
    {
        Hash.assign(n, 0);
        H.assign(n, 0);
        Hash[0] = 1;
        for (int i = 1; i <= n - 1; ++i)
        {
            Hash[i] = Hash[i - 1] * Base % P;
        }
        for (int i = 1; i <= n - 1; ++i)
        {
            H[i] = (H[i - 1] * Base % P + s[i]) % P;
        }
    }
    int operator()(int l, int r)
    {
        return (H[r] - H[l - 1] * Hash[r - l + 1] % P + P) % P;
    }
};
```

#### 无序字符串哈希
我们考虑哈希函数为$ f(n)=\sum_{i=1}^n h[s[i]] $，其中$ h[x] $是一个随机的函数，只要保证$ x $相同时$ h[x] $相同即可

```cpp
struct StringHash
{
    int n;
    std::vector<int> Hash;
    std::vector<int> H;
    int Base, P;
    StringHash(std::vector<int> &a, int max, int Base, int P) : n(a.size()), Base(Base), P(P) // 无序哈希
    {
        Hash.assign(max + 1, 0);
        H.assign(n, 0);
        Hash[0] = 1;
        for (int i = 1; i <= max; ++i)
        {
            Hash[i] = Hash[i - 1] * Base % P;
        }
        for (int i = 1; i <= n - 1; ++i)
        {
            H[i] = (H[i - 1] + Hash[a[i]]) % P;
        }
    }
    int operator()(int l, int r)
    {
        return (H[r] - H[l - 1] + P) % P;
    }
};
```

#### 二维有序字符串哈希
```cpp
using u64 = unsigned long long;
struct Hash
{
    int n, m;
    std::vector<u64> hX;//预处理行的Base次幂数组
    std::vector<u64> hY;//预处理列的Base次幂数组
    std::vector<std::vector<u64>> A;//哈希数组
    int P, Q;//两个Base 分别为行和列

    Hash(const std::vector<std::vector<char>> &a, int n, int m, int P, int Q) : n(n), m(m), hX(n + 1), hY(m + 1), P(P), Q(Q)
    {
        A.assign(n + 1, std::vector<u64>(m + 1, 0));
        hX[0] = 1;
        hY[0] = 1;
        for (int i = 1; i <= n; ++i)
        {
            hX[i] = hX[i - 1] * P;
        }
        for (int i = 1; i <= m; ++i)
        {
            hY[i] = hY[i - 1] * Q; 
        }
        for (int i = 1; i <= n; ++i)
        {
            for (int j = 1; j <= m; ++j)
            {
                A[i][j] = A[i][j - 1] * Q + A[i - 1][j] * P - A[i - 1][j - 1] * P * Q + (a[i][j] - 'a' + 1);
            }
        }
    }

    u64 query(int x1, int y1, int x2, int y2)
    {
        return A[x2][y2] - A[x2][y1 - 1] * hY[y2 - y1 + 1] - A[x1 - 1][y2] * hX[x2 - x1 + 1] + A[x1 - 1][y1 - 1] * hX[x2 - x1 + 1] * hY[y2 - y1 + 1];
    }
};
```

### 最小表示法
返回一个字符串字典序最小的循环同构串。

```cpp
std::vector<int> minimalString(std::vector<int> &a)
{
       int n = a.size();
       int i = 0, j = 1, k = 0;
       while (k < n and i < n and j < n)
       {
              if (a[(i + k) % n] == a[(j + k) % n])
              {
                     k++;
              }
              else
              {
                     (a[(i + k) % n] > a[(j + k) % n] ? i : j) += k + 1;
                     i += (i == j);
                     k = 0;
              }
       }
       k = std::min(i, j);
       std::vector<int> ans(n);
       for (int i = 0; i < n; i++)
       {
              ans[i] = a[(i + k) % n];
       }
       return ans;
}
// 直接返回字典序最小循环同构串
```

小Trick：如果我们有一个字符串数组，我们希望按特定的顺序拼起来，使得其字典序最小，我们只需要重载排序函数，方法是$ a+b<b+a $，其中$ a,b $都是字符串类型。

### KMP
对于字符串$ S $，我们通过$ KMP $求出一个$ fail $数组，其中$ fail(i)
 $表示该字符串以$ i $为结尾的前缀串的最长公共前后缀中前缀的结尾位置，其存在的意义是在匹配失败时不要从头开始匹配，例如$ abcabc $中$ fail(5)=2 $，代表我们在5位置匹配失败后可以从2位置继续匹配

但是如果我们有求出$ fail $的办法我们可以用更简单的方法进行字符串匹配，

只需要原串+特殊字符+匹配串，那么如果$ fail[i] $等于原串长度，那么匹配成功

```cpp

class KMP
{

public:
    KMP() {}
    std::vector<int> getPreFunction(std::string &s)
    {
        return kmp(s);
    }
    std::vector<int> getMatchPos(std::string &s, std::string &t)
    {
        std::vector<int> pos;
        auto link = kmp(t + "#" + s); // 在s中找t
        for (int i = t.size() + 1; i < link.size(); i++)
        {
            if (link[i] == t.size())
            {
                pos.push_back(i - 2 * t.size() + 1);
            }
        }
        return pos;
    }

private:
    std::vector<int> kmp(const std::string &s)
    {
        int n = s.size();
        std::vector<int> link(n);
        for (int i = 1, j = 0; i < n; i++)
        {
            while (j and s[i] != s[j])
            {
                j = link[j - 1];
            }
            j += (s[i] == s[j]);
            link[i] = j;
        }
        return link;
    }
};

```

### Z函数（扩展KMP）
对于字符串$ S $，我们可以通过$ Z-function $求出一个$ Z $数组，其中$ Z(i) $表示以$ i $为起点的后缀和原串的最长公共前缀，原理是通过维护一个$ Z-box
 $加速转移

需要注意到的是$ z $函数的返回值中$ z[0]=0 $



具体的说：对于$ i $，我们称区间$ [i,i+z[i]-1] $为$ i $的$ Z-box $，在算法执行过程中我们维护右端点最右的匹配段，我们记作$ [l,r] $，根据定义$ [l,r] $是原串的一个前缀。初始时$ l=r=0 $。

我们从小到大计算$ z[i] $，注意$ z[0]=0 $。

如果$ i<=r $，根据定义有$ s[i,r]=s[i-l,r-l] $,所以$ z[i]>=min(z[i-l],r-i+1) $，那么若$ z[i-l]<r-i+1 $，$ z[i]=z[i-l] $。否则我们让$ z[i]=r-i+1 $,然后我们不断向后暴力拓展。

如果$ i>r $，我们直接暴力匹配求出$ z[i] $

在求出每一个$ z[i] $后，若$ i+z[i]-1>r $，我们更新$ [l,r] $为$ [i,i+z[i]-1] $

```cpp
class ZFunction
{
public:
    ZFunction() {}

    std::vector<int> getZFunction(const std::string &s)
    // 得到单个字符串的z函数值
    {
        return zFunction(s);
    }
    std::vector<int> getMatch(const std::string &s, const std::string &t)
    // 得到字符串s的每一个后缀和t的前缀的匹配结果
    {
        auto z = zFunction(t + "#" + s);
        return std::vector(z.begin() + t.size() + 1, z.end());
    }

private:
    std::vector<int> zFunction(const std::string &s)
    {
        int n = s.size();
        std::vector<int> z(n);
        for (int i = 1, l = 0, r = 0; i < n; i++)
        {
            if (i < r) // 在Z-box内
            {
                z[i] = std::min(z[i - l], r - i);
            }
            while (i + z[i] < n and s[i + z[i]] == s[z[i]]) // 暴力
            {
                z[i]++;
            }
            if (i + z[i] > r) // 更新Z-box
            {
                l = i, r = i + z[i];
            }
        }
        return z;
    }
};

```

### Manacher
类似于$ z-function $的求法，我们同样维护一个加速盒子来加速我们的转移

可以求出字符串每个位置的回文半径长度

```cpp
std::vector<int> manacher(std::string s)
{
    std::string t = "#";
    for (auto c : s)
    {
        t += c;
        t += '#';
    }
    int n = t.size();
    std::vector<int> r(n);
    for (int i = 0, j = 0; i < n; i++)
    {
        if (2 * j - i >= 0 && j + r[j] > i)
        {
            r[i] = std::min(r[2 * j - i], j + r[j] - i);
        }
        while (i - r[i] >= 0 && i + r[i] < n && t[i - r[i]] == t[i + r[i]])
        {
            r[i] += 1;
        }
        if (i + r[i] > j + r[j])
        {
            j = i;
        }
    }
    for (auto &i : r)
    {
        i--;
    }
    return r;
}
```

### 最小循环节
判断一个串是否有长度为$ d $的循环节，我们只需要判断$ [l,r-d] $和$ [l+d,r] $处的串是否相同即可，其中$ l $表示左端点，$ r $表示右端点。

如果要找到最小的循环节，我们考虑到答案一定是$ len $的一个因数，并且由唯一分解定理一定可以表示为$ p_1^{a1} *p_2^{a2}.... $，那么我们对$ len $不断除去它的最小质因数（用欧拉筛处理），同时判断$ ans $除去该质因数是否满足即可，在实现哈希函数后，复杂度为$ O(\sum a) $，即所有质因数的幂之和

```cpp
int findMinimalCycle(std::string s)
{
    int len = s.length();
    s = ' ' + s;
    int l = 1, r = len;
    StringHash hash(s, 13331, 998244353);
    int ans = len;
    while (len != 1)
    {
        int d = ans / minPrimeFactor(len);
        if (hash(l, r - d) == hash(l + d, r))
        {
            ans = d;
        }
        len /= minPrimeFactor(len);
    }
    return ans;
}

```

### Lyndon分解
我们先介绍$ Lyndon $串，为了方便我们用$ s $表示字符串。其定义是$ s $的字典序严格小于$ s $的所有后缀。

我们称一个字符串$ s $的$ Lyndon $分解是指$ s=w_1w_2...w_k $，其中每个$ w $均为$ Lyndon $串且字典序非严格单调减少。

可以证明这样的分解方式存在且唯一。

```cpp
std::vector<int> Lyndon(std::string s) // 分成k个串 满足对每个串满足S(i)>=S(i+1)
// 每个S[i]都是其所有后缀中字典序最小的  也就是所有循环同构串中的最小串
{
    std::vector<int> res; // 存每个串的右端点
    int n = s.length();
    s = ' ' + s;
    for (int i = 1; i <= n;)
    {
        int j = i, k = i + 1; // 初始化
        while (k <= n and s[j] <= s[k])
        {
            if (s[j] < s[k])
            {
                j = i; // 合并为一整个
            }
            else
            {
                j++; // 保持循环不变式
            }
            k++;
        }
        while (i <= j) // 从v的开头重新开始
        {
            res.push_back(i + k - j - 1);
            i += k - j;
        }
    }
    return res;
}
```

### 子序列自动机
子序列自动机即预处理出所有的$ next[i][c] $,其中$ i $表示位置，$ c $表示字符集，朴素做法的复杂度为$ O(nc) $

```cpp
template <int Z, char Base>
struct SubSequenceAutomaton // 每个位置后面每个字母第一次出现的位置
{

    std::vector<std::array<int, Z>> next;
    int n;
    SubSequenceAutomaton(std::string s) : n(s.size() - 1) // 默认s是加过前缀空字符的
    {
        next.resize(n + 1);

        for (int i = 0; i < Z; ++i)
        {
            next[n][i] = n + 1;
        }
        for (int i = n - 1; i >= 0; --i)
        {
            next[i] = next[i + 1];
            next[i][s[i + 1] - Base] = i + 1;
        }
    }
    int getNextPos(int pos, char c)
    {
        return next[pos][c - Base];
    }
};
```

不难发现子序列自动机中每个位置只会有一个字符的值被修改，这启发我们使用主席树优化，这适用于字符集$ c $很大时，同样的我们的查询也会由$ O(1) $变成为$ O(logn) $

```cpp
struct PresidentTree
{
    int idx = 0;
    int n;
    std::vector<int> root, lc, rc;
    std::vector<int> sum;

    void pushup(int u)
    {
        sum[u] = sum[lc[u]] + sum[rc[u]];
    }
    PresidentTree(const std::vector<int> &a, int len) : n(a.size()), root(len + 1), lc(len * 40), rc(len * 40), sum(len * 40)
    { // 传入的a实际上是值域
        std::function<void(int &, int, int)> build = [&](int &u, int l, int r)
        {
            u = ++idx;
            if (l == r)
            {
                sum[u] = a[l];
                return;
            }
            int mid = l + r >> 1;
            build(lc[u], l, mid);
            build(rc[u], mid + 1, r);
            pushup(u);
        };
        build(root[len], 1, n - 1); //  倒着建树 
    }
    void insert(int &u, int v, int l, int r, int pos, int x) // 要插入新版本 所以idx必须++
    {
        u = ++idx; // 一定是直接加 不用判断是不是0
        lc[u] = lc[v];
        rc[u] = rc[v];
        sum[u] = sum[v];
        if (l == r)
        {
            sum[u] = x;
            return;
        }
        int mid = l + r >> 1;
        if (pos <= mid)
        {
            insert(lc[u], lc[v], l, mid, pos, x);
        }
        else
        {
            insert(rc[u], rc[v], mid + 1, r, pos, x);
        }
        pushup(u);
    }

    void insert(int now, int pre, int pos, int x)
    {
        insert(root[now], root[pre], 1, n - 1, pos, x);
    }

    int query(int u, int l, int r, int pos)
    {
        if (l == r)
        {
            return sum[u];
        }
        int mid = l + r >> 1;
        if (pos <= mid)
        {
            return query(lc[u], l, mid, pos);
        }
        else
        {
            return query(rc[u], mid + 1, r, pos);
        }
    }
    int query(int t, int pos)
    {
        return query(root[t], 1, n - 1, pos);
    }
};

// 子序列自动机

struct SubsequenceAutomaton
{
    const std::vector<int> &val;
    PresidentTree Tree;
    int n;
    SubsequenceAutomaton(const std::vector<int> &a, std::vector<int> &init) : val(a), n(a.size() - 1), Tree(init, a.size() - 1)
    {
        for (int i = n - 1; i >= 0; --i)
        {
            Tree.insert(i, i + 1, val[i + 1], i + 1); // 更新子序列自动机
        }
    }
    int query(int pos, int val) // pos后面第一个val的位置
    {
        return Tree.query(pos, val);
    }
};

```

### AC自动机
AC自动机即在$ trie $树的基础上补成一个$ trie $有向图，并求出$ fail $指针，$ trie $图的意义在于，它借助$ fail $指针补上了能继续匹配下去的边，$ fail $指针的意义是指向最长的相等后缀，如果我们当前$ ch[p][c] $没有出边，我们就考虑$ ch[fail[p]][c] $即可。

$ fail $树的意义在于，如果节点$ P

 $出现过那么所有的$ fail $也将出现，注意我们的$ fail $树和$ trie $树共用所有点但不共用边，换句话说，$ fail $树独立在$ trie
 $图以外 

我们考虑一个串在$ trie $图上走的意义，首先建图方式保证了我们走图的最优性，什么叫最优性呢，也就是说在走不下去时会找到最长的后缀继续走下去。我们每走到一个点，该点在$ fail $树上的每个祖先都会出现一次，由于最优性保证了不重不漏。因此多模式匹配的做法就是，先在$ trie $图上跑完整个串，对于每个到达的节点都标记一次贡献。然后我们利用$ dfs $或者$ toposort $的方式自下而上合并，把所有贡献合并给其祖先即可，此时每个节点的权值就代表了它出现的次数。

```cpp
template <int Z, char Base>
struct AcAutomaton
{
    std::vector<int> fail; // fail指针
    std::vector<std::vector<int>> ch;
    std::vector<std::vector<int>> ID;
    int idx = 0;
    int sum = 0;
    int n;

    AcAutomaton(std::vector<std::string> &s) : n(s.size())
    {
        for (auto x : s)
        {
            sum += x.size();
        }
        ch.assign(sum + 1, std::vector<int>(Z, 0));
        fail.resize(sum + 1);
        ID.resize(sum + 1);
        for (int i = 0; i < n; ++i)
        {
            insert(i, s[i]);
        }
        build();
    }

    void insert(int id, std::string s)
    {
        int p = 0;
        for (auto j : s)
        {
            j -= Base;
            if (!ch[p][j])
            {
                ch[p][j] = ++idx;
            }
            p = ch[p][j];
        }
        ID[p].push_back(id);
    }

    void build()
    {
        std::queue<int> q;
        for (int i = 0; i < 26; ++i)
        {
            if (ch[0][i])
            {
                q.push(ch[0][i]);
            }
        }
        while (q.size())
        {
            int u = q.front();
            q.pop();
            for (int i = 0; i < 26; ++i)
            {
                int v = ch[u][i];
                if (v)
                {
                    fail[v] = ch[fail[u]][i]; // fail指针回跳边
                    q.push(v);
                }
                else
                {
                    ch[u][i] = ch[fail[u]][i]; // 横插边
                }
            }
        }
    }
};

```

### 后缀自动机
后缀自动机是一个$ DAG+fail $树,我们假设$ t0 $为初始状态，$ t0 $到每个结束节点都是原串的一个后缀，原串的每个子串都可以通过$ t0 $到某个节点得到。可以证明，$ endpos $等价类要么包含要么完全不交，我们$ fail $指针的意义是，指向最长的后缀且满足$ endpos $类是我的超集,$ len $是当前节点代表的最长串，在$ fail $树上，父节点代表的最长串是子节点最短串的最长后缀



我们需要注意的是

$ cnt $数组只有在加新字符才更新，但分裂节点是不更新的，所以cnt数组实际上是个01数组

我们通过$ dfs $$ fail $树合并$ cnt $数组得到$ endpos $的大小

特别的当字符集很大时，我们把$ vector $换成哈希表



我们考虑题目的两种处理方法，即考虑$ ch $数组或者考虑$ fail $树，换句话说分为考虑路径和考虑点，因为$ DAG
 $和树都具有很好的性质

第一种情况，我们考虑路径，也就是说我们的所有子串都是一个固定起点的路径，我们可以在$ DAG $上$ DP $出想要的信息，例如我们求一个节点经过的不同子串数量实际上是DAG后继路径的数量，如果求经过这个点的所有子串数量，那么就是后继路径$ |endpos| $的和，用于处理子串第$ k
 $大相关问题

第二种情况，我们考虑点，在$ fail $树上我们的子串信息被高度压缩,每个节点代表$ endpos $相同的一类长度连续的子串，也就是说，他们从小到大是彼此的后缀。

```cpp
template <int Z, char Base>
struct Sam
{
    // 转移函数，ch[u][c]表示从状态u经过字符c转移到的状态
    std::vector<std::array<int, Z>> ch;

    std::vector<std::vector<int>> g;
    // fail指针(后缀链接)，len[u]表示状态u代表的最长子串长度
    std::vector<int> fail, len;
    // 点u表示的串长范围是 [len[fail[u]]+1,len[u]]

    // 如果我们在fail树上dfs合并cnt[u],那么cnt[u]表示状态u的endpos集合大小,也就是串的出现次数
    std::vector<long long> cnt;

    int last;      // 上一个添加的状态
    int tot;       // 总状态数
    long long num; // 不同子串的数量

    // 构造函数，预分配空间
    Sam(int n) : ch((n + 1) << 1), fail((n + 1) << 1), len((n + 1) << 1), g(n + 1 << 1)
    {
        cnt.assign((n + 1) << 1, 0);
        last = tot = 1; // 初始状态为1
        fail[1] = -1;   // 根节点的fail指针设为-1
        num = 0;
    }

    // 从字符串构造SAM
    Sam(const std::string &s) : Sam(s.size())
    {
        for (char c : s)
        {
            add(c);
        }
        for (int i = 2; i <= tot; ++i)
        {
            g[fail[i]].push_back(i); // fail树
        }
    }

    // 向SAM中添加一个字符
    void add(char c)
    {
        c -= Base; // 将字符映射到[0,Z)范围

        // 创建新状态cur
        int cur = ++tot;
        len[cur] = len[last] + 1;         // 新状态代表的最长子串长度
        cnt[cur] = 1;                     // 新状态的endpos集合大小为1
        num += len[cur] - len[fail[cur]]; // 更新不同子串数量

        // 从last状态开始，沿着fail指针向上跳转
        int v = last;
        while (v != -1 && !ch[v][c])
        {
            ch[v][c] = cur; // 设置转移
            v = fail[v];    // 跳转到fail指针指向的状态
        }

        if (v == -1)
        {
            // 如果跳转到了初始状态，设置fail指针为根状态1
            fail[cur] = 1;
        }
        else
        {
            int q = ch[v][c];
            if (len[v] + 1 == len[q])
            {
                // 如果q正好是v的直接扩展，直接设置fail指针
                fail[cur] = q;
            }
            else
            {
                // 否则需要克隆状态q
                int clone = ++tot;
                len[clone] = len[v] + 1;
                ch[clone] = ch[q];     // 复制转移函数
                fail[clone] = fail[q]; // 复制fail指针

                // 更新所有指向q的转移
                while (v != -1 && ch[v][c] == q)
                {
                    ch[v][c] = clone;
                    v = fail[v];
                }

                // 更新q和cur的fail指针
                fail[q] = fail[cur] = clone;
            }
        }

        last = cur; // 更新last状态
    }
};
```

#### 动态树维护后缀自动机
因为$ LCT $可以动态维护树的形态，我们常常用$ LCT $来维护$ fail $树。由于$ LCT $可以维护链上信息，也可维护子树信息，也分两种写法，主要在于如何正确修改$ Sam $中的$ add $函数

##### 维护链上信息
十分重要的是在这种做法下我们在分裂节点时需要$ splay(q) $,然后把这个点的信息$ clone
 $到分裂出的新节点上，为什么呢？因为我们之前链加到该点的信息在克隆新点后，对新点仍然有效，于是不能丢失

```cpp
    //把fail树的根节点调为1
    void add(char c)
    {
        c -= Base;
        int cur = ++tot;
        // 在此对 cur 加信息
        len[cur] = len[last] + 1; // 节点代表的字符串长度的取值范围是(len[fa[i]],len[i]] 且每个长度都出现一次 endpos等价类
        int v = last;
        while (v != -1 and !ch[v][c])
        {
            ch[v][c] = cur, v = fail[v];
        }

        if (v == -1)
        {
            fail[cur] = 1;
            lct.link(cur, fail[cur]);
        }
        else
        {
            int q = ch[v][c];
            if (len[v] + 1 == len[q])
            {
                fail[cur] = q;
                lct.link(cur, fail[cur]);
            }
            else
            {
                int cl = ++tot;
                len[cl] = len[v] + 1;
                fail[cl] = fail[q];
                ch[cl] = ch[q];
                lct.link(cl, fail[cl]);

                lct.splay(q);           // clone节点时要保存lct的信息
                lct.tr[cl] = lct.tr[q]; // 如果是链加我需要保存节点信息

                while (v != -1 and ch[v][c] == q)
                {
                    ch[v][c] = cl, v = fail[v];
                }
                fail[cur] = cl;
                lct.link(cur, fail[cur]);

                lct.cut(q, fail[q]);
                fail[q] = cl;
                lct.link(q, fail[q]);
            }
        }
        last = cur;
        //在链上加信息，lct.add(1, cur, 1);//直接链加，查询就是单点查
    }
};
```

##### 维护子树信息
在维护子树和的情况下，我们直接把$ SAM
 $中的连边断边改为$ LCT $即可，不需要在$ clone $节点时维护额外的信息

我们把链加做法中的$ splay(q),tr[cl]=tr[q] $删去即可

### 广义后缀自动机
广义后缀自动机是为了解决多个串的信息而出现的，其本质是在$ Trie $树上建后缀自动机

```cpp
template <int Z, char Base>
struct ExSam
{
    std::vector<std::array<int, Z>> ch;       // 转移数组，存储每个状态的字符转移（大小为字符集Z）
    std::vector<int> len, fail;               // len: 状态代表的最长子串长度；fail: 失败指针（后缀链接）
    std::vector<std::vector<int>> ID;         // ID[p][i]: 状态p在第i个字符串中的出现次数
    std::vector<std::vector<int>> g;          // fail树的邻接表（用于后续DFS统计）
    int cnt;                                  // 字符串数量

    int tot = 0, last = 0;                    // tot: 总状态数；last: 当前最后一个状态
    long long num = 0;                        // 总不同子串数（未在代码中完全使用）

    // 构造函数：接收多个字符串，构建扩展后缀自动机
    ExSam(const std::vector<std::string> &S)
    {
        cnt = S.size();                        // 字符串数量
        int LEN = 0;
        for (const auto &str : S)              // 计算所有字符串总长度（预估空间）
        {
            LEN += str.size();
        }

        // 初始化数组大小（预分配足够空间）
        len.resize(LEN << 1);                  // 长度设为总长度2倍，避免动态扩容
        fail.resize(LEN << 1);
        fail[0] = -1;                          // 初始状态的fail指针设为-1（根节点）
        ch.resize(LEN << 1);
        g.resize(LEN << 1);
        // 初始化每个状态在各字符串中的出现次数（初始为0）
        for (int i = 0; i < LEN << 1; i++) {
            ID.emplace_back(cnt, 0);
        }

        for (int i = 0; i < S.size(); i++)     // 逐个处理每个字符串
        {
            last = 0;                           // 每个字符串处理时，从根节点开始
            for (char c : S[i])                 // 逐个字符添加到后缀自动机
            {
                exadd(c, i);                    // 核心添加字符函数，i为当前字符串索引
            }
        }
    }

    // 深度优先搜索fail树，统计每个状态在各字符串中的出现次数（自底向上累加）
    void dfs(int u)
    {
        for (auto v : g[u])                    // 遍历u的所有子节点（fail树的子节点）
        {
            dfs(v);                             // 递归处理子节点
            // 将子节点v的统计结果累加到父节点u
            for (int i = 0; i < cnt; ++i)
            {
                ID[u][i] += ID[v][i];
            }
        }
    }

    // 检查状态p是否在所有字符串中出现过（即每个字符串的ID[p][i]均非零）
    bool check(int p) 
    {
        for (int i = 0; i < cnt; ++i)
        {
            if (!ID[p][i])                     // 只要有一个字符串未出现，返回false
            {
                return false;
            }
        }
        return true;
    }

    // 查询多个字符串的最长公共子串长度（参数s可任选其中一个字符串）
    int querylen(std::string s) 
    {
        // 构建fail树的邻接表（每个节点的fail指针指向父节点）
        for (int i = 1; i <= tot; ++i)
        {
            g[fail[i]].push_back(i);           // fail[i]是i的父节点，添加边fail[i]->i
        }
        dfs(0);                                // 从根节点开始DFS，统计各状态的出现次数

        int p = 0, now = 0, res = 0;           // p: 当前状态；now: 当前匹配长度；res: 最长匹配长度
        for (auto c : s)                       // 遍历字符串s的每个字符
        {
            c -= Base;                          // 字符映射到0~Z-1的范围（与模板参数Base一致）

            // 情况1：当前状态p存在字符c的转移，且该转移状态在所有字符串中出现过
            if (check(ch[p][c]))               
            {
                p = ch[p][c];                   // 转移到子状态
                now++;                          // 匹配长度+1
            }
            else                                // 情况2：不存在合法转移，需跳fail指针
            {
                // 沿着fail指针回溯，直到找到合法转移或根节点
                while (p != -1 && !check(ch[p][c]))
                {
                    p = fail[p];
                }
                if (p == -1)                    // 回溯到根节点仍无合法转移，重置匹配长度
                {
                    now = 0;
                    p = 0;
                }
                else                            // 找到合法转移，更新匹配长度为当前状态长度+1
                {
                    now = len[p] + 1;
                    p = ch[p][c];
                }
            }
            res = std::max(res, now);           // 更新最长匹配长度
        }
        return res;
    }

private:
    // 给状态cur标记属于字符串id（出现次数+1）
    void assign(int cur, int id)
    {
        ID[cur][id]++;                         // 记录状态cur在第id个字符串中出现过
    }

    // 核心函数：向后缀自动机中添加字符c（属于字符串id）
    void exadd(char c, int id)
    {
        c -= Base;                             // 字符映射

        // 情况1：当前last状态存在c的转移
        if (ch[last][c])
        {
            int v = last;                      // v = last
            int q = ch[v][c];                  // q是v通过c转移的目标状态

            // 如果q的长度不等于v的长度+1（说明q是克隆节点）
            if (len[q] != len[v] + 1)
            {
                // 创建克隆节点cl（复制q的属性，但长度为v+1）
                int cl = ++tot;
                len[cl] = len[v] + 1;          // 克隆节点的长度为v的长度+1
                fail[cl] = fail[q];            // 克隆节点的fail指向q的fail
                ch[cl] = ch[q];                // 克隆节点的转移复制q的转移

                // 将v及其祖先中所有指向q的转移改为指向cl
                while (v != -1 && ch[v][c] == q)
                {
                    ch[v][c] = cl;
                    v = fail[v];
                }
                fail[q] = cl;                  // q的fail指向克隆节点cl
                q = cl;                        // q更新为克隆节点
            }
            // 更新last为q，并标记q属于当前字符串id
            int cur = last = q;
            assign(cur, id);
            return;
        }

        // 情况2：当前last状态不存在c的转移，创建新状态cur
        int cur = ++tot;                       // 新建状态cur
        len[cur] = len[last] + 1;              // cur的长度为last的长度+1
        assign(cur, id);                       // 标记cur属于当前字符串id

        int v = last;                          // v = last，从last开始回溯
        // 沿着fail指针找到第一个存在c转移的状态v，或根节点
        while (v != -1 && ch[v][c] == 0)
        {
            ch[v][c] = cur;                    // 设置v到cur的转移
            v = fail[v];                       // 回溯到v的fail
        }
        if (v == -1)                           // 回溯到根节点，cur的fail指向根节点（0）
        {
            fail[cur] = 0;
        }
        else                                    // 找到存在c转移的状态v，其转移目标为q
        {
            int q = ch[v][c];
            if (len[q] == len[v] + 1)          // q是正常扩展的状态，cur的fail指向q
            {
                fail[cur] = q;
            }
            else                                // q是旧状态，需要创建克隆节点cl
            {
                int cl = ++tot;
                len[cl] = len[v] + 1;          // 克隆节点cl的长度为v的长度+1
                fail[cl] = fail[q];            // cl的fail指向q的fail
                ch[cl] = ch[q];                // cl的转移复制q的转移

                // 将v及其祖先中所有指向q的转移改为指向cl
                while (v != -1 && ch[v][c] == q)
                {
                    ch[v][c] = cl;
                    v = fail[v];
                }
                fail[q] = fail[cur] = cl;       // q和cur的fail均指向cl
            }
        }
        last = cur;                            // 更新last为当前新状态cur
        num += len[cur] - len[fail[cur]];      // 统计新增的不同子串数（未在查询中使用）
    }
};
```

### 回文自动机
为了分别表示奇回文串和偶回文串，回文自动机是两棵树加$ fail $指针的结构。我们不妨设左树维护偶回文串，根节点为$ 0 $，右树维护奇回文串，根节点为$ 1 $。特别的，$ 0 $的$ fail $指针指向$ 1 $

自动机上每个节点都代表一个回文串，如果$ i $点代表的串为$ S $，那么点$ i $经字符$ c $的边到达的节点为$ cSc $，其中$ fail $指向最长的回文后缀。

```cpp
template <int Z, char Base>
struct Pam
{
    std::vector<std::array<int, Z>> ch;   // 转移数组，存储每个节点的子节点
    std::vector<int> fail, len, dep, cnt; // fail指针数组，回文长度数组，深度数组，计数器
    std::string s;                        // 存储添加的字符

    int cur = 0, tot = 1; // 当前节点和总节点数，初始有两个节点：0（偶长度根）和1（奇长度根）

    // 构造函数，初始化数组大小
    Pam(int n) : ch(n + 2), fail(n + 2), len(n + 2), dep(n + 2), cnt(n + 2)
    {
        fail[0] = 1; // 偶长度根的fail指向奇长度根
        len[1] = -1; // 奇长度根的回文长度为-1，作为特殊标记
    }

    // 用字符串初始化的构造函数
    Pam(const std::string &s) : Pam(s.size())
    {
        for (int i = 0; i < s.size(); i++)
        {
            add(i, s[i]); // 逐个添加字符
        }
    }

    // 节点计数函数，可用于统计每个回文子串的出现次数
    void assign(int cur, int id)
    {
        cnt[cur]++;
    }

    // 获取当前节点的fail指针
    int getfail(int x, int i)
    {
        // 循环找到第一个满足条件的fail节点
        while (i - len[x] - 1 < 0 or s[i - len[x] - 1] != s[i])
        {
            x = fail[x];
        }
        return x;
    }

    // 添加字符到PAM
    void add(int i, char c)
    {
        c -= Base;      // 字符映射到0-Z范围内
        s.push_back(c); // 添加到字符串

        int v = getfail(cur, i); // 获取当前节点的fail节点

        // 如果该转移不存在，则创建新节点
        if (!ch[v][c])
        {
            fail[++tot] = ch[getfail(fail[v], i)][c]; // 设置新节点的fail指针
            ch[v][c] = tot;                           // 设置转移
            len[tot] = len[v] + 2;                    // 新节点的回文长度
            dep[tot] = dep[fail[tot]] + 1;            // 新节点的深度
        }

        cur = ch[v][c]; // 更新当前节点
        assign(cur, i); // 更新计数
    }

    // 获取fail树的邻接表表示，根节点为1
    auto getfailTree() const
    {
        std::vector e(tot + 1, std::vector<int>());
        for (int i = 0; i <= tot; i++)
        {
            if (i != 1) // 跳过根节点
            {
                e[fail[i]].emplace_back(i); // 添加边
            }
        }
        return e;
    }
};
```

### 后缀数组
后缀数组的三个核心函数：$ sa,rk,height $，$ sa[i] $表示排名为$ i $的后缀编号，$ rk[i] $表示编号为$ i $的后缀排名，不难发现$ sa $和$ rk
 $互为反函数。$ height[i] $$ =lcp(sa[i],sa[i-1]) $,即两个排名相邻的后缀的$ lcp $。

我们利用倍增+计数排序可以在$ O(nlogn) $的时间内算出$ sa,rk,height $

重要性质(常见用法)：

两个后缀的最长公共前缀：$ LCP(sa[i],sa[j])=min_{x=i+1}^jheight[x] $

不同子串数目$ num=n*(n+1)/2-\sum_{i=2}^n height[i] $，即所有子串数目减去重复子串数目

查找子串及其出现次数：可以在$ rank $数组上二分，复杂度$ logn*|S| $，

最长重复子串（重叠或不重叠）：利用$ height $可以直接求得

字符串匹配问题：我们把模式串和匹配串用空格拼在一起，利用$ rank $即可。

最长公共子串：仍然考虑把串拼在一起，利用$ height $求解

```cpp
struct SuffixArray
{
    const int n; // 字符串长度
    std::vector<int> sa, rk, h; // 后缀数组、排名数组、高度数组

    template <class T>
    SuffixArray(const T &s): n(s.size()), sa(n), rk(n), id(n), tmp(n)
    {
        // 初始化id数组为0~n-1（用于排序下标）
        std::iota(begin(id), end(id), 0); 
        // 初始排名为字符ASCII值
        for (int i = 0; i < n; i++) {
            rk[i] = s[i];
        }
        countSort(); // 第一次计数排序
        
        // 倍增法主循环（按双关键字排序）
        for (int w = 1;; w <<= 1) {
            // 处理长度为w的后缀，构建次关键字（起始位置>=w的后缀，次关键字为前w位的排名）
            std::iota(begin(id), begin(id) + w + 1, n - w); // 初始化次关键字下标（末尾w个元素优先）
            for (int i = 0, p = w; i < n; i++) { // 收集主关键字下标（起始位置<w的后缀，主关键字为当前排名）
                if (sa[i] >= w) { // sa[i]是当前已排序的后缀起始位置
                    id[p++] = sa[i] - w; // 次关键字为sa[i]-w位置的排名（主关键字+w的排名）
                }
            }
            countSort(); // 按双关键字排序
            
            oldrk = rk; // 保存上一轮排名
            
            // 重新计算新排名
            rk[sa[0]] = 0;
            for (int i = 1, p = 0; i < n; i++) {
                // 判断两个后缀是否相等（考虑长度w的双关键字）
                rk[sa[i]] = equal(sa[i], sa[i - 1], w) ? p : ++p;
            }
            
            // 所有排名唯一时终止（已完成所有后缀排序）
            if (rk[sa.back()] + 1 == n) {
                break;
            }
        }
        
        calcHeight(s); // 计算高度数组
    }

private:
    std::vector<int> oldrk, id, tmp, cnt; // 临时数组（旧排名、下标数组、临时存储、计数数组）

    template <class T>
    inline void calcHeight(const T &s)
    {
        h.assign(n, 0); // 初始化高度数组
        for (int i = 0, k = 0; i < n; i++) {
            if (rk[i] == 0) { // 排名为0的后缀是最大的，无前驱后缀
                continue;
            }
            k -= bool(k); // 避免k为0时减1（等价于k = k > 0 ? k-1 : 0）
            // 计算后缀i与前一名后缀（sa[rk[i]-1]）的最长公共前缀
            while (s[i + k] == s[sa[rk[i] - 1] + k]) { // 逐个字符比较
                k += 1;
            }
            h[rk[i]] = k; // 高度数组存储排名为rk[i]的后缀与前一名的LCP
        }
    }

    // 计数排序（用于双关键字排序）
    inline void countSort()
    {
        int m = *std::max_element(begin(rk), end(rk)); // 获取当前最大排名值
        cnt.assign(m + 1, 0); // 计数数组大小为最大排名+1
        // 统计每个排名的出现次数（tmp存储当前下标的排名）
        for (int i = 0; i < n; i++) {
            cnt[tmp[i] = rk[id[i]]] += 1;
        }
        // 计算前缀和（确定排序后位置）
        for (int i = 1; i < cnt.size(); i++) {
            cnt[i] += cnt[i - 1];
        }
        // 逆序填充sa数组（稳定排序）
        for (int i = n - 1; i >= 0; i--) {
            sa[--cnt[tmp[i]]] = id[i]; // 根据排名和计数确定位置
        }
    }

    // 判断两个后缀的前w个字符是否相等（基于旧排名）
    inline bool equal(int x, int y, int w)
    {
        // 获取x和y位置的后缀，长度为w的双关键字排名
        int rkx = (x + w < n ? oldrk[x + w] : -1); // 若越界，视为排名-1（小于任何有效排名）
        int rky = (y + w < n ? oldrk[y + w] : -1);
        // 主关键字（前w长度）和次关键字（后w长度）均相等时视为相等
        return oldrk[x] == oldrk[y] && rkx == rky;
    }
    /**
     * sa[i] -> 第i小的后缀（起始下标）
     * rk[i] -> 后缀i的排名（0~n-1）
     */
};
```

## ****

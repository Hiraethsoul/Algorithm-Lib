## 线段树
#### 维护区间最值
```cpp
template <class T>
class RMQSegmentTree
{
#define lc u << 1
#define rc u << 1 | 1
    const T inf = std::numeric_limits<T>::max() / 2;

public:
    struct Node
    {
        int l, r;
        T max, min;
    };
    RMQSegmentTree(const std::vector<T> &a) : n(a.size()), tr(4 * n)
    {
        n--;
        std::function<void(int, int, int)> build = [&](int u, int l, int r)
        {
            tr[u] = {l, r, a[l], a[l]};
            if (l == r)
            {
                return;
            }
            int mid = l + r >> 1;
            build(lc, l, mid);
            build(rc, mid + 1, r);
            pushup(u);
        };
        build(1, 1, n);
    }
    void singleChange(int pos, T val)
    {
        singleChange(1, 1, n, pos, val);
    }
    T rangeQueryMax(int l, int r)
    {
        return rangeQueryMax(1, 1, n, l, r);
    }
    T rangeQueryMin(int l, int r)
    {
        return rangeQueryMin(1, 1, n, l, r);
    }

private:
    int n;
    std::vector<Node> tr;
    void pushup(int u)
    {
        tr[u].max = std::max(tr[lc].max, tr[rc].max);
        tr[u].min = std::min(tr[lc].min, tr[rc].min);
    }

    void singleChange(int u, int l, int r, int x, T y)
    {
        if (l == r)
        {
            tr[u].max = tr[u].min = y;
            return;
        }
        int mid = l + r >> 1;
        if (x <= mid)
        {
            singleChange(lc, l, mid, x, y);
        }
        else
        {
            singleChange(rc, mid + 1, r, x, y);
        }
        pushup(u);
    }
    T rangeQueryMax(int u, int l, int r, int x, int y)
    {
        if (x <= l && y >= r)
        {
            return tr[u].max;
        }
        int mid = l + r >> 1;
        T res = -inf;
        if (x <= mid)
        {
            res = std::max(res, rangeQueryMax(lc, l, mid, x, y));
        }
        if (y > mid)
        {
            res = std::max(res, rangeQueryMax(rc, mid + 1, r, x, y));
        }
        return res;
    }
    T rangeQueryMin(int u, int l, int r, int x, int y)
    {
        if (x <= l && y >= r)
        {
            return tr[u].min;
        }
        int mid = l + r >> 1;
        T res = inf;
        if (x <= mid)
        {
            res = std::min(res, rangeQueryMin(lc, l, mid, x, y));
        }
        if (y > mid)
        {
            res = std::min(res, rangeQueryMin(rc, mid + 1, r, x, y));
        }
        return res;
    }
};
```

#### 维护区间修改
```cpp

template <class T>
class SegmentTree
{
#define lc u << 1
#define rc u << 1 | 1
public:
    struct Node
    {
        int l, r;
        T add, sum;
    };

    SegmentTree(const std::vector<T> &a) : n(a.size()), tr(4 * n)
    {
        n--;
        std::function<void(int, int, int)> build = [&](int u, int l, int r)
        {
            tr[u] = {l, r, 0, a[l]};
            if (l == r)
            {
                return;
            }
            int mid = l + r >> 1;
            build(lc, l, mid);
            build(rc, mid + 1, r);
            pushup(u);
        };
        build(1, 1, n);
    }
    void rangeAdd(int l, int r, T val)
    {
        rangeAdd(1, 1, n, l, r, val);
    }
    T rangeQuerySum(int l, int r)
    {
        return rangeQuerySum(1, 1, n, l, r);
    }

private:
    int n;
    std::vector<Node> tr;
    void pushup(int u)
    {
        tr[u].sum = tr[lc].sum + tr[rc].sum;
    }
    void pushdown(Node &u, T add)
    {
        u.sum += add * (u.r - u.l + 1);
        u.add += add;
    }
    void pushdown(int u)
    {
        if (tr[u].add)
        {
            pushdown(tr[lc], tr[u].add);
            pushdown(tr[rc], tr[u].add);
            tr[u].add = 0;
        }
    }
    void rangeAdd(int u, int l, int r, int x, int y, T k)
    {
        if (x <= l && y >= r)
        {
            pushdown(tr[u], k);
            return;
        }
        int mid = l + r >> 1;
        pushdown(u);
        if (x <= mid)
        {
            rangeAdd(lc, l, mid, x, y, k);
        }
        if (y > mid)
        {
            rangeAdd(rc, mid + 1, r, x, y, k);
        }
        pushup(u);
    }
    T rangeQuerySum(int u, int l, int r, int x, int y)
    {
        if (x <= l && y >= r)
        {
            return tr[u].sum;
        }
        int mid = l + r >> 1;
        pushdown(u);
        T res = 0;
        if (x <= mid)
        {
            res += rangeQuerySum(lc, l, mid, x, y);
        }
        if (y > mid)
        {
            res += rangeQuerySum(rc, mid + 1, r, x, y);
        }
        return res;
    }
};
```

乘标记和加标记的处理方法：

区间乘和区间加两个操作，关键在于维护乘法标记和加法标记之间的关系

具体地说，我们在下传标记时，采用的计算和的方法为![image](https://cdn.nlark.com/yuque/__latex/cbbf4761b94444051ec5e90fe1d9e34e.svg)，那么我们就要保证下传标记的时候正确操作，即![image](https://cdn.nlark.com/yuque/__latex/1d19b58f9864e03822771165dab68b35.svg),![image](https://cdn.nlark.com/yuque/__latex/f7014f7d795c75c9cd2162e2dd9faf52.svg)

覆盖标记和加标记的处理方法：

区间覆盖和区间加，关键在于懒标记之间的清除关系，在我们操作![image](https://cdn.nlark.com/yuque/__latex/8c7a5bbfa95ebd42fdb35f17d6e00cc4.svg)标记时，要清空对应位置的![image](https://cdn.nlark.com/yuque/__latex/7dd2af96399916d1009e67e99e1f60eb.svg)标记，这样才能保证信息维护的正确性。具体来讲，什么叫清空对应位置的![image](https://cdn.nlark.com/yuque/__latex/2a11d10e5f1c1b171f06c38c6dfadab6.svg)标记呢？也就是说，一旦我们更新了![image](https://cdn.nlark.com/yuque/__latex/0a25ff5d5f49aeb7283b1b06cf5b55d5.svg)位置的![image](https://cdn.nlark.com/yuque/__latex/8c7a5bbfa95ebd42fdb35f17d6e00cc4.svg)信息，我们就要立刻把![image](https://cdn.nlark.com/yuque/__latex/77c3adce895348f6083c425fe1ba2624.svg)位置的![image](https://cdn.nlark.com/yuque/__latex/2a11d10e5f1c1b171f06c38c6dfadab6.svg)信息清除掉，因为显然他不会再起到作用，而且在![image](https://cdn.nlark.com/yuque/__latex/17a0042cf8bb0b5dac93b7dea1780afe.svg)的时候我们要先处理![image](https://cdn.nlark.com/yuque/__latex/8c7a5bbfa95ebd42fdb35f17d6e00cc4.svg)标记，原因仍然是我们可能会清除![image](https://cdn.nlark.com/yuque/__latex/2a11d10e5f1c1b171f06c38c6dfadab6.svg)标记

#### 维护最大子段和
支持单点修改和区间查询最大子段和，不支持区间修改操作。

```cpp
template <class T>
class SegmentTree
{
#define lc u << 1
#define rc u << 1 | 1

public:
    struct Node
    {
        int l, r;
        T sum, lmax, rmax, max;
    };
    SegmentTree(const std::vector<T> &a) : n(a.size()), tr(n * 4)
    {
        n--;
        std::function<void(int, int, int)> build = [&](int u, int l, int r)
        {
            tr[u] = {l, r, a[l], a[l], a[l], a[l]};
            if (l == r)
            {
                return;
            }
            int mid = l + r >> 1;
            build(lc, l, mid);
            build(rc, mid + 1, r);
            pushup(tr[u], tr[lc], tr[rc]);
        };
        build(1, 1, n);
    }
    T rangeQuery(int x, int y)
    {
        Node ans = rangeQuery(1, 1, n, x, y);
        return ans.max;
    }

private:
    int n;
    std::vector<Node> tr;

    void pushup(Node &u, Node l, Node r)
    {
        u.sum = l.sum + r.sum;
        u.lmax = std::max(l.lmax, l.sum + r.lmax);
        u.rmax = std::max(r.rmax, r.sum + l.rmax);
        u.max = std::max({l.max, r.max, l.rmax + r.lmax});
    }

    Node rangeQuery(int u, int l, int r, int x, int y)
    {
        if (x <= l && y >= r)
        {
            return tr[u];
        }
        int mid = l + r >> 1;
        if (y <= mid)
        {
            return rangeQuery(lc, l, mid, x, y);
        }
        if (x > mid)
        {
            return rangeQuery(rc, mid + 1, r, x, y);
        }
        Node t;
        pushup(t, rangeQuery(lc, l, mid, x, y), rangeQuery(rc, mid + 1, r, x, y));
        return t;
    }
};
```

#### 动态开点
往往我们的序列非常大，但大多数为空，我们并不需要维护整个序列的信息，因此我们可以采用动态开空间的方法，于是有动态开点线段树，具体的说，就是用到哪里的空间就开哪里的空间,我们每需要访问一个节点![image](https://cdn.nlark.com/yuque/__latex/77c3adce895348f6083c425fe1ba2624.svg)，假如节点![image](https://cdn.nlark.com/yuque/__latex/77c3adce895348f6083c425fe1ba2624.svg)尚未分配空间，我们手动为其开空间即可，因为操作次数往往有限，每次操作我们最多开![image](https://cdn.nlark.com/yuque/__latex/ff4edff51773a4560f25e8eab96349ff.svg)的空间，所以空间复杂度是![image](https://cdn.nlark.com/yuque/__latex/257e5b30f34599d4250927ad3a06f277.svg)的

```cpp

template <class T>
class SegmentTree
{
public:
    SegmentTree(int capacity, int min, int max) : max(max), min(min)
    {
        lc.assign(capacity + 1, 0);
        rc.assign(capacity + 1, 0);
        sum.assign(capacity + 1, 0);
        add.assign(capacity + 1, 0);
    }

    void rangeAdd(int l, int r, T val)
    {
        rangeAdd(root, min, max, l, r, val);
    }
    T rangeQuerySum(int l, int r)
    {
        return rangeQuerySum(root, min, max, l, r);
    }

private:
    int min,
        max;
    int tot = 0;
    int root = 0;
    std::vector<int> lc, rc;
    std::vector<T> sum, add;
    void pushup(int u)
    {
        sum[u] = sum[lc[u]] + sum[rc[u]];
    }
    void pushdown(int u, int l, int r)
    {
        if (add[u])
        {
            lc[u] = (lc[u] ? lc[u] : ++tot);
            rc[u] = (rc[u] ? rc[u] : ++tot);
            int mid = l + r >> 1;
            sum[lc[u]] += (mid - l + 1) * add[u];
            sum[rc[u]] += (r - mid) * add[u];
            add[lc[u]] += add[u];
            add[rc[u]] += add[u];
            add[u] = 0;
        }
    }
    void rangeAdd(int &u, int l, int r, int x, int y, T val)
    { // 区修
        if (!u)
        {
            u = ++tot; // 动态开点
        }
        if (x <= l && r <= y)
        {
            sum[u] += val * (r - l + 1);
            add[u] += val;
            return;
        }
        pushdown(u, l, r);
        int mid = l + r >> 1;
        if (x <= mid)
        {
            rangeAdd(lc[u], l, mid, x, y, val);
        }
        if (y > mid)
        {
            rangeAdd(rc[u], mid + 1, r, x, y, val);
        }
        pushup(u);
    }
    T rangeQuerySum(int u, int l, int r, int x, int y)
    {
        if (x <= l and y >= r)
        {
            return (u ? sum[u] : 0);
        }
        int mid = l + r >> 1;
        pushdown(u, l, r);
        T res = 0;
        if (x <= mid)
        {
            res += rangeQuerySum(lc[u], l, mid, x, y);
        }
        if (y > mid)
        {
            res += rangeQuerySum(rc[u], mid + 1, r, x, y);
        }
        return res;
    }
};
```

#### 标记永久化
标记永久化是另一种处理懒标记的技术，我们可以把标记永久打在某个区间而不下传给子区间，我们只需要在查询时累加经过节点的信息即可。

#### 线段树上二分
线段树上二分，其作用往往是找到![image](https://cdn.nlark.com/yuque/__latex/d47812c3cab4e14b5c46e2797ab29d29.svg)区间内第一个大于等于![image](https://cdn.nlark.com/yuque/__latex/a428bd244ddaa5c11de20ca9cfd9d494.svg)的位置或值，同理也可以求出右边

我们常规的想法是在线段树外二分并不断询问区间![image](https://cdn.nlark.com/yuque/__latex/e73a4bbeae47057f73628a1f8e32a605.svg)，但这样的复杂度是![image](https://cdn.nlark.com/yuque/__latex/d21b2886bb46d44b030e0b737581e7ef.svg)的，并不够优秀

我们完全可以直接在线段树上进行这个二分操作，复杂度降为![image](https://cdn.nlark.com/yuque/__latex/ff4edff51773a4560f25e8eab96349ff.svg)

```cpp
template <class T>
class SegmentTree
{
#define lc u << 1
#define rc u << 1 | 1

public:
    struct Node
    {
        int l, r;
        T max;
    };
    SegmentTree(const std::vector<T> &a) : n(a.size()), tr(4 * n)
    {
        n--;
        std::function<void(int, int, int)> build = [&](int u, int l, int r)
        {
            tr[u] = {l, r, a[l]};
            if (l == r)
            {
                return;
            }
            int mid = l + r >> 1;
            build(lc, l, mid);
            build(rc, mid + 1, r);
            pushup(u);
        };
        build(1, 1, n);
    }
    int queryLeftFirstlower(int x, int y, T d)
    {
        return queryLeftFirstlower(1, 1, n, x, y, d);
    }

private:
    void pushup(int u)
    {
        tr[u].max = std::max(tr[lc].max, tr[rc].max);
    }
    int n;
    std::vector<Node> tr;
    int queryLeftFirstlower(int u, int l, int r, int x, int y, T d) //[x,y]靠左的第一个≥d的下标
    {
        if (x == l and y == r)
        {
            if (tr[u].max < d)
            {
                return 0;
            }
            if (l == r)
            {
                return l;
            }
            int mid = l + r >> 1;
            if (tr[lc].max >= d)
            {
                return queryLeftFirstlower(lc, l, mid, x, mid, d);
            }
            else
            {
                return queryLeftFirstlower(rc, mid + 1, r, mid + 1, y, d);
            }
        }
        else
        {
            int mid = l + r >> 1;
            if (y <= mid)
            {
                return queryLeftFirstlower(lc, l, mid, x, y, d);
            }
            else if (x > mid)
            {
                return queryLeftFirstlower(rc, mid + 1, r, x, y, d);
            }
            else
            {
                int pos = queryLeftFirstlower(lc, l, mid, x, mid, d);
                if (pos == 0)
                {
                    return queryLeftFirstlower(rc, mid + 1, r, mid + 1, y, d);
                }
                else
                {
                    return pos;
                }
            }
        }
    }
};
```

#### 线段树分治
线段树分治，全称是线段树按时间分治，其思想非常简单，往往问题的模型都是，某些元素都只在一个或常数个连续的时间区间内出现，我们想到利用线段树在![image](https://cdn.nlark.com/yuque/__latex/558ec40fbb27f97bc2dda151d1568a1c.svg)个线段里存下这个时间区间，也就是说我们维护一颗时间线段树，其每个叶子结点都是一个确定的时刻，其他节点都代表了一段时间区间，我们把信息存进线段树里，只需要统一处理，只需要递归到每个叶子结点就可以求出每个时间对应的答案。

注意进入该节点需要加入信息，而退出该节点需要删除信息，复杂度![image](https://cdn.nlark.com/yuque/__latex/5afa8206020e2963abb96f92df2f914e.svg) 

```cpp
class SegmentTree
{
#define lc u << 1
#define rc u << 1 | 1

public:
    struct Node
    {
        int l, r;
    };
    SegmentTree(int n) : n(n), tr(n + 1 << 2), ans(n + 1)
    {
        std::function<void(int, int, int)> build = [&](int u, int l, int r)
        {
            tr[u] = {l, r};
            if (l == r)
            {
                return;
            }
            int mid = l + r >> 1;
            build(lc, l, mid);
            build(rc, mid + 1, r);
        };
        build(1, 1, n);
    }

    std::vector<int> getAns()
    {
        query(1, 1, n);
        return ans;
    }

private:
    int n;
    std::vector<Node> tr;
    std::vector<int> ans;
    void addInfo(int u, int l, int r, int x, int y, int Info) // 传入起始和终止时间
    {
        if (x <= l and y >= r)
        {
            return;
        }
        int mid = l + r >> 1;
        if (x <= mid)
        {
            addInfo(lc, l, mid, x, y, Info);
        }
        if (y > mid)
        {
            addInfo(rc, mid + 1, r, x, y, Info);
        }
    }
    void query(int u, int l, int r)
    {
        // 加上当前节点的信息
        if (l == r)
        {
            // ans[l]=
            return;
        }
        int mid = l + r >> 1;
        query(lc, l, mid);
        query(rc, mid + 1, r);

        // 删除该节点的信息（回退信息）
    }
};
```

#### 维护线性基
如果是不考虑区间修改的线性基，我们考虑用猫树去维护

如果考虑加上区间异或操作的话，只能考虑如下的维护方法

对于一个序列![image](https://cdn.nlark.com/yuque/__latex/26fdbf8e53cb0e48da5f4ddd4aaf5a5c.svg),我们设其异或差分序列为![image](https://cdn.nlark.com/yuque/__latex/d29c2e5f4926e5b0e9a95305650f6e54.svg)

即![image](https://cdn.nlark.com/yuque/__latex/e61038c7e8e3e0a44018532fce1bf3c7.svg),特别的有![image](https://cdn.nlark.com/yuque/__latex/4d94cea4965163c9815feeb401c239ff.svg),可以证明的是

对于![image](https://cdn.nlark.com/yuque/__latex/26fdbf8e53cb0e48da5f4ddd4aaf5a5c.svg)序列的子区间![image](https://cdn.nlark.com/yuque/__latex/371d3811de80d3e7a448b5cebe095023.svg)所构成的线性基

和对于![image](https://cdn.nlark.com/yuque/__latex/d29c2e5f4926e5b0e9a95305650f6e54.svg)序列的子区间![image](https://cdn.nlark.com/yuque/__latex/f9d2695ad89e319c235dab349e21d813.svg)所构成的线性基 再插入![image](https://cdn.nlark.com/yuque/__latex/f22b875ee513fbde978f3a75b1ed9684.svg)

这两个线性基完全等价 因此我们把区间异或转化为单点异或

由于线性基合并的复杂度为![image](https://cdn.nlark.com/yuque/__latex/26f713bd9edf553f33d9a80a83729ae2.svg)，因此总复杂度为![image](https://cdn.nlark.com/yuque/__latex/2bbce2b1e3b7652a268dec983c408beb.svg)

#### 维护哈希
线段树维护哈希，可以实现单点修改，区间覆盖，区间查询。

事实上任何具有可合并性的信息都可以利用线段树维护，一个序列的哈希值恰好具有该特点，我们可以轻松用线段树维护,由于哈希的特殊性，我们无法维护区间加，但是可以维护区间覆盖。但是事实上，哈希函数几乎不会存在区间加的要求

特别重要的一点，我们用数据结构维护的哈希方法和常规的字符串哈希方法截然不同，也就是说我们不能直接比较，常规的哈希方法是![image](https://cdn.nlark.com/yuque/__latex/72eac70ecd4bf20511bbbb586e342827.svg),而数据结构维护的哈希方法是![image](https://cdn.nlark.com/yuque/__latex/3cb76bfbc442ced5a4107f8f8cf71a5d.svg),其中![image](https://cdn.nlark.com/yuque/__latex/67df0f404d0960fadcc99f6258733f22.svg)是全局的![image](https://cdn.nlark.com/yuque/__latex/2430560ec5c105a668925dd8fcdac841.svg)的次幂数组

两种哈希的不同点在于合并方式不同，因为第一种是越靠前乘的Base次数越多 第二种是越靠后乘的Base次数越多

```cpp
class SegmentTree
{
#define lc u << 1
#define rc u << 1 | 1
public:
    struct Node
    {
        int l, r, hashVal, cover;
    };
    SegmentTree(const std::vector<int> &a, int Base, int P) : Base(Base), P(P), n(a.size()), tr(4 * n), hash(n), prefixHash(n)
    {
        --n;
        hash[0] = 1;
        prefixHash[0] = 1;
        for (int i = 1; i < n; ++i)
        {
            hash[i] = 1ll * hash[i - 1] * Base % P;
            prefixHash[i] = (prefixHash[i - 1] + hash[i]) % P; // 哈希前缀和函数 用于区间覆盖
        }
        std::function<void(int, int, int)> build = [&](int u, int l, int r)
        {
            tr[u] = {l, r, a[l], 0};
            if (l == r)
            {
                return;
            }
            int mid = l + r >> 1;
            build(lc, l, mid);
            build(rc, mid + 1, r);
            pushup(u);
        };
        build(1, 1, n);
    }
    void rangeCover(int l, int r, int val)
    {
        rangeCover(1, 1, n, l, r, val);
    }
    int rangeQueryHashVal(int l, int r)
    {
        return rangeQueryHashVal(1, 1, n, l, r);
    }

private:
    int n;
    int Base, P;
    std::vector<Node> tr;
    std::vector<int> hash, prefixHash;

    void pushup(int u)
    {
        tr[u].hashVal = (tr[lc].hashVal + 1ll * tr[rc].hashVal * hash[tr[lc].r - tr[lc].l + 1] % P) % P;
    }
    void pushdown(Node &u, int cover)
    {
        u.hashVal = 1ll * cover * prefixHash[u.r - u.l] % P;
        u.cover = cover;
    }
    void pushdown(int u)
    {
        if (tr[u].cover)
        {
            pushdown(tr[lc], tr[u].cover);
            pushdown(tr[rc], tr[u].cover);
            tr[u].cover = 0;
        }
    }
    void rangeCover(int u, int l, int r, int x, int y, int c)
    {
        if (x <= l and y >= r)
        {
            pushdown(tr[u], c);
            return;
        }
        int mid = l + r >> 1;
        pushdown(u);
        if (x <= mid)
        {
            rangeCover(lc, l, mid, x, y, c);
        }
        if (y > mid)
        {
            rangeCover(rc, mid + 1, r, x, y, c);
        }
        pushup(u);
    }
    int rangeQueryHashVal(int u, int l, int r, int x, int y)
    {
        if (x <= l && y >= r)
        {
            return tr[u].hashVal;
        }
        int mid = l + r >> 1;
        pushdown(u);
        if (y <= mid)
        {
            return rangeQueryHashVal(lc, l, mid, x, y);
        }
        else if (x > mid)
        {
            return rangeQueryHashVal(rc, mid + 1, r, x, y);
        }
        else
        {
            return (rangeQueryHashVal(lc, l, mid, x, mid) + 1ll * rangeQueryHashVal(rc, mid + 1, r, mid + 1, y) * hash[mid - x + 1] % P) % P;
        }
    }
};
```

#### 线段树合并
线段树合并往往是动态开点的权值线段树，往往解决的是关于值域方面的询问，比如问子树内出现最多的颜色

换个理解方法，也就是建在树上的主席树

询问往往分两种常见形式

其一是每个节点有信息，询问以某点的子树内的信息总和，这一类是朴素的线段树合并

其二是有区间链加的操作，询问单点信息，这一类我们转化为树上差分，即可转化为第一类。

对于求解方法，我们仍然分两类，新开节点和不新开节点。

对于不新开节点的做法，我们往往离线询问到对应的节点上，然后在递归合并![image](https://cdn.nlark.com/yuque/__latex/3554585ecb04a4bf73b5938d239b0fe5.svg)时，当![image](https://cdn.nlark.com/yuque/__latex/77c3adce895348f6083c425fe1ba2624.svg)节点信息合并完成，我们顺势处理![image](https://cdn.nlark.com/yuque/__latex/0a25ff5d5f49aeb7283b1b06cf5b55d5.svg)节点的所有询问，但是之后该节点的信息会被覆盖而不能再使用

对于新开节点的做法，我们可以直接![image](https://cdn.nlark.com/yuque/__latex/3554585ecb04a4bf73b5938d239b0fe5.svg)递归合并所有信息，这样每个节点都可以保留正确的信息，我们可以不用离线询问，但是空间消耗巨大。

往往我们直接采用第一种做法即可

```cpp
class MergeSegmentTree
{
public:
    // 构造函数
    // g: 树的邻接表表示
    // val: 各节点的值
    // capacity: 线段树节点预分配空间
    // treeRoot: 树的根节点
    // min/max: 值域范围（若值域过大需先离散化）
    MergeSegmentTree(const std::vector<std::vector<int>> &g, std::vector<int> &val, int capacity, int treeRoot, int min, int max)
        : n(val.size()), g(g), min(min), max(max)
    {
        --n; // 调整为1-based索引
        // 初始化线段树节点数组
        root.assign(capacity + 1, 0); // 各子树根节点
        lc.assign(capacity + 1, 0);   // 左子节点指针
        rc.assign(capacity + 1, 0);   // 右子节点指针
        sum.assign(capacity + 1, 0);  // 区间和

        // 为每个节点创建叶子节点
        for (int i = 1; i <= n; ++i)
        {
            insert(root[i], min, max, val[i], 1); // 插入节点值
        }
        // 后序遍历合并子树线段树
        dfs(treeRoot, 0);
    }

    // 查询u子树中值≥val的节点数量
    int query(int u, int val)
    {
        return query(root[u], min, max, val);
    }

private:
    int n;                           // 节点总数
    int tot = 0;                     // 线段树节点计数器
    int min, max;                    // 值域范围
    std::vector<int> root;           // 各子树根节点
    std::vector<int> lc;             // 左子节点指针
    std::vector<int> rc;             // 右子节点指针
    std::vector<int> sum;            // 区间和统计
    std::vector<std::vector<int>> g; // 树的邻接表

    // 更新节点统计值
    void pushup(int u)
    {
        sum[u] = sum[lc[u]] + sum[rc[u]];
    }

    // 在线段树中插入值
    // u: 当前节点指针（引用传递）
    // l/r: 当前区间
    // pos: 插入位置
    // val: 插入值
    void insert(int &u, int l, int r, int pos, int val)
    {
        if (!u)
            u = ++tot; // 动态开点
        if (l == r)
        {
            sum[u] += val; // 叶子节点更新
            return;
        }
        int mid = l + r >> 1;
        if (pos <= mid)
            insert(lc[u], l, mid, pos, val); // 递归左子树
        else
            insert(rc[u], mid + 1, r, pos, val); // 递归右子树
        pushup(u);                               // 更新统计值
    }

    // 合并两棵线段树（返回合并后的根节点）
    int merge(int x, int y)
    {
        if (!x)
            return y; // x为空则返回y
        if (!y)
            return x; // y为空则返回x
        // 创建新节点合并统计值
        int u = ++tot;
        sum[u] = sum[x] + sum[y];
        // 递归合并左右子树
        lc[u] = merge(lc[x], lc[y]);
        rc[u] = merge(rc[x], rc[y]);
        return u;
    }

    // 后序遍历合并子树
    void dfs(int u, int fa)
    {
        for (auto v : g[u])
        {
            if (v == fa)
                continue;                      // 跳过父节点
            dfs(v, u);                         // 先处理子节点
            root[u] = merge(root[u], root[v]); // 合并子节点线段树
        }
    }

    // 查询区间中≥val的值的数量
    int query(int u, int l, int r, int val)
    {
        if (!u)
            return 0; // 空树返回0
        if (l >= val)
            return sum[u]; // 整个区间都≥val
        int res = 0;
        int mid = l + r >> 1;
        if (mid >= val)
            res += query(lc[u], l, mid, val); // 左子树可能包含
        res += query(rc[u], mid + 1, r, val); // 右子树可能包含
        return res;
    }
};

```

```cpp
class MergeSegmentTree
{
public:
    // 构造函数
    // g: 树的邻接表表示
    // val: 每个节点的值
    // capacity: 线段树的最大容量
    // treeRoot: 树的根节点
    // min: 值域的最小值
    // max: 值域的最大值（如果值域太大可以传入离散化后的数组）
    MergeSegmentTree(const std::vector<std::vector<int>> &g, std::vector<int> &val, int capacity, int treeRoot, int min, int max)
        : n(val.size()), ans(n), g(g), min(min), max(max)
    {
        --n; // 调整节点数量（假设节点编号从1开始）
        // 初始化线段树的各个数组
        root.assign(capacity + 1, 0); // 每个节点的线段树根
        lc.assign(capacity + 1, 0);   // 左孩子数组
        rc.assign(capacity + 1, 0);   // 右孩子数组
        sum.assign(capacity + 1, 0);  // 线段树节点对应的区间和

        // 为每个节点创建初始线段树
        for (int i = 1; i <= n; ++i)
        {
            insert(root[i], min, max, val[i], 1); // 在值val[i]位置插入1
        }

        // 从树的根节点开始进行深度优先遍历
        dfs(treeRoot, 0);
    }

    // 获取结果数组
    std::vector<int> getAns()
    {
        return ans;
    }

private:
    int n;                           // 节点数量
    int tot = 0;                     // 线段树节点计数器
    int min, max;                    // 值域范围
    std::vector<int> root;           // 每个节点的线段树根
    std::vector<int> lc;             // 线段树左孩子
    std::vector<int> rc;             // 线段树右孩子
    std::vector<int> sum;            // 线段树节点和
    std::vector<std::vector<int>> g; // 树的邻接表
    std::vector<int> ans;            // 存储每个节点的答案

    // 更新线段树节点的和
    void pushup(int u)
    {
        sum[u] = sum[lc[u]] + sum[rc[u]];
    }

    // 在线段树中插入值
    // u: 当前线段树节点
    // l, r: 当前区间
    // pos: 要插入的位置
    // val: 要插入的值
    void insert(int &u, int l, int r, int pos, int val)
    {
        if (!u)
            u = ++tot; // 动态开点
        if (l == r)
        {
            sum[u] += val; // 叶子节点更新
            return;
        }
        int mid = l + r >> 1;
        if (pos <= mid)
        {
            insert(lc[u], l, mid, pos, val); // 递归左子树
        }
        else
        {
            insert(rc[u], mid + 1, r, pos, val); // 递归右子树
        }
        pushup(u); // 更新当前节点
    }

    // 合并两棵线段树（覆盖式合并）
    int merge(int x, int y)
    {
        if (!x)
            return y; // 如果x为空，返回y
        if (!y)
            return x;                // 如果y为空，返回x
        sum[x] += sum[y];            // 合并节点和
        lc[x] = merge(lc[x], lc[y]); // 递归合并左子树
        rc[x] = merge(rc[x], rc[y]); // 递归合并右子树
        return x;
    }

    // 深度优先遍历树
    void dfs(int u, int fa)
    {
        for (auto v : g[u]) // 遍历所有子节点
        {
            if (v == fa)
                continue;                      // 跳过父节点
            dfs(v, u);                         // 递归处理子节点
            root[u] = merge(root[u], root[v]); // 将子节点的线段树合并到当前节点
        }
        ans[u] = query(root[u], min, max, val); // 查询当前节点的答案
    }

    // 查询线段树中≥val的值的数量
    int query(int u, int l, int r, int val)
    {
        if (!u)
            return 0; // 空树返回0
        if (l >= val)
            return sum[u]; // 整个区间都≥val，直接返回和
        int res = 0;
        int mid = l + r >> 1;
        if (mid >= val)
        {
            res += query(lc[u], l, mid, val); 
        }
        res += query(rc[u], mid + 1, r, val);
        return res;
    }
};
```

#### 维护树链
树链剖分得到![image](https://cdn.nlark.com/yuque/__latex/6887d6be660e53affd93d79336c403e2.svg)序列和重链信息，可以把链转成![image](https://cdn.nlark.com/yuque/__latex/ff4edff51773a4560f25e8eab96349ff.svg)个区间，于是我们可以用线段树维护树上链的信息

#### 李超线段树
李超线段树是一种用来维护平面上线段关系的数据结构，其在一类斜率优化![image](https://cdn.nlark.com/yuque/__latex/cdaf04cddf57ae63edeafceb53eb4044.svg)中有重要作用。

更具体的说，对于插入李超线段树的所有线段![image](https://cdn.nlark.com/yuque/__latex/73ffb5274c1fea4428905413960bc708.svg)，对于任意的![image](https://cdn.nlark.com/yuque/__latex/712ecf7894348e92d8779c3ee87eeeb0.svg)我都可以求出对应的![image](https://cdn.nlark.com/yuque/__latex/e086c41c430172c788fb859613096965.svg)。

李超线段树分两种，其限制条件不同，操作方法不同，时间复杂度也不同

对于![image](https://cdn.nlark.com/yuque/__latex/0a8f4563210ad9ab272b48a06ae56e74.svg)的李超线段树，我可以指定每段线段不同的的起点和终点，对于![image](https://cdn.nlark.com/yuque/__latex/4fdce66a3ca18398b05c1efc03c7aa4f.svg)的李超线段树，每个线段的起点和终点的横坐标相同。

特别需要注意的是，对于![image](https://cdn.nlark.com/yuque/__latex/a00a82084f6e427c40ebc185fe83bab0.svg)为![image](https://cdn.nlark.com/yuque/__latex/22d0feea96d3bb2fc273f7598ce748c1.svg)的情况我们需要返回![image](https://cdn.nlark.com/yuque/__latex/acfdac42918d6f58c17fd5da07294879.svg)

而且在修改最大最小时都要改变![image](https://cdn.nlark.com/yuque/__latex/51cfed01cb9faa1accbd539a371269d8.svg)和![image](https://cdn.nlark.com/yuque/__latex/e48d99de9537dd47d24206a74f207ea9.svg)函数

```cpp
// 李超线段树（Lichao Tree）实现，用于维护多条线段并在给定点查询最大值
class LichaoTree
{
    using ld = long double;         // 使用 long double 提高浮点数精度
    using pdi = std::pair<ld, int>; // 存储线段值和线段索引的 pair

    // 宏定义左右子节点（线段树标准写法）
#define lc u << 1     // 左子节点索引
#define rc u << 1 | 1 // 右子节点索引

    const ld eps = 1e-9; // 浮点数比较的误差范围
    const int inf = 1e9; // 表示无穷大的值

public:
    // 线段结构体，k是斜率，b是截距
    struct Line
    {
        ld k, b;
    };

    // 构造函数
    // n: 线段最大数量
    // min: 坐标最小值
    // max: 坐标最大值
    LichaoTree(int n, int min, int max)
        : tr(max * 4 + 1, 0), // 线段树节点数组，初始化为0（表示无线段）
          p(n + 1),           // 线段存储数组
          min(min),           // 最小x坐标
          max(max)            // 最大x坐标
    {
        // n是线段条数 min是最小X坐标,max是最大x坐标
    }

    // 插入一条线段 y = kx + b，作用区间为[l, r]
    void insertLine(ld k, ld b, int l, int r)
    {
        p[++idx] = {k, b};              // 存储线段
        change(1, min, max, l, r, idx); // 更新线段树
    }

    // 查询x位置的最大值及其对应的线段索引
    pdi queryMax(int x)
    {
        return query(1, min, max, x);
    }

private:
    std::vector<Line> p; // 存储所有线段
    std::vector<int> tr; // 线段树节点，存储当前区间最优线段索引
    int idx = 0;         // 当前线段数量
    int min, max;        // x坐标范围

    // 获取线段lineId在x位置的值
    ld getval(int lineId, int x)
    {
        if (!lineId)
        {
            return -inf; // 无效线段返回-∞（因为这里是求最大值）
        }
        auto [k, b] = p[lineId]; // 解构线段
        return k * x + b;        // 计算y值
    }

    // 浮点数比较函数
    // 返回值：1(a>b), -1(a<b), 0(a==b)
    int cmp(ld a, ld b)
    {
        if (a - b > eps)
            return 1; // a > b
        if (b - a > eps)
            return -1; // a < b
        return 0;      // a == b
    }

    // 递归更新线段树
    // u: 当前节点
    // [l,r]: 当前节点表示的区间
    // [x,y]: 要更新的区间
    // id: 新线段的索引
    void change(int u, int l, int r, int x, int y, int id)
    {
        int mid = l + r >> 1; // 区间中点

        // 如果当前区间完全包含在更新区间内
        if (x <= l and y >= r)
        {
            // 比较中点处的值
            int cm = cmp(getval(id, mid), getval(tr[u], mid));
            // 如果新线段更优，或者值相同但索引更小（保证稳定性），则交换
            if (cm == 1 || (!cm and id < tr[u]))
            {
                std::swap(id, tr[u]);
            }

            // 检查左端点是否需要递归更新左子树
            int cl = cmp(getval(id, l), getval(tr[u], l));
            if (cl == 1 || (!cl and id < tr[u]))
            {
                change(lc, l, mid, x, y, id);
            }

            // 检查右端点是否需要递归更新右子树
            int cr = cmp(getval(id, r), getval(tr[u], r));
            if (cr == 1 || (!cr and id < tr[u]))
            {
                change(rc, mid + 1, r, x, y, id);
            }
            return;
        }

        // 部分覆盖，递归处理子区间
        if (x <= mid)
            change(lc, l, mid, x, y, id);
        if (y > mid)
            change(rc, mid + 1, r, x, y, id);
    }

    // 比较两个结果，返回较大的那个
    // 如果值相同，返回索引较小的（保证稳定性）
    pdi pmax(pdi a, pdi b)
    {
        if (cmp(a.first, b.first) == 1)
            return a; // a > b
        else if (cmp(a.first, b.first) == -1)
            return b; // a < b
        else
            return a.second < b.second ? a : b; // 值相同时取索引小的
    }

    // 查询x位置的最大值
    pdi query(int u, int l, int r, int x)
    {
        // 叶节点直接返回
        if (l == r)
        {
            return {getval(tr[u], x), tr[u]};
        }

        int mid = l + r >> 1;
        pdi now = {getval(tr[u], x), tr[u]}; // 当前节点的值

        // 递归查询子区间
        if (x <= mid)
        {
            return pmax(now, query(lc, l, mid, x));
        }
        else
        {
            return pmax(now, query(rc, mid + 1, r, x));
        }
    }
};
```

```cpp

// 李超线段树类，用于维护多条线段并在给定点查询最大值

template <class T>
class LichaoTree
{
    const T inf = std::numeric_limits<T>::max() / 2;
#define lc u << 1     // 左子节点宏定义
#define rc u << 1 | 1 // 右子节点宏定义

    // 线段结构体，表示y = kx + b
    struct Line
    {
        T k, b; // 斜率k和截距b
    };

    // 构造函数
    // n: 预处理的线段数量
    // min: 值域最小值
    // max: 值域最大值
    LichaoTree(int n, int min, int max)
        : tr(max * 4 + 1), // 线段树数组大小（4倍空间）
          p(n + 1),        // 线段存储数组
          min(min),        // 值域下界
          max(max)         // 值域上界
    {
    }

    // 插入一条新线段 y = kx + b
    void insertLine(T k, T b)
    {
        p[++idx] = {k, b};        // 存储线段参数
        change(1, min, max, idx); // 从根节点开始更新线段树
    }

    // 在x处查询最大值
    T queryMax(int x)
    {
        return queryMax(1, min, max, x); // 从根节点开始查询
    }

private:
    int idx = 0;         // 线段计数器
    int min, max;        // 值域范围
    std::vector<int> tr; // 线段树节点，存储优势线段的索引
    std::vector<Line> p; // 存储所有线段

    // 计算线段id在x处的值
    T getval(int id, int x)
    {
        if (!id)
            return -inf;     // 无效线段返回负无穷
        auto [k, b] = p[id]; // 解构线段参数
        return k * x + b;    // 计算y值
    }

    // 更新线段树，插入新线段
    void change(int u, int l, int r, int id)
    {
        int mid = l + r >> 1; // 计算区间中点

        // 如果新线段在中点处更优，交换当前线段
        if (getval(id, mid) > getval(tr[u], mid))
        {
            std::swap(id, tr[u]);
        }

        // 如果新线段在左端点更优，递归左子树
        if (getval(id, l) > getval(tr[u], l))
        {
            change(lc, l, mid, id);
        }

        // 如果新线段在右端点更优，递归右子树
        if (getval(id, r) > getval(tr[u], r))
        {
            change(rc, mid + 1, r, id);
        }
    }

    // 查询x处的最大值
    T queryMax(int u, int l, int r, int x)
    {
        if (l == r) // 到达叶子节点
        {
            return getval(tr[u], x);
        }

        int mid = l + r >> 1;
        T now = getval(tr[u], x); // 当前节点的线段在x处的值

        // 根据x的位置决定查询方向
        if (x <= mid)
        {
            return std::max(now, queryMax(lc, l, mid, x));
        }
        else
        {
            return std::max(now, queryMax(rc, mid + 1, r, x));
        }
    }
};
```

#### 吉司机线段树
![image](https://cdn.nlark.com/yuque/__latex/42e602e9480d20b4cfd29900f208cffe.svg)，又名吉司机线段树，是专门用来解决一类区间取![image](https://cdn.nlark.com/yuque/__latex/76040453a36212d67fba520eeface367.svg)，区间取![image](https://cdn.nlark.com/yuque/__latex/416e9a8046d05a55fd5a31adaf5e6858.svg)问题，一般来说这类问题只需要普通的懒标记线段树就能解决，但是一旦加上区间加操作，这个问题变得十分困难，这和最大子段和问题类似。![image](https://cdn.nlark.com/yuque/__latex/fe0947fcbf8d311ac3fe67d92b9ca7e0.svg)就是解决这一类问题的利器。

我们以区间取![image](https://cdn.nlark.com/yuque/__latex/8a93d856ced2a133a990fa45a2130524.svg)为例子,我们记录区间![image](https://cdn.nlark.com/yuque/__latex/416e9a8046d05a55fd5a31adaf5e6858.svg),区间次大值![image](https://cdn.nlark.com/yuque/__latex/6f4c06f7af9e47c1ba8e2baa8b03bb81.svg),最大值出现次数![image](https://cdn.nlark.com/yuque/__latex/2785172b58ed1909db1b8aeb426b89b1.svg),那么我们进行区间![image](https://cdn.nlark.com/yuque/__latex/8a93d856ced2a133a990fa45a2130524.svg)操作时,我们设当前取![image](https://cdn.nlark.com/yuque/__latex/8a93d856ced2a133a990fa45a2130524.svg)的值为![image](https://cdn.nlark.com/yuque/__latex/8597b8ad64ac82614635dd0459956516.svg),如果![image](https://cdn.nlark.com/yuque/__latex/bf8c9825b3929fd50c0014e4d5373354.svg)，显然我们不需要操作，如果![image](https://cdn.nlark.com/yuque/__latex/53484a6acb2ed18d70da83ae3dfced1b.svg)并且![image](https://cdn.nlark.com/yuque/__latex/9317be9898779353a3e6c6fbc52e31c0.svg)，那么我们维护当前的![image](https://cdn.nlark.com/yuque/__latex/416e9a8046d05a55fd5a31adaf5e6858.svg)和![image](https://cdn.nlark.com/yuque/__latex/5d9e8c2483c4833aa0f798fca42487db.svg)，即![image](https://cdn.nlark.com/yuque/__latex/21e4de9dd551801d20d8c95bb4f9f465.svg)然后结束，否则我们继续递归下去。

不难发现问题所在，我们没有递归所有节点更改，我们也没有打懒标记，这就是![image](https://cdn.nlark.com/yuque/__latex/fe0947fcbf8d311ac3fe67d92b9ca7e0.svg)的独特之处

实际上我们的![image](https://cdn.nlark.com/yuque/__latex/e73a4bbeae47057f73628a1f8e32a605.svg)值本身就是一个懒标记可以使用，举例来说，在我们![image](https://cdn.nlark.com/yuque/__latex/f17fdb6a79ab01dbbad527199c0a1986.svg)的时候，如果![image](https://cdn.nlark.com/yuque/__latex/b955cf95981566128ef246059d23887d.svg)，这个式子本身就存在矛盾，因此我们知道是我们的操作导致的，我们在此进行修正从而维护了节点信息正确,对于具体的数据变化我们要具体分析,![image](https://cdn.nlark.com/yuque/__latex/17a0042cf8bb0b5dac93b7dea1780afe.svg)函数需要随机应变

根据论文的证明，时间复杂度![image](https://cdn.nlark.com/yuque/__latex/2e1f294ec40ceb84f92961c667c63d2b.svg)

为了节约码量，省去了部分非关键函数

```cpp
// 线段树 beats（吉如一线段树）实现类，支持区间取min/max操作
template <class T>
class SegmentTreeBeats
{
public:
    const T inf = std::numeric_limits<T>::max() / 2; // 定义无穷大值
#define lc u << 1                                    // 左子节点宏定义
#define rc u << 1 | 1                                // 右子节点宏定义

    // 线段树节点结构体
    struct Node
    {
        int l, r;    // 节点代表的区间[l,r]
        T sum;       // 区间和
        T max;       // 区间最大值
        T min;       // 区间最小值
        T add;       // 延迟标记（区间加法）
        T secondmax; // 区间次大值
        int maxCnt;  // 最大值出现次数
        T secondmin; // 区间次小值
        int minCnt;  // 最小值出现次数
    };

    // 构造函数，使用数组a初始化线段树
    SegmentTreeBeats(const std::vector<T> &a) : n(a.size()), tr(4 * n)
    {
        n--; // 调整节点数量（假设节点编号从1开始）

        // 递归构建线段树的lambda函数
        std::function<void(int, int, int)> build = [&](int u, int l, int r)
        {
            tr[u] = {l, r, a[l], a[l], a[l], 0}; // 初始化节点基础信息
            if (l == r)                          // 叶子节点
            {
                tr[u].secondmax = -inf;          // 初始化次大值
                tr[u].secondmin = inf;           // 初始化次小值
                tr[u].maxCnt = tr[u].minCnt = 1; // 初始化计数
                return;
            }
            int mid = l + r >> 1;  // 计算中点
            build(lc, l, mid);     // 构建左子树
            build(rc, mid + 1, r); // 构建右子树
            pushup(u);             // 合并子节点信息
        };
        build(1, 1, n); // 从根节点开始构建
    }

    // 区间取min操作（将区间[x,y]中大于p的值改为p）
    void rangeGetMin(int l, int r, T min)
    {
        rangeGetMin(1, 1, n, l, r, min);
    }

    // 区间取max操作（将区间[x,y]中小于p的值改为p）
    void rangeGetMax(int l, int r, T max)
    {
        rangeGetMax(1, 1, n, l, r, max);
    }

private:
    int n;                // 原始数组大小
    std::vector<Node> tr; // 线段树节点数组

    // 向上合并子节点信息
    void pushup(int u)
    {
        // 合并最大值信息
        tr[u].max = std::max(tr[lc].max, tr[rc].max);
        // 合并最小值信息
        tr[u].min = std::min(tr[lc].min, tr[rc].min);
        // 合并区间和
        tr[u].sum = tr[lc].sum + tr[rc].sum;

        // 处理最大值及其计数
        if (tr[lc].max == tr[rc].max)
        {
            tr[u].maxCnt = tr[lc].maxCnt + tr[rc].maxCnt;
            tr[u].secondmax = std::max(tr[lc].secondmax, tr[rc].secondmax);
        }
        else if (tr[lc].max > tr[rc].max)
        {
            tr[u].maxCnt = tr[lc].maxCnt;
            tr[u].secondmax = std::max(tr[rc].max, tr[lc].secondmax);
        }
        else if (tr[rc].max > tr[lc].max)
        {
            tr[u].maxCnt = tr[rc].maxCnt;
            tr[u].secondmax = std::max(tr[lc].max, tr[rc].secondmax);
        }

        // 处理最小值及其计数
        if (tr[lc].min == tr[rc].min)
        {
            tr[u].minCnt = tr[lc].minCnt + tr[rc].minCnt;
            tr[u].secondmin = std::min(tr[lc].secondmin, tr[rc].secondmin);
        }
        else if (tr[rc].min > tr[lc].min)
        {
            tr[u].minCnt = tr[lc].minCnt;
            tr[u].secondmin = std::min(tr[rc].min, tr[lc].secondmin);
        }
        else if (tr[lc].min > tr[rc].min)
        {
            tr[u].minCnt = tr[rc].minCnt;
            tr[u].secondmin = std::min(tr[lc].min, tr[rc].secondmin);
        }
    }

    // 应用加法延迟标记
    void pushdown(Node &u, T add)
    {
        u.sum += add * (u.r - u.l + 1); // 更新区间和
        u.max += add;                   // 更新最大值
        u.min += add;                   // 更新最小值
        u.secondmax += add;             // 更新次大值
        u.secondmin += add;             // 更新次小值
        u.add += add;                   // 累加延迟标记
    }

    // 下传延迟标记（包括加法和取min/max操作）
    void pushdown(int u)
    {
        // 处理加法延迟标记
        if (tr[u].add)
        {
            pushdown(tr[lc], tr[u].add);
            pushdown(tr[rc], tr[u].add);
            tr[u].add = 0;
        }

        // 处理取min操作（核心操作）
        if (tr[u].min > tr[lc].min)
        {
            // 处理左子树的最小值
            if (tr[lc].max == tr[lc].min)
            {
                tr[lc].max = tr[u].min;
            }
            if (tr[lc].secondmax == tr[lc].min)
            {
                tr[lc].secondmax = tr[u].min;
            }
            tr[lc].sum += tr[lc].minCnt * (tr[u].min - tr[lc].min);
            tr[lc].min = tr[u].min;
        }

        if (tr[u].min > tr[rc].min)
        {
            // 处理右子树的最小值
            if (tr[rc].max == tr[rc].min)
            {
                tr[rc].max = tr[u].min;
            }
            if (tr[rc].secondmax == tr[rc].min)
            {
                tr[rc].secondmax = tr[u].min;
            }
            tr[rc].sum += tr[rc].minCnt * (tr[u].min - tr[rc].min);
            tr[rc].min = tr[u].min;
        }

        // 处理取max操作（核心操作）
        if (tr[u].max < tr[lc].max)
        {
            // 处理左子树的最大值
            if (tr[lc].min == tr[lc].max)
            {
                tr[lc].min = tr[u].max;
            }
            if (tr[lc].secondmin == tr[lc].max)
            {
                tr[lc].secondmin = tr[u].max;
            }
            tr[lc].sum -= tr[lc].maxCnt * (tr[lc].max - tr[u].max);
            tr[lc].max = tr[u].max;
        }

        if (tr[u].max < tr[rc].max)
        {
            // 处理右子树的最大值
            if (tr[rc].min == tr[rc].max)
            {
                tr[rc].min = tr[u].max;
            }
            if (tr[rc].secondmin == tr[rc].max)
            {
                tr[rc].secondmin = tr[u].max;
            }
            tr[rc].sum -= tr[rc].maxCnt * (tr[rc].max - tr[u].max);
            tr[rc].max = tr[u].max;
        }
    }

    // 区间取min操作的实现
    void rangeGetMin(int u, int l, int r, int x, int y, T p)
    {
        if (tr[u].max <= p) // 如果区间最大值已经≤p，无需操作
        {
            return;
        }
        if (x <= l && y >= r) // 完全包含区间
        {
            if (tr[u].secondmax < p) // 次大值<p，可以批量修改
            {
                // 更新各种信息
                if (tr[u].min == tr[u].max)
                {
                    tr[u].min = p;
                }
                if (tr[u].secondmin == tr[u].max)
                {
                    tr[u].secondmin = p;
                }
                tr[u].sum -= tr[u].maxCnt * (tr[u].max - p);
                tr[u].max = p;
                return;
            }
        }
        int mid = l + r >> 1; // 计算中点
        pushdown(u);          // 下传标记
        if (x <= mid)
        {
            rangeGetMin(lc, l, mid, x, y, p); // 处理左子树
        }
        if (y > mid)
        {
            rangeGetMin(rc, mid + 1, r, x, y, p); // 处理右子树
        }
        pushup(u); // 合并子节点信息
    }

    // 区间取max操作的实现
    void rangeGetMax(int u, int l, int r, int x, int y, T p)
    {
        if (tr[u].min >= p) // 如果区间最小值已经≥p，无需操作
        {
            return;
        }
        if (x <= l && y >= r) // 完全包含区间
        {
            if (tr[u].secondmin > p) // 次小值>p，可以批量修改
            {
                // 更新各种信息
                if (tr[u].max == tr[u].min)
                {
                    tr[u].max = p;
                }
                if (tr[u].secondmax == tr[u].min)
                {
                    tr[u].secondmax = p;
                }
                tr[u].sum += tr[u].minCnt * (p - tr[u].min);
                tr[u].min = p;
                return;
            }
        }
        int mid = l + r >> 1; // 计算中点
        pushdown(u);          // 下传标记
        if (x <= mid)
        {
            rangeGetMax(lc, l, mid, x, y, p); // 处理左子树
        }
        if (y > mid)
        {
            rangeGetMax(rc, mid + 1, r, x, y, p); // 处理右子树
        }
        pushup(u); // 合并子节点信息
    }
};
```

当然![image](https://cdn.nlark.com/yuque/__latex/fe0947fcbf8d311ac3fe67d92b9ca7e0.svg)对于数字的修正效果不止于取![image](https://cdn.nlark.com/yuque/__latex/8a93d856ced2a133a990fa45a2130524.svg)或取![image](https://cdn.nlark.com/yuque/__latex/e73a4bbeae47057f73628a1f8e32a605.svg)，我们可以做把区间![image](https://cdn.nlark.com/yuque/__latex/371d3811de80d3e7a448b5cebe095023.svg)内![image](https://cdn.nlark.com/yuque/__latex/9c3af0d299565f25d78f8e13e82845e8.svg)的数变成![image](https://cdn.nlark.com/yuque/__latex/3f61e3a1a6bfacdedbceae7e534e7bce.svg)类似的操作。

```cpp
// Segment Tree Beats 实现类
template <class T>
class SegmentTreeBeats
{
    const T inf = std::numeric_limits<T>::max() / 2; // 定义一个无穷大的常量
#define lc u << 1                                    // 左子节点宏定义
#define rc u << 1 | 1                                // 右子节点宏定义

public:
    // 线段树节点结构体
    struct Node
    {
        int l, r;         // 节点代表的区间[l,r]
        T max, secondMax; // 区间最大值和次大值
    };

    // 构造函数，用给定数组a初始化线段树
    SegmentTreeBeats(const std::vector<T> &a) : n(a.size()), tr(4 * n)
    {
        n--; // 调整为1-based索引
        // 递归构建线段树的lambda函数
        std::function<void(int, int, int)> build = [&](int u, int l, int r)
        {
            tr[u] = {l, r}; // 初始化节点区间
            if (l == r)     // 叶子节点
            {
                tr[u].max = a[l];       // 最大值就是元素本身
                tr[u].secondMax = -inf; // 次大值初始为负无穷
                return;
            }
            int mid = l + r >> 1;  // 计算中点
            build(lc, l, mid);     // 递归构建左子树
            build(rc, mid + 1, r); // 递归构建右子树
            pushup(u);             // 合并子节点信息
        };
        build(1, 1, n); // 从根节点开始构建
    }

    // 区间修改操作：把[l,r]区间内>=before的值改为after
    void rangeChange(int l, int r, T before, T after)
    {
        rangeChange(1, 1, n, l, r, before, after);
    }

    // 区间查询最大值
    T rangeQueryMax(int l, int r)
    {
        return rangeQueryMax(1, 1, n, l, r);
    }

private:
    int n;                // 数组长度
    std::vector<Node> tr; // 线段树节点数组

    // 向上合并子节点信息
    void pushup(int u)
    {
        // 计算当前区间的最大值
        tr[u].max = std::max(tr[lc].max, tr[rc].max);

        // 维护次大值，分三种情况：
        // 1. 左右子树最大值相等
        if (tr[lc].max == tr[rc].max)
        {
            tr[u].secondMax = std::max(tr[lc].secondMax, tr[rc].secondMax);
        }
        // 2. 左子树最大值较大
        else if (tr[lc].max > tr[rc].max)
        {
            tr[u].secondMax = std::max(tr[rc].max, tr[lc].secondMax);
        }
        // 3. 右子树最大值较大
        else if (tr[rc].max > tr[lc].max)
        {
            tr[u].secondMax = std::max(tr[lc].max, tr[rc].secondMax);
        }
    }

    // 向下传递标记
    void pushdown(int u)
    {
        // 根据当前节点的最大值更新子节点的最大值
        // 但不会让子节点超过当前节点的最大值

        // 左子节点最大值较大且需要更新
        if (tr[lc].max > tr[rc].max and tr[lc].max < tr[u].max)
        {
            tr[lc].max = tr[u].max;
        }
        // 右子节点最大值较大且需要更新
        else if (tr[rc].max > tr[lc].max and tr[rc].max < tr[u].max)
        {
            tr[rc].max = tr[u].max;
        }
        // 左右子节点最大值相等且需要更新
        else if (tr[rc].max == tr[lc].max and tr[rc].max < tr[u].max)
        {
            tr[rc].max = tr[lc].max = tr[u].max;
        }
    }

    // 区间修改实现
    void rangeChange(int u, int l, int r, int x, int y, T p, T q)
    {
        // 如果当前区间最大值都小于p，直接返回
        if (tr[u].max < p)
        {
            return;
        }

        // 如果完全包含当前区间
        if (x <= l && y >= r)
        {
            // 如果次大值小于p，说明只有最大值需要修改
            if (tr[u].secondMax < p)
            {
                tr[u].max = q; // 直接修改最大值
                return;
            }
        }

        // 部分包含，需要递归处理
        int mid = l + r >> 1;
        pushdown(u); // 先下推标记

        // 递归处理左子树
        if (x <= mid)
        {
            rangeChange(lc, l, mid, x, y, p, q);
        }
        // 递归处理右子树
        if (y > mid)
        {
            rangeChange(rc, mid + 1, r, x, y, p, q);
        }

        pushup(u); // 合并子节点信息
    }

    // 区间查询最大值实现
    T rangeQueryMax(int u, int l, int r, int x, int y)
    {
        // 完全包含当前区间，直接返回最大值
        if (x <= l && y >= r)
        {
            return tr[u].max;
        }

        int mid = l + r >> 1;
        pushdown(u);  // 下推标记
        T ans = -inf; // 初始化为极小值

        // 查询左子树
        if (x <= mid)
        {
            ans = std::max(ans, rangeQueryMax(lc, l, mid, x, y));
        }
        // 查询右子树
        if (y > mid)
        {
            ans = std::max(ans, rangeQueryMax(rc, mid + 1, r, x, y));
        }

        return ans;
    }
};
```

#### 猫树
猫叔是一类不支持修改但支持快速查询的线段树，具体的说，对于一个线段树节点![image](https://cdn.nlark.com/yuque/__latex/32d10fa53de28fc430ffa4d8380ea7eb.svg)，我们考虑从![image](https://cdn.nlark.com/yuque/__latex/689295fb72b63ee1db32afb2f3bbe8b8.svg)分开，对![image](https://cdn.nlark.com/yuque/__latex/427106f8802f426216fe766023b90416.svg)维护后缀和，对![image](https://cdn.nlark.com/yuque/__latex/f37974f21b50e02fb71872ed4ea1ead5.svg)维护前缀和，不难发现我们一定可以拼出跨越![image](https://cdn.nlark.com/yuque/__latex/689295fb72b63ee1db32afb2f3bbe8b8.svg)的任意一个区间的信息，只需要合并对应的前缀信息和后缀信息。那么对于一个询问![image](https://cdn.nlark.com/yuque/__latex/371d3811de80d3e7a448b5cebe095023.svg)，我们不妨设节点![image](https://cdn.nlark.com/yuque/__latex/26d4d5b24033ce629cbb6fb2cedebce0.svg)编号为![image](https://cdn.nlark.com/yuque/__latex/c895173d3be4872abf206be4268a58cb.svg),![image](https://cdn.nlark.com/yuque/__latex/0e8c92172e820e4d5e05d6869e889b70.svg)编号为![image](https://cdn.nlark.com/yuque/__latex/dd1caa3f2e1582dab2cf9bfdb21b7556.svg)，我们考虑线段树节点![image](https://cdn.nlark.com/yuque/__latex/d08ed99ef04f607c4bbb11cdebacbeca.svg)，不难发现该节点一定包含![image](https://cdn.nlark.com/yuque/__latex/371d3811de80d3e7a448b5cebe095023.svg)且其![image](https://cdn.nlark.com/yuque/__latex/689295fb72b63ee1db32afb2f3bbe8b8.svg)一定在![image](https://cdn.nlark.com/yuque/__latex/371d3811de80d3e7a448b5cebe095023.svg)范围内。那么我们只要在![image](https://cdn.nlark.com/yuque/__latex/d08ed99ef04f607c4bbb11cdebacbeca.svg)得到查询![image](https://cdn.nlark.com/yuque/__latex/c508d653f6c416b13f7d5caefa25456a.svg)的信息即可。

那么询问复杂度为![image](https://cdn.nlark.com/yuque/__latex/5aafefbab4f605f4bf12dd13652b5a27.svg)。

为了方便求![image](https://cdn.nlark.com/yuque/__latex/a5f1a3b1ccbcb20d75ccf0efa8b7bb12.svg)，我们不妨把数组长度补位![image](https://cdn.nlark.com/yuque/__latex/5ba6a6ea8493a057d8a2222fe42e3908.svg)，这样建出的树会是一颗完美的满二叉树，那么我们对于线段树的每一层维护一个![image](https://cdn.nlark.com/yuque/__latex/1e8e8d06f79d50dc13a49e8935a6dc80.svg)数组即可，对于每次查询，我们从![image](https://cdn.nlark.com/yuque/__latex/0ed4e429fb69de3ef9edf438480e3e46.svg)跳到它们对应![image](https://cdn.nlark.com/yuque/__latex/a5f1a3b1ccbcb20d75ccf0efa8b7bb12.svg)所在的层数，公式为![image](https://cdn.nlark.com/yuque/__latex/8f2fd374813fbab6a1bd1b1644d8139f.svg)，我们在该层统计我们想要的信息即可，这样求![image](https://cdn.nlark.com/yuque/__latex/a5f1a3b1ccbcb20d75ccf0efa8b7bb12.svg)的复杂度为![image](https://cdn.nlark.com/yuque/__latex/a2006f1ac61cb1902beacb3e29fff089.svg)

```cpp

template <class T>
class SegmentTree
{
#define lc u << 1
#define rc u << 1 | 1
public:
    SegmentTree(const std::vector<T> &a) : val(a)
    {
        int cur = a.size() - 1;
        int log = std::__lg(cur);
        if ((1 << log) != cur)
        {
            ++log;
        }
        n = 1 << log;
        val.resize(n + 1);
        lg.resize(n + 1);
        id.resize(n + 1);
        std::fill(begin(val) + cur + 1, end(val), 0);
        info.resize(log + 1, std::vector<T>(n + 1));
        for (int i = 1; i <= n; ++i)
        {
            lg[i] = std::__lg(i);
        }
        auto build = [&](auto build, int u, int l, int r, int dep) -> void
        {
            int mid = l + r >> 1;
            for (int i = mid; i >= l; --i)
            {
                info[dep][i] = (i == mid ? val[i] : merge(info[dep][i + 1], val[i]));
            }
            for (int i = mid + 1; i <= r; ++i)
            {
                info[dep][i] = (i == mid + 1 ? val[i] : merge(info[dep][i - 1], val[i]));
            }
            if (l == r)
            {
                id[l] = u; // 编号是谁
                return;
            }
            build(build, lc, l, mid, dep + 1);
            build(build, rc, mid + 1, r, dep + 1);
        };
        build(build, 1, 1, n, 0);
    }

    T query(int l, int r)
    {
        if (l == r)
        {
            return val[l];
        }
        int d = lg[id[l]] - lg[id[l] ^ id[r]] - 1;
        return merge(info[d][l], info[d][r]);
    }

private:
    int n;
    std::vector<T> val;
    std::vector<std::vector<T>> info;
    std::vector<int> lg;
    std::vector<int> id;
    T merge(T a, T b)
    {
    }
};
```

#### 维护前后缀最大/最小值和
你需要维护一个排列（序列也行）,有单点修改操作，存在一个函数![image](https://cdn.nlark.com/yuque/__latex/3818937ac554603003e6727783932e9f.svg),每次操作后，需要你输出所有位置![image](https://cdn.nlark.com/yuque/__latex/2443fbcfeb7e85e1d62b6f5e4f27207e.svg)的函数值之和,其中![image](https://cdn.nlark.com/yuque/__latex/2443fbcfeb7e85e1d62b6f5e4f27207e.svg)位置的值必须是前缀最小值,我们记这个和为![image](https://cdn.nlark.com/yuque/__latex/8597b8ad64ac82614635dd0459956516.svg)

我们考虑用线段树维护，每个区间维护![image](https://cdn.nlark.com/yuque/__latex/994322615398048126a9c01c53a11a93.svg)和![image](https://cdn.nlark.com/yuque/__latex/8597b8ad64ac82614635dd0459956516.svg),问题在于修改时如何合并两个区间的![image](https://cdn.nlark.com/yuque/__latex/8597b8ad64ac82614635dd0459956516.svg)，我们分两部分考虑

注意到前缀最小值的性质，一个区间的左子区间一定有贡献，因为第一个一定满足，然后我们根据左子区间的最小值![image](https://cdn.nlark.com/yuque/__latex/8f547fc57221ba7c2df1084c0e666477.svg)，记这个值为![image](https://cdn.nlark.com/yuque/__latex/df976ff7fcf17d60490267d18a1e3996.svg),来递归求解右子区间的贡献,我们写一个![image](https://cdn.nlark.com/yuque/__latex/6e4d37491dff9a939ae840a38642e2a2.svg)函数

在递归函数![image](https://cdn.nlark.com/yuque/__latex/6e4d37491dff9a939ae840a38642e2a2.svg)中,如果![image](https://cdn.nlark.com/yuque/__latex/5e0f4b5ecdff2b8d1936bce4b97eb586.svg)那么说明左区间一定没贡献，我们直接递归右边，否则，左区间一定存在贡献，当左区间存在贡献时，右区间的贡献一定全部有效，因为右区间能贡献的值一定小于![image](https://cdn.nlark.com/yuque/__latex/8f547fc57221ba7c2df1084c0e666477.svg),因此我们单次操作复杂度![image](https://cdn.nlark.com/yuque/__latex/a0506dd3331bbca44510ba4dea0e2781.svg),实际上是把![image](https://cdn.nlark.com/yuque/__latex/e0d4aac8c4706ee30e2aa1d4f02db543.svg)的![image](https://cdn.nlark.com/yuque/__latex/477d74b83dc0d30cae6608207b4f6946.svg)变成了![image](https://cdn.nlark.com/yuque/__latex/1b0fce2bd1f5925667628ba7a81a4635.svg)

```cpp
struct SegmentTree//所有前缀最小值位置的f函数值之和
{
#define lc u << 1
#define rc u << 1 | 1
    struct Node
    {
        int l, r;
        Z val;
        int mi;
    };
    int n;
    std::vector<Node> tr;

    SegmentTree(int t) : n(t + 1), tr(4 * n)
    {
        n--;
        std::function<void(int, int, int)> build = [&](int u, int l, int r)
        {
            tr[u] = {l, r};
            if (l == r)
            {
                return;
            }
            int mid = l + r >> 1;
            build(lc, l, mid);
            build(rc, mid + 1, r);
        };
        build(1, 1, n);
    }
    Z count(int u, int l, int r, int cur)
    {
        if (l == r)
        {
            return tr[u].mi < cur ? f[l] : Z{0};//能不能做贡献
        }
        int mid = l + r >> 1;
        if (tr[lc].mi > cur)//左边的最小值>cur 一定没贡献
        {
            return count(rc, mid + 1, r, cur);//递归右边
        }
        else
        {
            return tr[u].val - tr[lc].val + count(lc, l, mid, cur);
            //因为tr[lc].mi<cur 而右区间的贡献被左区间最小值限制，左区间最小值满足情况
            //所以右区间一定都能做贡献
        }
    }
    void modify(int u, int l, int r, int x, int y)
    {
        if (l == r)
        {
            tr[u].mi = y;//最小值一定是自己
            tr[u].val = f[l];//
            return;
        }
        int mid = l + r >> 1;
        if (x <= mid)
        {
            modify(lc, l, mid, x, y);
        }
        else
        {
            modify(rc, mid + 1, r, x, y);
        }
        
        tr[u].mi = std::min(tr[lc].mi, tr[rc].mi);
        tr[u].val = tr[lc].val + count(rc, mid + 1, r, tr[lc].mi);
        //pushup函数变成了这个
        //左区间一定产生贡献 右区间我们需要具体统计  也就是说只有小于我的才产生贡献
    }
};
```

#### 二维线段树
```cpp
template <typename T>
class SegmentTree2D
{
private:
    int n, m; // 矩阵维度
    std::vector<std::vector<T>> min;
    std::vector<std::vector<T>> max;
    std::vector<std::vector<T>> sum;
    T inf;

public:
    // 构造函数：初始化并构建线段树
    SegmentTree2D(const std::vector<std::vector<T>> &matrix)
    {
        if (matrix.empty() || matrix[0].empty())
            return;

        n = matrix.size();
        m = matrix[0].size();
        const int x = 4 * n;
        const int y = 4 * m;

        // 初始化树结构
        min.resize(x, std::vector<T>(y));
        max.resize(x, std::vector<T>(y));
        sum.resize(x, std::vector<T>(y));

        inf = std::numeric_limits<T>::max() / 2;

        buildX(1, 1, n, matrix);
    }

    // 单点更新：(x, y) 位置的值增加 delta
    void update(int x, int y, T delta)
    {
        if (x < 1 || x > n || y < 1 || y > m)
            return;
        updateX(1, 1, n, x, y, delta);
    }

    // 区间查询：返回 [x1, x2] × [y1, y2] 范围内的统计信息
    struct QueryResult
    {
        T min;
        T max;
        T sum;
    };

    QueryResult query(int x1, int y1, int x2, int y2) const
    {
        if (x1 > x2 || y1 > y2 || x1 < 1 || x2 > n || y1 < 1 || y2 > m)
        {
            return {inf, -inf, T{}};
        }

        QueryResult result = {inf, -inf, T{}};
        queryX(1, 1, n, x1, x2, y1, y2, result);
        return result;
    }

private:
    // 内层树的向上合并（Y 方向）
    void pushupY(int u, int v)
    {
        min[u][v] = std::min(min[u][v << 1], min[u][v << 1 | 1]);
        max[u][v] = std::max(max[u][v << 1], max[u][v << 1 | 1]);
        sum[u][v] = sum[u][v << 1] + sum[u][v << 1 | 1];
    }

    // 外层树的向上合并（X 方向）
    void pushupX(int u, int v)
    {
        min[u][v] = std::min(min[u << 1][v], min[u << 1 | 1][v]);
        max[u][v] = std::max(max[u << 1][v], max[u << 1 | 1][v]);
        sum[u][v] = sum[u << 1][v] + sum[u << 1 | 1][v];
    }

    // 构建内层树（Y 方向）
    void buildY(int u, int v, int l, int r, const std::vector<std::vector<T>> &matrix, int x)
    {
        if (l == r)
        {
            if (x != 0)
            { // 叶子节点
                min[u][v] = max[u][v] = sum[u][v] = matrix[x - 1][l - 1];
            }
            else
            { // 非叶子节点（合并子树）
                pushupX(u, v);
            }
            return;
        }

        int mid = (l + r) / 2;
        buildY(u, v << 1, l, mid, matrix, x);
        buildY(u, v << 1 | 1, mid + 1, r, matrix, x);
        pushupY(u, v);
    }

    // 构建外层树（X 方向）
    void buildX(int u, int l, int r, const std::vector<std::vector<T>> &matrix)
    {
        if (l == r)
        {
            buildY(u, 1, 1, m, matrix, l);
            return;
        }

        int mid = (l + r) / 2;
        buildX(u << 1, l, mid, matrix);
        buildX(u << 1 | 1, mid + 1, r, matrix);
        buildY(u, 1, 1, m, matrix, 0); // 非叶子节点
    }

    // 内层树的更新（Y 方向）
    void updateY(int u, int v, int l, int r, int y, T delta, int x)
    {
        if (l == r)
        {
            if (x != 0)
            { // 叶子节点
                min[u][v] += delta;
                max[u][v] += delta;
                sum[u][v] += delta;
            }
            else
            { // 非叶子节点
                pushupX(u, v);
            }
            return;
        }

        int mid = (l + r) / 2;
        if (y <= mid)
        {
            updateY(u, v << 1, l, mid, y, delta, x);
        }
        else
        {
            updateY(u, v << 1 | 1, mid + 1, r, y, delta, x);
        }
        pushupY(u, v);
    }

    // 外层树的更新（X 方向）
    void updateX(int u, int l, int r, int x, int y, T delta)
    {
        if (l == r)
        {
            updateY(u, 1, 1, m, y, delta, l);
            return;
        }

        int mid = (l + r) / 2;
        if (x <= mid)
        {
            updateX(u << 1, l, mid, x, y, delta);
        }
        else
        {
            updateX(u << 1 | 1, mid + 1, r, x, y, delta);
        }
        updateY(u, 1, 1, m, y, delta, 0); // 非叶子节点
    }

    // 内层树的查询（Y 方向）
    void queryY(int u, int v, int l, int r, int y1, int y2, QueryResult &res) const
    {
        if (y1 <= l && r <= y2)
        {
            res.min = std::min(res.min, min[u][v]);
            res.max = std::max(res.max, max[u][v]);
            res.sum += sum[u][v];
            return;
        }

        int mid = (l + r) / 2;
        if (y1 <= mid)
        {
            queryY(u, v << 1, l, mid, y1, y2, res);
        }
        if (y2 > mid)
        {
            queryY(u, v << 1 | 1, mid + 1, r, y1, y2, res);
        }
    }

    // 外层树的查询（X 方向）
    void queryX(int u, int l, int r, int x1, int x2, int y1, int y2, QueryResult &res) const
    {
        if (x1 <= l && r <= x2)
        {
            queryY(u, 1, 1, m, y1, y2, res);
            return;
        }
        int mid = (l + r) / 2;
        if (x1 <= mid)
        {
            queryX(u << 1, l, mid, x1, x2, y1, y2, res);
        }
        if (x2 > mid)
        {
            queryX(u << 1 | 1, mid + 1, r, x1, x2, y1, y2, res);
        }
    }
};
```

#### 维护扫描线
##### 矩形周长并
```cpp
class RectanglePerimeter
{
#define lc u << 1
#define rc u << 1 | 1
private:
    // 扫描线结构体
    struct ScanLine
    {
        int l;
        int r;
        int y;
        int tag; // 入边:+1, 出边:-1

        // 比较运算符：按y排序，相同y时入边优先
        bool operator<(const ScanLine &other) const
        {
            return y == other.y ? tag > other.tag : y < other.y;
        }
    };

    // 线段树节点结构体
    struct Node
    {
        int l;           // 区间左端点(离散化后)
        int r;           // 区间右端点(离散化后)
        int coverCnt;    // 覆盖次数
        int coverLen;    // 覆盖长度
        int lineCnt;     // 垂直边数量
        bool isCoveredL; // 左端点是否被覆盖
        bool isCoveredR; // 右端点是否被覆盖

        // 默认构造函数
        Node() : l(0), r(0), coverCnt(0), coverLen(0),
                 lineCnt(0), isCoveredL(false), isCoveredR(false) {}
    };

    std::vector<ScanLine> scanLines; // 扫描线数组
    std::vector<int> xIdx;           // 离散化后的x坐标
    std::vector<Node> tr;            // 线段树节点数组

    // 建树
    void build(int u, int l, int r)
    {
        tr[u].l = l;
        tr[u].r = r;
        if (l == r)
            return;
        int mid = (l + r) / 2;
        build(u * 2, l, mid);
        build(u * 2 + 1, mid + 1, r);
    }

    // 上传父节点信息
    void pushUp(int u)
    {
        if (tr[u].coverCnt > 0)
        {
            // 区间被覆盖，计算真实长度
            tr[u].coverLen = xIdx[tr[u].r + 1] - xIdx[tr[u].l];
            tr[u].lineCnt = 2;
            tr[u].isCoveredL = true;
            tr[u].isCoveredR = true;
        }
        else if (tr[u].l == tr[u].r)
        {
            // 叶子节点且未被覆盖
            tr[u].coverLen = 0;
            tr[u].lineCnt = 0;
            tr[u].isCoveredL = false;
            tr[u].isCoveredR = false;
        }
        else
        {
            // 合并子节点信息
            tr[u].coverLen = tr[u * 2].coverLen + tr[u * 2 + 1].coverLen;
            tr[u].lineCnt = tr[u * 2].lineCnt + tr[u * 2 + 1].lineCnt;
            tr[u].isCoveredL = tr[u * 2].isCoveredL;
            tr[u].isCoveredR = tr[u * 2 + 1].isCoveredR;
            // 如果左右子节点相连，合并垂直边
            if (tr[u * 2].isCoveredR && tr[u * 2 + 1].isCoveredL)
            {
                tr[u].lineCnt -= 2;
            }
        }
    }

    // 区间更新
    void rangeUpdate(int u, int l, int r, int tag)
    {
        if (l > tr[u].r || r < tr[u].l)
            return;
        if (l <= tr[u].l && tr[u].r <= r)
        {
            tr[u].coverCnt += tag;
            pushUp(u);
            return;
        }
        rangeUpdate(lc, l, r, tag);
        rangeUpdate(rc, l, r, tag);
        pushUp(u);
    }

public:
    // 计算矩形轮廓周长
    int calculatePerimeter(const std::vector<std::array<int, 4>> &rectangles)
    {
        int n = rectangles.size();
        if (n == 0)
            return 0;

        // 初始化扫描线和x坐标数组
        scanLines.resize(n * 2);
        xIdx.resize(n * 2);

        // 生成扫描线和收集x坐标
        for (int i = 0; i < n; ++i)
        {
            const auto &rect = rectangles[i];
            int x1 = rect[0];
            int y1 = rect[1];
            int x2 = rect[2];
            int y2 = rect[3];

            // 下边界(入边)
            scanLines[i] = {x1, x2, y1, 1};
            // 上边界(出边)
            scanLines[i + n] = {x1, x2, y2, -1};

            xIdx[i] = x1;
            xIdx[i + n] = x2;
        }

        // 排序扫描线
        std::sort(scanLines.begin(), scanLines.end());

        // 离散化x坐标
        std::sort(xIdx.begin(), xIdx.end());
        auto last = std::unique(xIdx.begin(), xIdx.end());
        xIdx.erase(last, xIdx.end());
        int s = xIdx.size();
        if (s < 2)
            return 0;

        // 初始化线段树
        tr.resize(s * 8);
        build(1, 0, s - 2);

        int res = 0;
        int lastLength = 0;

        // 处理扫描线
        for (size_t i = 0; i < scanLines.size(); ++i)
        {
            // 查找离散化后的区间
            int l = std::lower_bound(xIdx.begin(), xIdx.end(), scanLines[i].l) - xIdx.begin();
            int r = std::lower_bound(xIdx.begin(), xIdx.end(), scanLines[i].r) - xIdx.begin();

            // 确保区间有效
            if (l < r)
            {
                rangeUpdate(1, l, r - 1, scanLines[i].tag);
            }

            // 计算水平轮廓线
            if (i < scanLines.size() - 1)
            {
                res += std::abs(tr[1].coverLen - lastLength);
                lastLength = tr[1].coverLen;

                // 计算垂直轮廓线
                res += tr[1].lineCnt * (scanLines[i + 1].y - scanLines[i].y);
            }
        }

        // 处理最后一条扫描线的水平边
        res += std::abs(tr[1].coverLen - lastLength);

        return res;
    }
};
```

##### 矩形面积并
需要注意的是离散化以后每个点代表的是一段距离![image](https://cdn.nlark.com/yuque/__latex/a73b8a2d259fef7fc6fd89e583706208.svg)，其中![image](https://cdn.nlark.com/yuque/__latex/72cb3a229067770aeb6caa625a65a1a1.svg)表示下一个点的左端点。

```cpp
template <class T>
struct SegmentTree
{
#define lc u << 1     // 左子节点索引
#define rc u << 1 | 1 // 右子节点索引

    // 线段结构体，表示水平或垂直的线段
    struct Line
    {
        int x1, x2; // 线段的左右x坐标
        int y;      // 线段的y坐标
        int tag;    // 标记：+1表示矩形开始边，-1表示矩形结束边

        // 重载小于运算符，用于按y坐标排序
        bool operator<(Line &t)
        {
            return y < t.y;
        }
    };

    std::vector<Line> L;  // 存储所有线段
    std::vector<int> cnt; // 记录节点被覆盖的次数
    std::vector<int> len; // 记录节点代表的区间被覆盖的总长度
    std::vector<int> X;   // 存储所有x坐标用于离散化
    T ans = 0;            // 最终的面积结果

    // 向上更新节点信息
    void pushup(int u, int l, int r)
    {
        // 如果当前区间被完全覆盖
        if (cnt[u])
        {
            // 直接计算区间长度（注意X是离散化后的坐标）
            len[u] = X[r + 1] - X[l]; // r对应X[r+1]是因为离散化处理
        }
        else
        {
            // 否则合并子区间的长度
            len[u] = len[lc] + len[rc];
        }
    }

    // 区间修改函数
    void change(int u, int l, int r, int x, int y, int tag)
    {
        // 完全覆盖当前区间
        if (x <= l and y >= r)
        {
            cnt[u] += tag;   // 更新覆盖次数
            pushup(u, l, r); // 更新长度信息
            return;
        }

        int mid = l + r >> 1; // 计算中点

        // 处理左子区间
        if (x <= mid)
        {
            change(lc, l, mid, x, y, tag);
        }
        // 处理右子区间
        if (y > mid)
        {
            change(rc, mid + 1, r, x, y, tag);
        }

        pushup(u, l, r); // 合并子区间信息
    }

    // 构造函数，初始化线段树并计算面积
    SegmentTree(int n, std::vector<std::array<int, 4>> &a)
        : L(2 * n + 1),   // 每个矩形有两条边（开始和结束）
          X(2 * n + 1),   // 存储所有x坐标
          cnt(16 * n + 1), // 覆盖次数数组，预留足够空间
          len(16* n + 1)  // 长度数组，预留足够空间
    {
        // 处理每个矩形，生成线段
        for (int i = 1; i <= n; ++i)
        {
            auto [x1, y1, x2, y2] = a[i - 1]; // 解构矩形坐标

            // 矩形下边（开始边）
            L[i] = {x1, x2, y1, 1};
            // 矩形上边（结束边）
            L[n + i] = {x1, x2, y2, -1};

            // 存储x坐标用于离散化
            X[i] = x1;
            X[n + i] = x2;
        }

        n = n * 2; // 现在n表示线段数量

        // 按y坐标排序所有线段（扫描线算法需要）
        std::sort(begin(L) + 1, end(L));
        // 对x坐标排序（离散化准备）
        std::sort(begin(X) + 1, end(X));
        int s = std::unique(begin(X) + 1, end(X)) - begin(X) - 1;

        // 扫描线算法主循环
        for (int i = 1; i < n; i++)
        {
            // 在离散化后的x坐标中找到当前线段的左右边界
            int l = std::lower_bound(begin(X) + 1, begin(X) + s + 1, L[i].x1) - begin(X);
            int r = std::lower_bound(begin(X) + 1, begin(X) + s + 1, L[i].x2) - begin(X);

            // 如果区间有效（l <= r-1）
            if (l <= r - 1)
            {
                // 更新线段树（注意r-1是因为离散化处理）
                change(1, 1, s, l, r - 1, L[i].tag);
            }

            // 计算当前扫描线与下一条扫描线之间的面积
            ans += 1ll * (L[i + 1].y - L[i].y) * len[1];
        }
    }
};
```

#### 线段树懒标记合并
考虑一种特殊的标记

定义![image](https://cdn.nlark.com/yuque/__latex/fda17667a3e8a047cf101592cd95f763.svg)表示![image](https://cdn.nlark.com/yuque/__latex/55ed20c9c6386ae6a4e164d974275e57.svg)

考虑合并标记即

![image](https://cdn.nlark.com/yuque/__latex/716b17f361c1ad4e75cada0843b6c89c.svg)

等价于![image](https://cdn.nlark.com/yuque/__latex/9624da6ac3c3a24c0f8e142a822a6863.svg)

结论是

![image](https://cdn.nlark.com/yuque/__latex/18e63101d01e6d155b0addd51167a9b0.svg)

![image](https://cdn.nlark.com/yuque/__latex/92fbbe00b5669df1136e59f11c2a79bf.svg)

![image](https://cdn.nlark.com/yuque/__latex/8b123a56b68fe70b710847575198a3b2.svg)



## 主席树
### 维护值域
```cpp

template <class T>
class PresidentTree
{
private:
    // 线段树节点结构体
    struct Node
    {
        int val; // 节点值（通常是区间统计值）
        int l, r;
        T sum;                                              // 左右子节点索引
        Node(int val = 0) : val{val}, l{0}, r{0}, sum{0} {} // 构造函数，默认左右子节点为0（空）
    };

    std::vector<Node> tr;    // 动态节点存储数组
    const int Start, Last;   // 值域范围 [Start, Last]
    std::vector<int> root;   // 各版本根节点索引数组
    int newNode(int val = 0) // 创建新节点
    {
        tr.emplace_back(Node(val)); // 在数组末尾添加新节点
        return tr.size() - 1;       // 返回新节点索引
    }

    // 向上更新节点值（基于子节点）
    void pushup(int u)
    {
        tr[u].val = tr[tr[u].l].val + tr[tr[u].r].val; // 当前节点值为左右子节点值之和
        tr[u].sum = tr[tr[u].l].sum + tr[tr[u].r].sum;
    }

    // 插入操作（动态开点）
    void insert(int &u, int l, int r, int x)
    {
        if (u == 0) // 如果当前节点不存在
        {
            u = newNode(); // 创建新节点
        }
        if (l == r) // 到达叶子节点
        {
            tr[u].val++; // 增加计数（用于统计出现次数）
            tr[u].sum += l;
            return;
        }
        int mid = l + r >> 1; // 计算中点
        if (x <= mid)         // 目标在左子树
        {
            insert(tr[u].l, l, mid, x); // 递归处理左子树
        }
        else // 目标在右子树
        {
            insert(tr[u].r, mid + 1, r, x); // 递归处理右子树
        }
        pushup(u); // 更新当前节点值
    }

    // 合并两棵线段树（用于构建版本链）
    int merge(int u, int v, int l, int r)
    {
        if (!u or !v) // 如果任一节点为空
        {
            return (u ? u : v); // 返回非空的那个
        }
        if (l == r) // 到达叶子节点
        {
            tr[u].val += tr[v].val; // 合并统计值
            tr[u].sum += tr[v].sum;
            return u;
        }
        int mid = l + r >> 1;                          // 计算中点
        tr[u].l = merge(tr[u].l, tr[v].l, l, mid);     // 递归合并左子树
        tr[u].r = merge(tr[u].r, tr[v].r, mid + 1, r); // 递归合并右子树
        pushup(u);                                     // 更新当前节点值
        return u;                                      // 返回合并后的树根
    }

    // 查询区间 [x,y] 内的元素个数（版本u到v之间的变化）
    int getRange(int u, int v, int l, int r, int x, int y)
    {
        if (y < l or x > r) // 查询区间与当前区间无交集
        {
            return 0;
        }
        if (x <= l and y >= r) // 当前区间完全包含在查询区间内
        {
            return tr[v].val - tr[u].val; // 返回版本间的差值
        }
        int mid = l + r >> 1; // 计算中点
        int res = 0;
        if (x <= mid) // 查询左子树
        {
            res += getRange(tr[u].l, tr[v].l, l, mid, x, y);
        }
        if (y > mid) // 查询右子树
        {
            res += getRange(tr[u].r, tr[v].r, mid + 1, r, x, y);
        }
        return res;
    }

    // 查询第k小的元素（版本u到v之间）
    int getKth(int u, int v, int l, int r, int k)
    {
        if (l == r) // 到达叶子节点
        {
            return l; // 返回该值
        }
        int mid = l + r >> 1;                      // 计算中点
        int L = tr[tr[v].l].val - tr[tr[u].l].val; // 左子树元素个数
        if (L >= k)                                // 第k小在左子树
        {
            return getKth(tr[u].l, tr[v].l, l, mid, k);
        }
        else // 第k小在右子树
        {
            return getKth(tr[u].r, tr[v].r, mid + 1, r, k - L); // 注意k要减去左子树元素数
        }
    }
    T queryKthSum(int u, int v, int l, int r, int k) // 前k大的数之和
    {
        if (!k)
        {
            return 0;
        }
        if (l == r)
        {
            return (T)l * k;
        }
        int cnt = tr[tr[u].r].val - tr[tr[v].r].val;
        int mid = l + r >> 1;
        if (cnt >= k)
        {
            return queryKthSum(tr[u].r, tr[v].r, mid + 1, r, k);
        }
        else
        {
            return tr[tr[u].r].sum - tr[tr[v].r].sum + queryKthSum(tr[u].l, tr[v].l, l, mid, k - cnt);
        }
    }

public:
    // 构造函数：基于数组a初始化，值域范围[mi, ma]
    PresidentTree(const std::vector<int> &a, int mi, int ma)
        : root(a.size()), Start(mi), Last(ma), tr(1) // 初始化
    {
        // 预分配空间（优化性能）
        tr.reserve(a.size() * std::__lg(2 * a.size()));
        root[0] = newNode(); // 创建初始版本（空树）

        // 构建各版本
        for (int i = 1; i <= a.size() - 1; ++i)
        {
            // 空间不足时扩容
            if (tr.capacity() <= tr.size() + 64)
            {
                tr.reserve(std::max(2 * tr.capacity(), tr.capacity() + 64));
            }
            insert(root[i], Start, Last, a[i]);                 // 插入当前元素
            root[i] = merge(root[i], root[i - 1], Start, Last); // 合并到前一版本
        }
    }

    // 查询区间 [u,v] 中值在 [l,r] 范围内的元素个数
    int getRange(int u, int v, int l, int r)
    {
        return getRange(root[u - 1], root[v], Start, Last, l, r);
    }

    // 查询区间 [u,v] 中第k小的元素
    int getKth(int u, int v, int k)
    {
        return getKth(root[u - 1], root[v], Start, Last, k);
    }
    T getKthSum(int u, int v, int k)
    {
        return getKthSum(root[u - 1], root[v], Start, Last, k);
    }
};

```

### 维护历史版本
在维护历史版本的主席树中，我们可以支持在新开版本时实现区间加，使用标记永久化的技巧即可。

```cpp
template <class T>
class PresidentTree
{
public:
    // 构造函数：使用给定数组a初始化主席树，capacity指定预分配空间大小
    PresidentTree(const std::vector<int> &a, int capacity)
        : n(a.size()),      // 数组长度
          root(n),          // 各版本根节点数组
          lc(capacity + 1), // 左子节点数组（+1防止越界）
          rc(capacity + 1), // 右子节点数组
          sum(capacity + 1) // 节点和数组
    {
        // 递归构建初始版本线段树的lambda函数
        std::function<void(int &, int, int)> build = [&](int &u, int l, int r)
        {
            u = ++idx;  // 分配新节点，idx从1开始
            if (l == r) // 叶子节点
            {
                sum[u] = a[l]; // 存储数组值
                return;
            }
            int mid = l + r >> 1;     // 计算中点
            build(lc[u], l, mid);     // 递归构建左子树
            build(rc[u], mid + 1, r); // 递归构建右子树
            pushup(u);                // 合并子节点信息
        };
        build(root[0], 1, n - 1); // 构建初始版本（版本0），基于数组索引
    }

private:
    int idx = 0;           // 节点计数器，从1开始分配
    int n;                 // 数组长度
    std::vector<int> root; // 各版本根节点数组
    std::vector<int> lc;   // 左子节点数组
    std::vector<int> rc;   // 右子节点数组
    std::vector<T> sum;    // 节点和数组（使用long long类型）

    // 向上合并子节点信息
    void pushup(int u)
    {
        sum[u] = sum[lc[u]] + sum[rc[u]]; // 当前节点和为左右子节点和之和
    }

    // 插入新版本：基于版本v创建新版本u，在pos位置更新值为x
    void insertNewVersion(int &u, int v, int l, int r, int pos, int x)
    {
        u = ++idx; // 分配新节点（关键：必须创建新节点以实现可持久化）

        // 复制旧版本v的信息
        lc[u] = lc[v];
        rc[u] = rc[v];
        sum[u] = sum[v];

        if (l == r) // 到达目标位置
        {
            sum[u] = x; // 更新值
            return;
        }

        int mid = l + r >> 1; // 计算中点
        if (pos <= mid)       // 目标在左子树
        {
            // 递归处理左子树，创建新路径
            insertNewVersion(lc[u], lc[v], l, mid, pos, x);
        }
        else // 目标在右子树
        {
            // 递归处理右子树，创建新路径
            insertNewVersion(rc[u], rc[v], mid + 1, r, pos, x);
        }
        pushup(u); // 更新当前节点信息
    }
};
```

### 维护树上信息
我们在线段树合并部分其实已经涉及此问题，我们认为线段树合并就是一种树上主席树类似的结构。

但是线段树合并长于维护子树信息，在维护链上问题时几乎束手无策,因此我们需要想新的办法

我们引出树上主席树，其本质仍然是主席树，只不过把区间变成了树，树实际上可以转化为不同的序列，我们按特定的顺序建主席树的方法，称为树上主席树,分两种，分别为![image](https://cdn.nlark.com/yuque/__latex/ab9beef7db741e3cc3445e9070df572e.svg)序和![image](https://cdn.nlark.com/yuque/__latex/40e0b9f3427d7c821289b81883ff5776.svg)序

##### DFS序
![image](https://cdn.nlark.com/yuque/__latex/ab9beef7db741e3cc3445e9070df572e.svg)序建立的主席树可以解决树链上的值域问题，我们按![image](https://cdn.nlark.com/yuque/__latex/65a3fe4bfdefd5ee1936a2f0c526111a.svg)序遍历的顺序来建树，每次基于的版本来自其父节点的版本，那么怎么转化为树链呢？我们采用树上差分的思想即可。

##### BFS序
按![image](https://cdn.nlark.com/yuque/__latex/194d47626354143208e9eb2dd1785d70.svg)排序,也就是我们以![image](https://cdn.nlark.com/yuque/__latex/194d47626354143208e9eb2dd1785d70.svg)为依据加点，每个节点基于的版本是上一个![image](https://cdn.nlark.com/yuque/__latex/194d47626354143208e9eb2dd1785d70.svg)相同的节点，如果没有则基于![image](https://cdn.nlark.com/yuque/__latex/42399d9f30d856d9df5a08151a2e8ea9.svg)新开版本即可。

主要面向的问题是，对节点![image](https://cdn.nlark.com/yuque/__latex/0a25ff5d5f49aeb7283b1b06cf5b55d5.svg)，询问其子树内深度小于等于![image](https://cdn.nlark.com/yuque/__latex/56c1b0cb7a48ccf9520b0adb3c8cb2e8.svg)的信息，注意到虽然完整子树的![image](https://cdn.nlark.com/yuque/__latex/65a3fe4bfdefd5ee1936a2f0c526111a.svg)序连续，但是只截取部分深度是不连续的。但按我们这样建立的主席树，相同深度的节点将是同一个版本，也就可以解决这一类问题。但是其他子树内也存在深度小于等于![image](https://cdn.nlark.com/yuque/__latex/56c1b0cb7a48ccf9520b0adb3c8cb2e8.svg)的节点，怎么办呢？注意到主席树实际上可以限制两维信息，分别是版本区间和内层值域区间，我们只需要限制值域为![image](https://cdn.nlark.com/yuque/__latex/6437a9cafad4ca56400ec617f44658fd.svg)即可

## 树状数组
#### 树状数组
```cpp
template <class T>
struct BIT // 单点修改 区间查询
{
    int n;
    std::vector<T> a;
    int lowbit(int x)
    {
        return x & (-x);
    }
    void add(int pos, T x)
    {
        for (int i = pos; i <= n - 1; i += lowbit(i))
        {
            a[i] += x;
        }
    }
    BIT(int n) : n(n), a(n) {} // 空构造
    BIT(const std::vector<T> &t) : n(t.size()), a(n)
    {
        a.assign(n, 0);
        for (int i = 1; i <= n - 1; ++i)
        {
            add(i, t[i]);
        }
    }
    T getsum(int x)
    {
        T res = 0;
        for (int i = x; i; i -= lowbit(i))
        {
            res += a[i];
        }
        return res;
    }
};
```

#### 二维树状数组
```cpp
template <class T>
struct BIT
{
    int n, m;
    std::vector<std::vector<T>> a;
    int lowbit(int x)
    {
        return x & (-x);
    }
    BIT(int n, int m) : n(n), m(m)
    {
        a.assign(n + 1, std::vector<T>(m + 1, 0));
    }
    BIT(std::vector<std::vector<T>> &val) : n(val.size() - 1), m(val[1].size() - 1)
    {
        a.assign(n + 1, std::vector<int>(m + 1, 0));
        for (int i = 1; i <= n; ++i)
        {
            for (int j = 1; j <= m; ++j)
            {
                add(i, j, a[i][j]);
            }
        }
    }

    void add(int x, int y, T val)
    {
        for (int i = x; i <= n; i += lowbit(i))
        {
            for (int j = y; j <= m; j += lowbit(j))
            {
                a[i][j] += val;
            }
        }
    }
    T query(int x, int y)
    {
        T res = 0;
        for (int i = x; i >= 1; i -= lowbit(i))
        {
            for (int j = y; j >= 1; j -= lowbit(j))
            {
                res += a[i][j];
            }
        }
        return res;
    }

    T query(int x1, int y1, int x2, int y2)
    {
        return query(x2, y2) - query(x1 - 1, y2) - query(x2, y1 - 1) + query(x1 - 1, y1 - 1);
    }
};
```

#### 维护矩形区间加
```cpp
template <class T>
struct Bit
{
    int n, m;
    BIT<T> A, Ai, Aj, Aij;
    Bit(int n, int m) : n(n), m(m), A(n, m), Ai(n, m), Aj(n, m), Aij(n, m) // 只用空构造
    {
    }

    void add(int x, int y, T val)
    {
        A.add(x, y, val);
        Ai.add(x, y, x * val);
        Aj.add(x, y, y * val);
        Aij.add(x, y, x * y * val);
    }
    void add(int x1, int y1, int x2, int y2, T val)
    {
        add(x1, y1, val);
        add(x1, y2 + 1, -val);
        add(x2 + 1, y1, -val);
        add(x2 + 1, y2 + 1, val);
    }

    T query(int x, int y)
    {
        return ((T)x * y + x + y + 1) * A.query(x, y) - Ai.query(x, y) * (y + 1) - Aj.query(x, y) * (x + 1) + Aij.query(x, y);
    }

    T query(int x1, int y1, int x2, int y2)
    {
        return query(x2, y2) - query(x1 - 1, y2) - query(x2, y1 - 1) + query(x1 - 1, y1 - 1);
    }
};

```

## ST表
#### 返回权值
```cpp
template <class T>
class ST
{
    std::vector<std::vector<T>> st;

public:
    ST(const std::vector<T> &a)
    {
        int n = a.size() - 1, logn = std::__lg(n);
        st.assign(logn + 1, std::vector<int>(n + 1));
        for (int i = 1; i <= n; ++i)
        {
            st[0][i] = a[i];
        }
        for (int j = 1; j <= logn; ++j)
        {
            for (int i = 1; i + (1 << j) - 1 <= n; ++i) // n-i+1=(1<<j)是边界
            {
                st[j][i] = std::max(st[j - 1][i], st[j - 1][i + (1 << (j - 1))]);
            } // i是当前位置 j是向右扩展(1<<j)个数字
        }
    }

    T operator()(int l, int r)
    {
        int log = std::__lg(r - l + 1);
        return std::max(st[log][l], st[log][r - (1 << log) + 1]);
    }
};
```

#### 返回位置
```cpp
template <class T>
class ST
{
    std::vector<std::vector<int>> st;
    std::vector<T> A;

public:
    ST(const std::vector<T> &a)
    {
        A = a;
        int n = a.size() - 1, logn = std::__lg(n);
        st.assign(logn + 1, std::vector<int>(n + 1));
        for (int i = 1; i <= n; ++i)
        {
            st[0][i] = i;
        }
        for (int j = 1; j <= logn; ++j)
        {
            for (int i = 1; i + (1 << j) - 1 <= n; ++i)
            {
                st[j][i] = (a[st[j - 1][i]] > a[st[j - 1][i + (1 << j - 1)]] ? st[j - 1][i] : st[j - 1][i + (1 << j - 1)]);
            }
        }
    }

    int operator()(int l, int r)
    {
        int log = std::__lg(r - l + 1);
        return (A[st[log][l]] > A[st[log][r - (1 << log) + 1]] ? st[log][l] : st[log][r - (1 << log) + 1]);
    }
};
```

#### 压位ST表
请注意传入参数<u>是左闭右开</u>

```cpp
template <class T, class Cmp = std::less<T>>
struct RMQ
{
    const Cmp cmp = Cmp();
    static constexpr unsigned B = 64;
    using u64 = unsigned long long;

    const int n;
    std::vector<std::vector<T>> a;
    std::vector<T> pre, suf, ini;
    std::vector<u64> stk;

    RMQ(const std::vector<T> &v) : n{v.size()}, pre{v}, suf{v}, ini{v}, stk(n)
    {
        if (n <= 0)
        {
            return;
        }
        const int M = (n - 1) / B + 1;
        const int lg = std::__lg(M);
        a.assign(lg + 1, std::vector<T>(M));

        for (int i = 0; i < M; i++)
        {
            a[0][i] = v[i * B];
            for (int j = 1; j < B && i * B + j < n; j++)
            {
                a[0][i] = std::min(a[0][i], v[i * B + j], cmp);
            }
        }
        for (int i = 1; i < n; i++)
        {
            if (i % B)
            {
                pre[i] = std::min(pre[i], pre[i - 1], cmp);
            }
        }
        for (int i = n - 2; i >= 0; i--)
        {
            if (i % B != B - 1)
            {
                suf[i] = std::min(suf[i], suf[i + 1], cmp);
            }
        }
        for (int j = 0; j < lg; j++)
        {
            for (int i = 0; i + (2 << j) <= M; i++)
            {
                a[j + 1][i] = std::min(a[j][i], a[j][i + (1 << j)], cmp);
            }
        }

        for (int i = 0; i < M; i++)
        {
            const int l = i * B;
            const int r = std::min(1U * n, l + B);
            u64 s = 0;
            for (int j = l; j < r; j++)
            {
                while (s && cmp(v[j], v[std::__lg(s) + l]))
                {
                    s ^= 1ULL << std::__lg(s);
                }
                s |= 1ULL << (j - l);
                stk[j] = s;
            }
        }
    }
    // [l, r)
    T operator()(int l, int r) const//左闭右开 用的时候需要--l 传入的数组下标从0起
    {
        if (l / B != (r - 1) / B)
        {
            T ans = std::min(suf[l], pre[r - 1], cmp);
            l = l / B + 1;
            r = r / B;
            if (l < r)
            {
                int k = std::__lg(r - l);
                ans = std::min({ans, a[k][l], a[k][r - (1 << k)]}, cmp);
            }
            return ans;
        }
        else
        {
            int x = B * (l / B);
            return ini[__builtin_ctzll(stk[r - 1] >> (l - x)) + l];
        }
    }
};
```

## 哈希表
这里是一个手写哈希表（速度很快）（第一个参数是数据类型，第二个是空间大小（同时也是mod数））最好开成一个质数。 

```cpp
using u64 = unsigned long long;

template <class T, int Mod>
class HashTable {
    struct Iterator {
        u64 *pKey;
        T *pVal;

        Iterator(u64 *pKey, T *pVal) : pKey{pKey}, pVal{pVal} {}

        Iterator operator++() {
            ++pKey;
            ++pVal;

            return *this;
        }

        bool operator!=(Iterator it) const {
            return pKey != it.pKey;
        }

        std::pair<u64, T> operator*() {
            return std::make_pair(*pKey, *pVal);
        }
    };

    Iterator begin() const {
        return Iterator(to + 1, val + 1);
    }

    Iterator end() const {
        return Iterator(to + tot + 1, val + tot + 1);
    }

    int hd[Mod], nt[Mod * 2], tot = 0;
    u64 to[Mod * 2];
    T val[Mod * 2];
public:
    void clear() {
        for (int i = 1; i <= tot; i++) {
            hd[to[i] % Mod] = 0;
        }
        tot = 0;
    }

    T operator()(u64 x) const {
        int u = x % Mod;
        for (int i = hd[u]; i > 0; i = nt[i]) {
            if (to[i] == x) {
                return val[i];
            }
        }
        return T{};
    }

    T &operator[](u64 x) {
        int u = x % Mod;
        for (int i = hd[u]; i > 0; i = nt[i]) {
            if (to[i] == x) {
                return val[i];
            }
        }
        to[++tot] = x;
        nt[tot] = hd[u];
        hd[u] = tot;
        return val[tot] = T{};
    }
};

HashTable<int, int(1e6) + 3> mp;
```

考虑使用安全的![image](https://cdn.nlark.com/yuque/__latex/e70dcaaf09091e6fd86014b2b511007c.svg)来代替（极快）

```cpp
std::mt19937 rnd((u64) new char);
struct T
{
    u64 operator()(u64 x) const
    {
        static const u64 s1 = rnd(), s2 = rnd(), s3 = rnd();
        x += s1;
        x = (x ^ (x >> 33)) * s2;
        x = (x ^ (x >> 30)) * s3;
        return x;
    }
};
__gnu_pbds::gp_hash_table<u64, u64, T> mp;

```

安全的![image](https://cdn.nlark.com/yuque/__latex/72cbca3ff823a8631b543d91bda00932.svg)(比![image](https://cdn.nlark.com/yuque/__latex/e70dcaaf09091e6fd86014b2b511007c.svg)慢很多)

```cpp
std::mt19937 rnd((u64) new char);
struct T
{
    u64 operator()(const u64 &x) const
    {
        static const u64 r = rnd();
        return x ^ r;
    }
};
std::unordered_map<u64, u64, T> mp;

```

## 前缀树
#### 前缀树
```cpp
template <class T, char Base>
struct PreTree
{
    int idx = 0;
    std::vector<std::vector<int>> ch;
    std::vector<int> cnt;
    PreTree(std::vector<std::string> s)
    {
        int num = 0;
        for (auto i : s)
        {
            num += i.length();
        }
        ch.assign(num + 1, std::vector<int>(T, 0));
        cnt.assign(num + 1, 0);
        for (auto i : s)
        {
            insert(i);
        }
    }
    void insert(std::string s)
    {
        int p = 0;
        int len = s.length();
        for (int i = 0; i < len; ++i)
        {
            int j = s[i] - Base;
            if (!ch[p][j])
            {
                ch[p][j] = ++idx;
            }
            p = ch[p][j];
            cnt[p]++;
        }
    }
    int query(std::string s)
    {
        int p = 0;
        int len = s.length();
        for (int i = 0; i < len; ++i)
        {
            int j = s[i] - Base;
            if (!ch[p][j])
            {
                return 0;
            }
            p = ch[p][j];
        }
        return cnt[p];
    }
};
```

#### 二进制前缀树
```cpp

template <int T, class G>
struct PreTree
{
    int idx = 0;
    std::vector<std::vector<int>> ch;
    std::vector<int> cnt;
    PreTree(std::vector<G> &a)
    {
        int n = a.size();
        ch.assign(n * T + 1, std::vector<int>(2, 0));
        cnt.assign(n * T + 1, 0);
        for (auto i : a)
        {
            insert(i);
        }
    }
    PreTree(int n)
    {
        ch.assign(n * T + 1, std::vector<int>(2, 0));
        cnt.assign(n * T + 1, 0);
    }
    void insert(G x)
    {
        int p = 0;
        for (int i = T; i >= 0; --i)
        {
            int j = x >> i & 1;
            if (!ch[p][j])
            {
                ch[p][j] = ++idx;
            }
            p = ch[p][j];
            cnt[p]++;
        }
    }
    void erase(G x) // 需要保证x存在
    {
        int p = 0;
        for (int i = T; i >= 0; --i)
        {
            int j = x >> i & 1;
            p = ch[p][j];
            cnt[p]--;
        }
    }
    G query(G x) // 求  与x异或的最大值
    {
        int p = 0;
        G res = 0;
        for (int i = T; i >= 0; --i)
        {
            int j = x >> i & 1;
            if (ch[p ^ 1][j])
            {
                p = ch[p ^ 1][j];
                res += 1ll << i;
            }
            else
            {
                p = ch[p][j];
                if (!p) // 在没有的时候一定要返回！
                {
                    return res;
                }
            }
        }
        return res;
    }
};

```

#### 可持久化二进制前缀树
```cpp

template <int T, class G>
struct PreTree
{
    int idx = 1;
    std::vector<std::vector<bool>> ch;
    std::vector<int> cnt;
    std::vector<int> root;
    PreTree(std::vector<G> &a, int capacity) : root(a.size())
    {
        ch.assign(capacity + 1, std::vector<bool>(2, 0));
        cnt.assign(capacity + 1, 0);
        root[0] = 1;
        for (int i = 1; i < a.size(); ++i)
        {
            root[i] = ++idx;
            insert(root[i], root[i - 1], T - 1, a[i]);
        }
    }
    void insert(int u, int v, int t, G x)
    {
        if (t < 0)
        {
            return;
        }
        int j = x >> t & 1;
        ch[u][!j] = ch[v][!j]; // 继承旧版本
        ch[u][j] = ++idx;
        cnt[ch[u][j]] = cnt[ch[v][j]] + 1;
        insert(ch[u][j], ch[v][j], t - 1, x);
    }
    G query_Max(int u, int v, G x)
    {
        G res = 0;
        for (int i = T - 1; i >= 0; --i)
        {
            int j = x >> i & 1;
            if (cnt[ch[v][!j]] > cnt[ch[u][!j]])
            {
                u = ch[u][!j];
                v = ch[v][!j];
                res += (1ll << i);
            }
            else
            {
                u = ch[u][j];
                v = ch[v][j];
            }
        }
        return res;
    }

    G queryMax(int l, int r, G x)
    {
        return query_Max(root[l - 1], root[r], x);
    }
    G queryK_Min(int l, int r, G x, int k) // 第k小
    {
        G res = 0;
        for (int i = T - 1; i >= 0; --i)
        {
            int j = x >> i & 1;
            if (cnt[ch[r][j]] - cnt[ch[l][j]] >= k)
            {
                l = ch[l][j];
                r = ch[r][j];
            }
            else
            {
                res |= 1ll << i;
                k -= cnt[ch[r][j]] - cnt[ch[l][j]];
                l = ch[l][!j];
                r = ch[r][!j];
            }
        }
        return res;
    }
    G queryKMin(int l, int r, G x, int k) // 求k小
    {
        return queryK_Min(root[l - 1], root[r], x, k);
    }
};
```

## 平衡树
平衡树是一种![image](https://cdn.nlark.com/yuque/__latex/0bcded4603d61cf33e3cd037fc03a244.svg)，也就是二叉搜索树。在理想状态下我们的操作复杂度为![image](https://cdn.nlark.com/yuque/__latex/1b0fce2bd1f5925667628ba7a81a4635.svg),但是在退化为链为复杂度将退化为![image](https://cdn.nlark.com/yuque/__latex/e65a67ac353abeeff44c359310d05c02.svg)，因此我们往往通过某些手段来尽可能维护树的平衡性，因此衍生出了不同种类的平衡树

目前我们主流的平衡树有两种，其一是![image](https://cdn.nlark.com/yuque/__latex/153c35bc0905d0f3d795b5caa5c62231.svg),其二是![image](https://cdn.nlark.com/yuque/__latex/be807a525a1204ef774ecdeb245240d5.svg),其中![image](https://cdn.nlark.com/yuque/__latex/5deac8f242f3d3a2211cda89e20f848b.svg)支持可持久化的操作,![image](https://cdn.nlark.com/yuque/__latex/be807a525a1204ef774ecdeb245240d5.svg)在维护![image](https://cdn.nlark.com/yuque/__latex/efc541079b45080327affad8793c1d7f.svg)的时候复杂度更优，各自具有其优势。

平衡树同样具有两种用法，维护区间和维护值域，类似于区间线段树和权值线段树

相较于线段树而言，平衡树最大的功能是可以在某些位置进行插入删除操作并同时维护序列的信息，而线段树只具有修改的功能，但不能在序列的中间位置插入和删除.

由于![image](https://cdn.nlark.com/yuque/__latex/5deac8f242f3d3a2211cda89e20f848b.svg)更容易理解且更好写，我们往往只在考虑![image](https://cdn.nlark.com/yuque/__latex/efc541079b45080327affad8793c1d7f.svg)时使用![image](https://cdn.nlark.com/yuque/__latex/be807a525a1204ef774ecdeb245240d5.svg)。

### 红黑树
在![image](https://cdn.nlark.com/yuque/__latex/f5e7401836f57f59370dbb9061a0be24.svg)库中有内置的红黑树，我们传![image](https://cdn.nlark.com/yuque/__latex/4c751a9fa6d57d8d3a0fca730e5e3b31.svg)即为![image](https://cdn.nlark.com/yuque/__latex/767e2bc28b23ee0a19f3bac38f112f49.svg),想要实现可重集合有两种方法，其一是传入![image](https://cdn.nlark.com/yuque/__latex/f807d41b92e8d12023f15c1584f31a01.svg)，其二是传入![image](https://cdn.nlark.com/yuque/__latex/d2296aba1d1c5eaf66e3856440216598.svg),第二维是一个全局自增变量，也就是通过第二维使得相同的数字被判定为不同。

```cpp

namespace pb = __gnu_pbds;
template <class T, class Cmp = std::less<T>>
// Cmp传std::less<T>就是Set 传std::less_equal<T>就是multiset
struct RedBlackTree
{
    // order_of_key(x) 返回严格小于x的元素个数
    // find_by_order(x) 返回从小到大第x+1个数的迭代器
    // split(val,t)把>=val的部分给t
    const T inf = std::numeric_limits<T>::max() / 2;
    using Tree = pb::tree<T, pb::null_type, Cmp, pb::rb_tree_tag, pb::tree_order_statistics_node_update>;
    Tree tree;
    RedBlackTree() {}
    void insert(T x)
    {
        tree.insert(x);
    }
    void eraseOne(T x)
    {
        auto it = tree.find_by_order(tree.order_of_key(x)); // 更可靠的方式找到第一个x
        if (it != tree.end() and *it == x)
        {
            tree.erase(it);
        }
    }
    void eraseAll(T x)
    {
        Tree a, b;
        tree.split(x, a); // 把
        a.split(x + 1, b);
        tree.join(b);
    }
    int getNum(T x)
    {
        return tree.order_of_key(x + 1) - tree.order_of_key(x);
    }
    int allNum()
    {
        return tree.size();
    }
    T nxt(T x)
    {
        insert(x + 1);
        auto it = tree.find_by_order(tree.order_of_key(x + 1));
        ++it;
        if (it == tree.end())
        {
            return inf;
        }
        eraseOne(x + 1);
        return *it;
    }
    T pre(T x)
    {
        auto it = tree.find_by_order(tree.order_of_key(x));
        if (it == tree.begin())
        {
            return -inf;
        }
        --it;
        return *it;
    }
    // 3 2 2 1 1
    int getRank(T x) // 默认最大的为rank1 相同元素我最大
    {
        return tree.size() - tree.order_of_key(x + 1) + 1;
    }
    T getVal(int rank)
    {
        return *tree.find_by_order(tree.size() - rank);
    }
    int getAntiRank(T x)
    {
        return tree.order_of_key(x) + 1;
    }
    T getAntiVal(int rank)
    {
        return *tree.find_by_order(rank - 1);
    }
};
```

### FHQtreap
![image](https://cdn.nlark.com/yuque/__latex/64a19cc7447a60bca113b1ce9484d079.svg)维护平衡的方式是它对每个节点都随机一个类似于优先级的权值来维护平衡，通过这种操作使得树高的期望值为![image](https://cdn.nlark.com/yuque/__latex/1b0fce2bd1f5925667628ba7a81a4635.svg),在代码中我们用![image](https://cdn.nlark.com/yuque/__latex/5766b36eb57b42893cecb2e481b8469c.svg)表示，其核心操作是![image](https://cdn.nlark.com/yuque/__latex/811613a1510f8ad427cc778b77dc933f.svg)和![image](https://cdn.nlark.com/yuque/__latex/79b0188bf845a80397ad32451b420330.svg)，具体的说,![image](https://cdn.nlark.com/yuque/__latex/e2b3da7c86a4fc3499e8ebb0b3c5d194.svg)函数分别有四个参数，表示把根节点![image](https://cdn.nlark.com/yuque/__latex/4faf0c587205d654244bd07bba6f65de.svg)分成![image](https://cdn.nlark.com/yuque/__latex/712ecf7894348e92d8779c3ee87eeeb0.svg)和![image](https://cdn.nlark.com/yuque/__latex/bf98c0ddcbe9c1e535f767c78c3aa813.svg)两棵子树，其左子树的值小于等于![image](https://cdn.nlark.com/yuque/__latex/8597b8ad64ac82614635dd0459956516.svg)，右子树的值大于![image](https://cdn.nlark.com/yuque/__latex/8597b8ad64ac82614635dd0459956516.svg)，

![image](https://cdn.nlark.com/yuque/__latex/e2b3da7c86a4fc3499e8ebb0b3c5d194.svg)最最最容易出错的地方是我们每次![image](https://cdn.nlark.com/yuque/__latex/e2b3da7c86a4fc3499e8ebb0b3c5d194.svg)后必须重新合并！，不合并将会破坏整棵树的结构！

我们用root表示根，而![image](https://cdn.nlark.com/yuque/__latex/fe5ecbec1e96a37e46f979f585190277.svg)函数的返回值为![image](https://cdn.nlark.com/yuque/__latex/506a5e745b27601cc792bd41808fa8df.svg),也就是说当我们![image](https://cdn.nlark.com/yuque/__latex/ff5c846774535ebe9526d9fe0969ebb7.svg)后，需要进行操作![image](https://cdn.nlark.com/yuque/__latex/8b47e17967e1e5ebd5ce6abffc27a96f.svg)。这两个函数十分容易理解，![image](https://cdn.nlark.com/yuque/__latex/569281a34902651be2167ba7de4ee31e.svg)根据![image](https://cdn.nlark.com/yuque/__latex/8d4ad8a732d49dc719cb4361b5bea348.svg)左小右大的性质递归分裂即可，对于![image](https://cdn.nlark.com/yuque/__latex/fe5ecbec1e96a37e46f979f585190277.svg)，我们需要用到一开始随机的优先级权值来决定合并顺序，以此维护树高的期望为![image](https://cdn.nlark.com/yuque/__latex/ff4edff51773a4560f25e8eab96349ff.svg)

#### 维护值域
我们可以理解为是进阶版的超级![image](https://cdn.nlark.com/yuque/__latex/767e2bc28b23ee0a19f3bac38f112f49.svg)和![image](https://cdn.nlark.com/yuque/__latex/73d6921efa5a6d9656c8964d295ce2ad.svg),几乎支持维护数组值域上所有的操作，且均为单次操作![image](https://cdn.nlark.com/yuque/__latex/1b0fce2bd1f5925667628ba7a81a4635.svg)

```cpp
template <class T>
class FHQTreap
{
public:
    FHQTreap(const std::vector<T> &a) : n(a.size()), tr(n) // 只有初始大小
    {
        for (int i = 1; i <= n - 1; ++i)
        {
            multiInsert(a[i]);
        }
    }
    FHQTreap(int n) : n(n), tr(n) {} // 没有初始大小
    void multiInsert(T val)          // 插入一个值为val的点
    {
        int x, y, z;
        split(root, val, x, y);       // 从val分开
        newNode(z, val);              // 开新节点
        root = merge(merge(x, z), y); // 合并
    }

    bool singleInsert(T val) // set
    {
        if (!checkIsExist(val))
        {
            int x, y, z;
            split(root, val, x, y);       // 从val分开
            newNode(z, val);              // 开新节点
            root = merge(merge(x, z), y); // 合并
            return true;
        }
        return false;
    }

    bool checkIsExist(T val) // check有没有这个数
    {
        int x, y, z;
        split(root, val, x, y);
        split(x, val - 1, x, z);
        int ans = tr[z].size;
        root = merge(merge(x, z), y);
        return ans > 0;
    }

    int getNum(T val)
    {
        int x, y, z;
        split(root, val, x, y);
        split(x, val - 1, x, z);
        int ans = tr[z].size;
        root = merge(merge(x, z), y);
        return ans;
    }

    void eraseOne(T val) // 删除一个值为val的点
    {
        int x, y, z;
        split(root, val, x, z);       // 先把root 分成x和z x是左子树上面的值都<=val
        split(x, val - 1, x, y);      // 把x分成x和y两颗子树 其中x上面的值都小于等于val-1;
        y = merge(tr[y].l, tr[y].r);  // 把拆下来的y子树的左右子树连到一起  //根节点已经没了 搞掉一个根节点
        root = merge(merge(x, y), z); // 最后重新合并
    }

    void eraseAll(T val) // 全部删掉
    {
        int x, y, z;
        split(root, val, x, y);
        split(x, val - 1, x, z);
        root = merge(x, y);
    }

    T getAntiVal(int getRank)
    {
        return getAntiVal(root, getRank);
    }
    T getVal(int getRank) // 最大的为rank1
    {
        return getVal(root, getRank);
    }

    int getAntiRank(T val) //(从小到大 最小为rank1  如果大于了所有数 则会返回size+1  如果小于了所有数 则会返回1
    {
        int x, y;
        split(root, val - 1, x, y);
        int ans = tr[x].size + 1;
        root = merge(x, y);
        return ans;
    }
    int getRank(T val) //(从大到小 最大为rank1 如果大于了所有数 则会返回1  如果小于了所有数 则会返回size+1  有重复元素情况下 一律最优考虑
    {
        int x, y;
        split(root, val, x, y);
        int ans = tr[y].size + 1;
        root = merge(x, y);
        return ans;
    }

    T getPre(T val) // 不考虑重复元素
    {
        int x, y, z;
        T ans;
        split(root, val - 1, x, y);
        ans = tr[x].size ? getAntiVal(x, tr[x].size) : -1; // 没有前缀
        root = merge(x, y);
        return ans;
    }

    T getNxt(T val) // 不考虑重复元素
    {
        int x, y, z;
        T ans;
        split(root, val, x, y);
        ans = tr[y].size ? getAntiVal(y, 1) : -1; // 没有后缀
        root = merge(x, y);
        return ans;
    }

private:
    struct Node
    {
        int l, r, size;
        T val;
        int key;
    };
    int n;
    std::vector<Node> tr;

    int root = 0, idx = 0;

    void newNode(int &u, T val)
    {
        u = ++idx;
        if (tr.size() <= idx)
        {
            tr.resize(idx + 1);
        }
        tr[u].val = val;
        tr[u].key = rand();
        tr[u].size = 1;
    }

    void pushup(int u)
    {
        tr[u].size = tr[tr[u].l].size + tr[tr[u].r].size + 1;
    }

    void split(int u, T val, int &x, int &y) // 按权值分裂 左子树小于等于val 右子树大于val
    {
        if (!u)
        {
            x = 0;
            y = 0;
            return;
        }
        if (tr[u].val <= val)
        {
            x = u;
            split(tr[x].r, val, tr[x].r, y);
            pushup(x);
        }
        else
        {
            y = u;
            split(tr[y].l, val, x, tr[y].l);
            pushup(y);
        }
    }
    int merge(int x, int y) // 合并 都一样
    {
        if (!x || !y)
        {
            return x + y;
        }
        if (tr[x].key < tr[y].key)
        {
            tr[x].r = merge(tr[x].r, y);
            pushup(x);
            return x;
        }
        else
        {
            tr[y].l = merge(x, tr[y].l);
            pushup(y);
            return y;
        }
    }
    T getAntiVal(int root, int rank) // 考虑重复元素  最小的为rank1
    {
        if (rank > tr[root].size or rank < 1) // 没有这么多数
        {
            return -1;
        }
        if (rank == tr[tr[root].l].size + 1)
        {
            return tr[root].val;
        }
        else if (rank <= tr[tr[root].l].size)
        {
            return getAntiVal(tr[root].l, rank);
        }
        else
        {
            return getAntiVal(tr[root].r, rank - tr[tr[root].l].size - 1);
        }
    }
    T getVal(int root, int rank) // 考虑重复元素   最大的为rank1
    {
        if (rank > tr[root].size or rank < 1) // 没有这么多数
        {
            return -1;
        }
        if (rank == tr[tr[root].r].size + 1)
        {
            return tr[root].val;
        }
        else if (rank <= tr[tr[root].r].size)
        {
            return getVal(tr[root].r, rank);
        }
        else
        {
            return getVal(tr[root].l, rank - tr[tr[root].r].size - 1);
        }
    }
};
```

#### 维护区间
又称文艺平衡树，我们可以像线段树一样维护各种信息且支持懒标记操作。

特别的，文艺平衡树具有特别的区间翻转功能，是线段树所不具备的。

```cpp
template <class T>
struct FHQTreap
{

public:
    FHQTreap(const std::vector<T> &a) : n(a.size()), tr(n) // 开二倍防止新点RE
    {
        for (int i = 1; i < n; ++i)
        {
            root = merge(root, newNode(a[i]));
        }
    }
    void insert(int pos, T val) // 在pos后面插入一个值为val的点
    {
        int x, y;
        split(root, pos, x, y);
        root = merge(merge(x, newNode(val)), y);
    }
    void del(int pos) // 删除pos位置的点
    {
        int x, y, z;
        split(root, pos, x, z);
        split(x, pos - 1, x, y);
        root = merge(x, z);
    }
    void reverse(int l, int r)
    {
        int x, y, z;
        split(root, r, x, z);  // 从val=r的位置裂为x和z x为左子树
        split(x, l - 1, x, y); // 从val=l-1的位置裂为x和y x仍为左子树
        tr[y].tag ^= 1;        // 相当于找到了起点l
        root = merge(merge(x, y), z);
    }
    T SingleQuery(int pos)
    {
        int x, y, z;
        split(root, pos, x, y);
        split(x, pos - 1, x, z);
        T res = tr[z].val;
        root = merge(merge(x, z), y);
        return res;
    }
    T RangeQuery(int l, int r)
    {
        int x, y, z;
        split(root, r, x, y);
        split(x, l - 1, x, z);
        T res = tr[z].sum;
        root = merge(merge(x, z), y);
        return res;
    }

private:
    struct Node
    {
        int l, r, key, size, tag;
        T val, sum;
    };
    int n;
    std::vector<Node> tr;
    int root = 0, idx = 0;

    int newNode(T val)
    {
        ++idx;
        if (tr.size() <= idx)
        {
            tr.resize(idx + 1);
        }
        tr[idx].val = val;
        tr[idx].key = rand();
        tr[idx].size = 1;
        tr[idx].sum = val;
        return idx;
    }
    void pushup(int u)
    {
        tr[u].size = tr[tr[u].l].size + tr[tr[u].r].size + 1;
        tr[u].sum = tr[tr[u].l].sum + tr[tr[u].r].sum + tr[u].val;
    }
    void pushdown(int u)
    {
        if (tr[u].tag and u)
        {
            std::swap(tr[u].l, tr[u].r);
            tr[tr[u].l].tag ^= 1;
            tr[tr[u].r].tag ^= 1;
            tr[u].tag = 0;
        }
    }
    void split(int u, int rank, int &x, int &y) // split(root,num,x,y)表示把以root为根的子树的前num个数分给x
    {
        if (!u)
        {
            x = 0;
            y = 0;
            return;
        }
        pushdown(u);
        if (rank > tr[tr[u].l].size)
        {
            rank -= tr[tr[u].l].size + 1;
            x = u;
            split(tr[u].r, rank, tr[u].r, y);
        }
        else
        {
            y = u;
            split(tr[u].l, rank, x, tr[u].l);
        }
        pushup(u);
    }
    int merge(int x, int y)
    {
        if (!x || !y)
        {
            return x + y;
        }
        if (tr[x].key < tr[y].key)
        {
            pushdown(x);
            tr[x].r = merge(tr[x].r, y);
            pushup(x);
            return x;
        }
        else
        {
            pushdown(y);
            tr[y].l = merge(x, tr[y].l);
            pushup(y);
            return y;
        }
    }
};

```

#### 维护哈希
由于线段树维护哈希功能存在一定的局限性，因为不支持插入与删除，所以我们也可以考虑平衡树维护。其维护的哈希函数方法和线段树完全一致，但和常规的字符串哈希不同，具体可以看线段树维护哈希的介绍，需要尤为注意。

### Splay
![image](https://cdn.nlark.com/yuque/__latex/be807a525a1204ef774ecdeb245240d5.svg)是![image](https://cdn.nlark.com/yuque/__latex/efc541079b45080327affad8793c1d7f.svg)的基础，只有基于![image](https://cdn.nlark.com/yuque/__latex/be807a525a1204ef774ecdeb245240d5.svg)的![image](https://cdn.nlark.com/yuque/__latex/efc541079b45080327affad8793c1d7f.svg)复杂度才是优秀的![image](https://cdn.nlark.com/yuque/__latex/4fdce66a3ca18398b05c1efc03c7aa4f.svg)

![image](https://cdn.nlark.com/yuque/__latex/1b401aefd6098d47c03f1b83b8c15735.svg)有两个核心操作，![image](https://cdn.nlark.com/yuque/__latex/178d0674bc7b537106ae0218013b0ad4.svg)和![image](https://cdn.nlark.com/yuque/__latex/4981038c8e3f05783885cbc30d0d98c0.svg),其中![image](https://cdn.nlark.com/yuque/__latex/178d0674bc7b537106ae0218013b0ad4.svg)分为左旋和右旋，相当于是在保证中序遍历不变的情况下进行旋转，有了![image](https://cdn.nlark.com/yuque/__latex/178d0674bc7b537106ae0218013b0ad4.svg)之后我们就可以进行核心操作![image](https://cdn.nlark.com/yuque/__latex/3fbcf570669c462a0b16bf59f69a3d6c.svg)，![image](https://cdn.nlark.com/yuque/__latex/4981038c8e3f05783885cbc30d0d98c0.svg)的作用就是根据当前树不同的形态，采用不同的旋转策略，尽可能减小树高来优化复杂度，也就是通过![image](https://cdn.nlark.com/yuque/__latex/4981038c8e3f05783885cbc30d0d98c0.svg)函数维持树的平衡,多![image](https://cdn.nlark.com/yuque/__latex/be807a525a1204ef774ecdeb245240d5.svg)可以保证复杂度。

```cpp
struct Splay //   注意getval需要rank+1
{
    struct Node
    {
        int s[2];
        int fa;
        int val;
        int siz;
        int cnt;
        void init(int _fa, int _val)
        {
            val = _val;
            fa = _fa;
            cnt = siz = 1;
        }
    };
    int root = 0;
    int idx = 0;
    std::vector<Node> tr;
    void pushup(int x)
    {
        tr[x].siz = tr[tr[x].s[0]].siz + tr[tr[x].s[1]].siz + tr[x].cnt;
    }
    Splay(const std::vector<int> &a) : tr(a.size())
    {
        for (int i = 1; i < a.size(); ++i)
        {
            insert(a[i]);
        }
        insert(1e18);
        insert(-1e18);
    }
    Splay(int n) : tr(n + 10) 
    {
        insert(1e18);
        insert(-1e18);
    }
    void rotate(int x)
    {
        int y = tr[x].fa;
        int z = tr[y].fa;
        int k = (tr[y].s[1] == x);
        tr[y].s[k] = tr[x].s[k ^ 1];
        tr[tr[x].s[k ^ 1]].fa = y;
        tr[x].s[k ^ 1] = y;
        tr[y].fa = x;
        tr[z].s[(tr[z].s[1] == y)] = x;
        tr[x].fa = z;
        pushup(y), pushup(x);
    }
    void splay(int x, int k) // k>0时 把 x伸展到k下面 k=0时把 x转到根
    {
        while (tr[x].fa != k)
        {
            int y = tr[x].fa;
            int z = tr[y].fa;
            if (z != k)
            {
                ((tr[y].s[0] == x) ^ (tr[z].s[0] == y)) ? rotate(x) : rotate(y);
            }
            rotate(x);
        }
        if (!k)
        {
            root = x;
        }
    }

    void insert(int val)
    {
        int x = root;
        int fa = 0;
        while (x and tr[x].val != val)
        {
            fa = x;
            x = tr[x].s[val > tr[x].val];
        }
        if (x)
        {
            tr[x].cnt++;
        }
        else
        {
            x = ++idx;
            tr[fa].s[val > tr[fa].val] = x;
            tr[x].init(fa, val);
        }
        splay(x, 0);
    }
    void multi_insert(int val)
    {
        int x = root;
        int fa = 0;
        while (x and tr[x].val != val)
        {
            fa = x;
            x = tr[x].s[val > tr[x].val];
        }
        if (x)
        {
            tr[x].cnt++;
            if (tr[x].cnt > 1)
            {
                tr[x].cnt = 1;
            }
        }
        else
        {
            x = ++idx;
            tr[fa].s[val > tr[fa].val] = x;
            tr[x].init(fa, val);
        }
        splay(x, 0);
    }
    void find(int val)
    {
        int x = root;
        while (tr[x].s[val > tr[x].val] and val != tr[x].val)
        {
            x = tr[x].s[val > tr[x].val];
        }
        splay(x, 0);
    }
    int getpre(int val)
    {
        find(val); // 转到根
        int x = root;
        if (tr[x].val < val)
        {
            return x;
        }
        x = tr[x].s[0];
        while (tr[x].s[1])
        {
            x = tr[x].s[1];
        }
        splay(x, 0);
        return x;
    }
    int getsuf(int val)
    {
        find(val);
        int x = root;
        if (tr[x].val > val)
        {
            return x;
        }
        x = tr[x].s[1];
        while (tr[x].s[0])
        {
            x = tr[x].s[0];
        }
        splay(x, 0);
        return x;
    }
    void delone(int val) // 只删除一个
    {
        int pre = getpre(val);
        int suf = getsuf(val); // 返回节点编号
        splay(pre, 0);
        splay(suf, pre);
        int cur = tr[suf].s[0]; // cur就是要删除的节点的编号
        if (tr[cur].cnt > 1)
        {
            tr[cur].cnt--;
            splay(cur, 0); // 实际上是为了pushup
        }
        else
        {
            tr[suf].s[0] = 0; // 直接把节点删掉
            splay(suf, 0);
        }
    }
    void delall(int val)
    {
        int pre = getpre(val);
        int suf = getsuf(val);
        splay(pre, 0);
        splay(suf, pre);
        int cur = tr[suf].s[0]; // cur就是要删除的节点的编号
        tr[suf].s[0] = 0;       // 直接把节点删掉
        splay(suf, 0);
    }
    int getrank(int val) // 默认是插入了inf 和-inf的结果
    {
        insert(val);
        int res = tr[tr[root].s[0]].siz;
        delone(val);
        return res;
    }
    int getval(int rank)
    {
        int x = root;
        while (true)
        {
            int y = tr[x].s[0];
            if (tr[y].siz + tr[x].cnt < rank)
            {
                rank -= tr[y].siz + tr[x].cnt;
                x = tr[x].s[1];
            }
            else if (tr[y].siz >= rank)
            {
                x = y;
            }
            else
            {
                break;
            }
        }
        splay(x, 0);
        return tr[x].val;
    }
};
```

### 动态树
动态树(Link cut Tree)，简单理解就是把平衡树建在树上，由于平衡树的特性使动态树有了动态连边动态删边的能力，但实际上即使不需要动态操作树的结构,我们也可以用![image](https://cdn.nlark.com/yuque/__latex/efc541079b45080327affad8793c1d7f.svg)求解一些问题，比如树链最大子段和问题，用![image](https://cdn.nlark.com/yuque/__latex/efc541079b45080327affad8793c1d7f.svg)来做显得十分自然,用线段树做则显得十分复杂



![image](https://cdn.nlark.com/yuque/__latex/efc541079b45080327affad8793c1d7f.svg)把一整颗树分为分为多条按深度递增的链，分法并不唯一，然后我们对每条链以深度为标准都开一颗![image](https://cdn.nlark.com/yuque/__latex/be807a525a1204ef774ecdeb245240d5.svg)维护。然后我们引出实链剖分的概念，我们定义在![image](https://cdn.nlark.com/yuque/__latex/be807a525a1204ef774ecdeb245240d5.svg)中的边都是实边，连接不同![image](https://cdn.nlark.com/yuque/__latex/be807a525a1204ef774ecdeb245240d5.svg)的边为虚边，那么不难发现，一个点的多个儿子不能同时出现在一个![image](https://cdn.nlark.com/yuque/__latex/be807a525a1204ef774ecdeb245240d5.svg)中，所以每个点只有一个实儿子，其余全是虚儿子，对于虚儿子所在的![image](https://cdn.nlark.com/yuque/__latex/be807a525a1204ef774ecdeb245240d5.svg)，该![image](https://cdn.nlark.com/yuque/__latex/be807a525a1204ef774ecdeb245240d5.svg)所在的根通过虚边连向该点。换句话说，![image](https://cdn.nlark.com/yuque/__latex/be807a525a1204ef774ecdeb245240d5.svg)中的根节点的父节点是该![image](https://cdn.nlark.com/yuque/__latex/be807a525a1204ef774ecdeb245240d5.svg)中深度最小节点的父亲，且满足认父不认子的特征。

然后我们就可以讲操作函数了

![image](https://cdn.nlark.com/yuque/__latex/4848a905197f6a4b2d4c0f553861e349.svg)表示把![image](https://cdn.nlark.com/yuque/__latex/712ecf7894348e92d8779c3ee87eeeb0.svg)和原树根节点之间（深度最小点）的路径打通，即路径上全是实边，且![image](https://cdn.nlark.com/yuque/__latex/7db4cee9e74865ab082228d786b31d61.svg)点变成该![image](https://cdn.nlark.com/yuque/__latex/1b401aefd6098d47c03f1b83b8c15735.svg)深度最大点，我们先把![image](https://cdn.nlark.com/yuque/__latex/712ecf7894348e92d8779c3ee87eeeb0.svg)转到所在![image](https://cdn.nlark.com/yuque/__latex/be807a525a1204ef774ecdeb245240d5.svg)的根，此时的右儿子深度一定大于我，因此直接置空，置空的意义就是实边转为虚边，我成为了深度最大点。然后我跳到当前节点的父节点![image](https://cdn.nlark.com/yuque/__latex/42d63c25c72532fdc1dc8409f990e38d.svg)，来到了上一个![image](https://cdn.nlark.com/yuque/__latex/be807a525a1204ef774ecdeb245240d5.svg)深度最大的节点,因为要打通路径，我们继续把![image](https://cdn.nlark.com/yuque/__latex/42d63c25c72532fdc1dc8409f990e38d.svg)转到根，即![image](https://cdn.nlark.com/yuque/__latex/20bf11f600f331847ac9325f6398c116.svg)，并且把现在的右儿子设为![image](https://cdn.nlark.com/yuque/__latex/712ecf7894348e92d8779c3ee87eeeb0.svg),即![image](https://cdn.nlark.com/yuque/__latex/b69980ccac7487535c03bbf49f0d965b.svg)，意思就是把这两个![image](https://cdn.nlark.com/yuque/__latex/be807a525a1204ef774ecdeb245240d5.svg)之间的路径打通了，不断递归下去直至父节点不再存在，就说明我们已经打通了所有的路径,注意在此过程中需要不断![image](https://cdn.nlark.com/yuque/__latex/477d74b83dc0d30cae6608207b4f6946.svg)更新信息

![image](https://cdn.nlark.com/yuque/__latex/3078348891a695e00a3c1844b74789b9.svg)表示把![image](https://cdn.nlark.com/yuque/__latex/712ecf7894348e92d8779c3ee87eeeb0.svg)变成原树的根，因为有时候我们需要的路径有可能深度并不递增，我们无法将他们放置在同一个![image](https://cdn.nlark.com/yuque/__latex/be807a525a1204ef774ecdeb245240d5.svg)中，因此我们需要换根操作。我们知道![image](https://cdn.nlark.com/yuque/__latex/4848a905197f6a4b2d4c0f553861e349.svg)以后![image](https://cdn.nlark.com/yuque/__latex/712ecf7894348e92d8779c3ee87eeeb0.svg)是所在![image](https://cdn.nlark.com/yuque/__latex/be807a525a1204ef774ecdeb245240d5.svg)深度最大点，那么我们![image](https://cdn.nlark.com/yuque/__latex/90d26396f418fea574ad7513842ec306.svg)后![image](https://cdn.nlark.com/yuque/__latex/712ecf7894348e92d8779c3ee87eeeb0.svg)将不存在右儿子,那么此时我们对整个![image](https://cdn.nlark.com/yuque/__latex/be807a525a1204ef774ecdeb245240d5.svg)打翻转标记，那么翻转后的![image](https://cdn.nlark.com/yuque/__latex/712ecf7894348e92d8779c3ee87eeeb0.svg)将没有左儿子，成为了原树的根,当然也需要![image](https://cdn.nlark.com/yuque/__latex/477d74b83dc0d30cae6608207b4f6946.svg)

![image](https://cdn.nlark.com/yuque/__latex/e39b76d46c22c8f561583c08bccff3b1.svg)表示找到![image](https://cdn.nlark.com/yuque/__latex/712ecf7894348e92d8779c3ee87eeeb0.svg)在原树中的根，我们仍然先![image](https://cdn.nlark.com/yuque/__latex/188ed27df442b306a25555948834f7d2.svg),然后不断跳左儿子，并且要![image](https://cdn.nlark.com/yuque/__latex/17a0042cf8bb0b5dac93b7dea1780afe.svg)，直至找不到做儿子为止，也就找到了根。最后要![image](https://cdn.nlark.com/yuque/__latex/7c565f7b860b6dc07de5dc15a302f13c.svg)保证复杂度

![image](https://cdn.nlark.com/yuque/__latex/912c2297daa702def7dc7a485e33322e.svg)表示分离出![image](https://cdn.nlark.com/yuque/__latex/da346798e0393c0b75fcdac8277be699.svg)的链并将信息整合到了![image](https://cdn.nlark.com/yuque/__latex/bf98c0ddcbe9c1e535f767c78c3aa813.svg)，怎么做呢，很显然我们先![image](https://cdn.nlark.com/yuque/__latex/3078348891a695e00a3c1844b74789b9.svg)，然后![image](https://cdn.nlark.com/yuque/__latex/d37d097c5b7d5e74b10fa27138c9a1c3.svg)，再![image](https://cdn.nlark.com/yuque/__latex/797ae8120a606c94626839fc986a50c7.svg)即可

![image](https://cdn.nlark.com/yuque/__latex/ef37331726f8b6f10239323c50159483.svg),即把![image](https://cdn.nlark.com/yuque/__latex/a969cab25db24b7b40ddd3064d3ab658.svg)之间连一条边，直接把![image](https://cdn.nlark.com/yuque/__latex/712ecf7894348e92d8779c3ee87eeeb0.svg)变为原树的根，令![image](https://cdn.nlark.com/yuque/__latex/427485d908375107ca8c976ced20acda.svg)即可

![image](https://cdn.nlark.com/yuque/__latex/08ebe8684d17f4cd856bddc93090d0f6.svg),即把![image](https://cdn.nlark.com/yuque/__latex/a969cab25db24b7b40ddd3064d3ab658.svg)之间的边断开，我们直接![image](https://cdn.nlark.com/yuque/__latex/912c2297daa702def7dc7a485e33322e.svg),然后使![image](https://cdn.nlark.com/yuque/__latex/d825b24c9fc3260d455ab0b7fb23ae02.svg)即可

当然在代码中我们判断了非法连边断边的操作，但一般题目都保证数据合法

#### 维护树链信息
有了以上的这些函数，我们已经能动态维护森林，并且维护链上的信息了。![image](https://cdn.nlark.com/yuque/__latex/efc541079b45080327affad8793c1d7f.svg)维护链信息最经典的应用是动态![image](https://cdn.nlark.com/yuque/__latex/67ca15b1b4ac65f7bcb0c3250083057b.svg)，因为我们能轻易求出链上边权最小值，并且动态加边断边,对于懒标记的使用，几乎和平衡树没有区别。

```cpp
template <class T>
struct LCT // 单点修改 区间查询
{
    // LCT节点结构，包含左右子树指针、父节点、翻转标记、子树大小、节点值和子树和
    struct Node
    {
        int s[2];       // 左右子树索引
        int fa, tag, siz; // 父节点、翻转标记、子树大小
        T val, sum;     // 节点值和子树和
    };
    std::vector<Node> tr; // 存储所有节点的数组

    // 构造函数，初始化LCT节点
    LCT(const std::vector<T> &a) : tr(a.size())
    {
        for (int i = 1; i < a.size(); ++i)
        {
            tr[i].sum = tr[i].val = a[i];
            tr[i].tag = 0;
        }
    }

    // 更新节点信息，计算子树和和子树大小
    void pushup(int x)
    {
        tr[x].sum = tr[tr[x].s[0]].sum + tr[tr[x].s[1]].sum + tr[x].val;
        tr[x].siz = tr[tr[x].s[0]].siz + tr[tr[x].s[1]].siz + 1;
    }

    // 下传翻转标记
    void pushdown(int x)
    {
        if (tr[x].tag)
        {
            std::swap(tr[x].s[0], tr[x].s[1]);
            tr[tr[x].s[0]].tag ^= 1;
            tr[tr[x].s[1]].tag ^= 1;
            tr[x].tag = 0;
        }
    };

    // 判断节点x是否为其所在Splay的根
    bool notroot(int x)
    {
        return ((tr[tr[x].fa].s[0] == x) || (tr[tr[x].fa].s[1] == x));
    }

    // 递归下传所有祖先的标记
    void pushall(int x)
    {
        if (notroot(x))
        {
            pushall(tr[x].fa);
        }
        pushdown(x);
    }

    // 旋转操作，将节点x向上旋转一层
    void rotate(int x)
    {
        int y = tr[x].fa, z = tr[y].fa;
        int k = (tr[y].s[1] == x);
        if (notroot(y))
        {
            tr[z].s[tr[z].s[1] == y] = x;
        }
        tr[x].fa = z;
        tr[y].s[k] = tr[x].s[k ^ 1];
        tr[tr[x].s[k ^ 1]].fa = y;
        tr[x].s[k ^ 1] = y;
        tr[y].fa = x;
        pushup(y), pushup(x);
    }

    // Splay操作，将节点x旋转到其所在Splay的根
    void splay(int x)
    {
        pushall(x);
        while (notroot(x))
        {
            int y = tr[x].fa, z = tr[y].fa;
            if (notroot(y))
            {
                ((tr[y].s[1] == x) ^ (tr[z].s[1] == y)) ? rotate(x) : rotate(y);
            }
            rotate(x);
        }
    }

    // 打通从节点x到根的路径，将x到根的路径合并为一个Splay
    void access(int x)
    {
        for (int y = 0; x;)
        {
            splay(x);
            tr[x].s[1] = y;
            pushup(x);
            y = x, x = tr[x].fa;
        }
    }

    // 将节点x变为原树的根
    void makeroot(int x)
    {
        access(x);
        splay(x);
        tr[x].tag ^= 1;
    }

    // 分离出x->y的路径，将x设为根，然后打通到y的路径并将y旋转到根
    void split(int x, int y) // 分离出x->y的链 并且把答案pushup到y
    {
        makeroot(x);
        access(y);
        splay(y);
    }

    // 查询x-y路径上的和
    T query(int x, int y) // 输出x-y路径上的答案
    {
        split(x, y); // 答案被统计至y
        return tr[y].sum;
    }

    // 查询节点x的值
    T query(int x)
    {
        splay(x);
        return tr[x].val;
    }

    // 查找节点x所在树的根节点
    int findroot(int x)
    {
        access(x);
        splay(x);
        while (tr[x].s[0])
        {
            pushdown(x), x = tr[x].s[0];
        }
        splay(x);
        return x;
    }

    // 连接节点x和y
    void link(int x, int y)
    {
        makeroot(x);
        if (findroot(y) != x)
        {
            tr[x].fa = y;
        }
    }

    // 断开节点x和y之间的边
    void cut(int x, int y)
    {
        makeroot(x);
        if (findroot(y) == x and tr[y].fa == x and !tr[y].s[0])
        {
            tr[x].s[1] = tr[y].fa = 0;
            pushup(x);
        }
    }

    // 修改节点x的值
    void change(int x, T val) // 改变x的点权
    {
        splay(x);
        tr[x].val = val;
        pushup(x);
    }
};
```

#### 维护子树信息
根据上文，我们发现![image](https://cdn.nlark.com/yuque/__latex/efc541079b45080327affad8793c1d7f.svg)似乎并不能维护子树信息，事实上这的确是![image](https://cdn.nlark.com/yuque/__latex/28f26e920f683bf3930be1e1f302f9da.svg)的弱项，但我们仍有办法维护。

我们发现对于点![image](https://cdn.nlark.com/yuque/__latex/712ecf7894348e92d8779c3ee87eeeb0.svg),我们只能维护出它的实儿子的信息，实际上是从![image](https://cdn.nlark.com/yuque/__latex/712ecf7894348e92d8779c3ee87eeeb0.svg)出发的一条链。那么我们不难想到，只要能够维护虚儿子信息的总和，我们把他们合并起来便是子树信息了。

对于每次询问，我们![image](https://cdn.nlark.com/yuque/__latex/0cc73ced46da3d208ca031df01d7a68c.svg)，此时![image](https://cdn.nlark.com/yuque/__latex/77c3adce895348f6083c425fe1ba2624.svg)已经被转到根上，那么![image](https://cdn.nlark.com/yuque/__latex/77c3adce895348f6083c425fe1ba2624.svg)的子树信息和为![image](https://cdn.nlark.com/yuque/__latex/29414c91dd7dd59ce2502230e492b4f7.svg)

```cpp
template <class T>
struct LCT
{
    struct Node
    {
        int s[2];
        int fa, tag;
        T val, info, exInfo; // exInfo是虚子树信息总和 info是所有儿子的信息总和
    };
    int root;
    std::vector<Node> tr;
    LCT(int n, int _root) : root(_root), tr(n + 1) {}
    void pushup(int x)
    {
        tr[x].info = tr[tr[x].s[0]].info + tr[tr[x].s[1]].info + tr[x].exInfo + tr[x].val;
    }
    void pushdown(int x)
    {
        if (tr[x].tag)
        {
            std::swap(tr[x].s[0], tr[x].s[1]);
            tr[tr[x].s[0]].tag ^= 1;
            tr[tr[x].s[1]].tag ^= 1;
            tr[x].tag = 0;
        }
    };

    bool notroot(int x)
    {
        return ((tr[tr[x].fa].s[0] == x) || (tr[tr[x].fa].s[1] == x));
    }

    void pushall(int x)
    {
        if (notroot(x))
        {
            pushall(tr[x].fa);
        }
        pushdown(x);
    }

    void rotate(int x)
    {
        int y = tr[x].fa, z = tr[y].fa;
        int k = (tr[y].s[1] == x);
        if (notroot(y))
        {
            tr[z].s[tr[z].s[1] == y] = x;
        }
        tr[x].fa = z;
        tr[y].s[k] = tr[x].s[k ^ 1];
        tr[tr[x].s[k ^ 1]].fa = y;
        tr[x].s[k ^ 1] = y;
        tr[y].fa = x;
        pushup(y), pushup(x);
    }

    void splay(int x)
    {
        pushall(x);
        while (notroot(x))
        {
            int y = tr[x].fa, z = tr[y].fa;
            if (notroot(y))
            {
                ((tr[y].s[1] == x) ^ (tr[z].s[1] == y)) ? rotate(x) : rotate(y);
            }
            rotate(x);
        }
    }

    void access(int x)
    {
        for (int y = 0; x;)
        {
            splay(x);
            tr[x].exInfo += tr[tr[x].s[1]].info;
            tr[x].s[1] = y;
            tr[x].exInfo -= tr[tr[x].s[1]].info;
            pushup(x);
            y = x, x = tr[x].fa;
        }
    }

    void makeroot(int x) // 把x转到根
    {
        access(x);
        splay(x);
        tr[x].tag ^= 1;
    }

    void split(int x, int y) // 分离出x->y的链 并且把答案pushup到y
    {
        makeroot(x);
        access(y);
        splay(y);
    }
    T query(int x) // 询问子树信息
    {
        split(root, x);
        return tr[x].exInfo + tr[x].val;
    }
    int findroot(int x) // 找x节点的根 可以理解为并查集的root
    {
        access(x);
        splay(x);
        while (tr[x].s[0])
        {
            pushdown(x), x = tr[x].s[0];
        }
        splay(x);
        return x;
    }

    void link(int x, int y)
    {
        makeroot(x);
        if (findroot(y) != x)
        {
            tr[x].fa = y;
            tr[y].exInfo += tr[x].info;
        }
        pushup(y);
    }
    void cut(int x, int y)
    {
        makeroot(x);
        if (findroot(y) == x and tr[y].fa == x and !tr[y].s[0])
        {
            tr[x].s[1] = tr[y].fa = 0;
            pushup(x);
        }
    }
    void change(int x, T val) // 改变x的点权
    {
        splay(x);
        tr[x].val = val;
        pushup(x);
    }
};
```

#### 维护边双连通分量
![image](https://cdn.nlark.com/yuque/__latex/efc541079b45080327affad8793c1d7f.svg)同时能动态维护边双连通分量来维护图的连通性，怎么做呢？我们维护两个并查集，其一为全局连通性并查集，其二为![image](https://cdn.nlark.com/yuque/__latex/efc541079b45080327affad8793c1d7f.svg)用并查集，在加边![image](https://cdn.nlark.com/yuque/__latex/3fa416a2719b11d2ab46a98b76dd7be0.svg)时，我们用全局并查集判断这两点是否联通，假如不联通，我们![image](https://cdn.nlark.com/yuque/__latex/9b780aa9db89179dd26349935777e500.svg),否则我们![image](https://cdn.nlark.com/yuque/__latex/ea8fa072e530e7a71f9ddcfdd349e02f.svg)，并通过![image](https://cdn.nlark.com/yuque/__latex/3554585ecb04a4bf73b5938d239b0fe5.svg)把信息整合到![image](https://cdn.nlark.com/yuque/__latex/d29c2e5f4926e5b0e9a95305650f6e54.svg)节点上，然后我们将![image](https://cdn.nlark.com/yuque/__latex/d29c2e5f4926e5b0e9a95305650f6e54.svg)的左儿子和右儿子置空，代表我们把该边双连通分量缩点，在![image](https://cdn.nlark.com/yuque/__latex/3554585ecb04a4bf73b5938d239b0fe5.svg)过程中我们还得维护内层并查集，也就是把经过的节点的父亲置为![image](https://cdn.nlark.com/yuque/__latex/e3b1a1ba9d491cc6835e70607ead3750.svg)，代表他们缩点以后变成了![image](https://cdn.nlark.com/yuque/__latex/e3b1a1ba9d491cc6835e70607ead3750.svg)点。

总的来说，外层并查集维护全局图的连通性，内层并查集维护![image](https://cdn.nlark.com/yuque/__latex/efc541079b45080327affad8793c1d7f.svg)内所有点目前真正的祖先

```cpp

struct LCT // 单点修改 区间查询
{
    DSU dsu, Dsu; // 后者是全局并查集
    struct Node
    {
        int s[2];    // 左右子树
        int fa, tag; // 父节点和翻转标记
    };
    std::vector<Node> tr; // 存储LCT的节点
    std::vector<int> siz; // 维护lct内并查集的siz
    int res = 0;          // 临时存储双连通分量的大小
    LCT(int n) : tr(n + 1), dsu(n), Dsu(n), siz(n + 1)
    {
        siz[0] = 0;
        for (int i = 1; i <= n; ++i)
        {
            tr[i].s[0] = tr[i].s[1] = tr[i].fa = 0; // 初始化节点
            tr[i].tag = 0;
            siz[i] = 1; // 初始每个节点的大小为1
        }
    }

    // 下推翻转标记
    void pushdown(int x)
    {
        if (tr[x].tag)
        {
            std::swap(tr[x].s[0], tr[x].s[1]); // 交换左右子树
            if (tr[x].s[0])
            {
                tr[tr[x].s[0]].tag ^= 1; // 传递标记给左子树
            }
            if (tr[x].s[1])
            {
                tr[tr[x].s[1]].tag ^= 1; // 传递标记给右子树
            }
            tr[x].tag = 0; // 清除当前节点标记
        }
    };

    // 判断节点x是否不是其父节点的根（即是否为splay的根）
    bool notroot(int x)
    {
        return ((tr[dsu.root(tr[x].fa)].s[0] == x) || (tr[dsu.root(tr[x].fa)].s[1] == x));
    }

    // 递归下推所有标记直到节点x
    void pushall(int x)
    {
        if (notroot(x))
        {
            pushall(dsu.root(tr[x].fa)); // 先下推父节点的标记
        }
        pushdown(x); // 再下推当前节点的标记
    }

    // 旋转操作，将节点x向上旋转一层
    void rotate(int x)
    {
        int y = dsu.root(tr[x].fa), z = dsu.root(tr[y].fa); // 获取父节点和祖父节点
        int k = (tr[y].s[1] == x);                          // 判断x是y的左子还是右子
        if (notroot(y))
        {
            tr[z].s[tr[z].s[1] == y] = x; // 将x接到祖父节点z上
        }
        tr[x].fa = z;                // 更新x的父节点为z
        tr[y].fa = x;                // 更新y的父节点为x
        tr[y].s[k] = tr[x].s[k ^ 1]; // 更新y的子节点
        if (tr[x].s[k ^ 1])
        {
            tr[tr[x].s[k ^ 1]].fa = y; // 更新x原某个子节点的父节点为y
        }
        tr[x].s[k ^ 1] = y; // 更新x的子节点为y
    }

    // 将节点x旋转到其所在splay的根
    void splay(int x)
    {
        pushall(x); // 先下推所有标记
        while (notroot(x))
        {
            int y = dsu.root(tr[x].fa), z = dsu.root(tr[y].fa); // 获取父节点和祖父节点
            if (notroot(y))
            {
                // 之字形旋转和一字形旋转的处理
                ((tr[y].s[0] == x) ^ (tr[z].s[0] == y)) ? rotate(x) : rotate(y);
            }
            rotate(x); // 最后旋转x
        }
    }

    // 打通从根到x的路径，将x到根的路径变为实链
    void access(int x)
    {
        for (int y = 0; x;)
        {
            splay(x);                      // 将x旋转到根
            tr[x].s[1] = y;                // 将x的右子树设置为y
            tr[y].fa = x;                  // 更新y的父节点为x
            y = x, x = dsu.root(tr[x].fa); // 继续处理x的父节点
        }
    }

    // 将x变为树的根
    void makeroot(int x)
    {
        access(x);      // 打通从根到x的路径
        splay(x);       // 将x旋转到根
        tr[x].tag ^= 1; // 翻转整条路径
    }

    // 分离出x->y的链，并把答案pushup到y
    void split(int x, int y)
    {
        makeroot(x); // 将x变为根
        access(y);   // 打通从x到y的路径
        splay(y);    // 将y旋转到根
    }

    // 连接x和y
    void link(int x, int y)
    {
        makeroot(x);  // 将x变为根
        tr[x].fa = y; // 将x连接到y
    }

    // 暴力dfs并查集的祖先并修改，注意是从底向上合并信息的
    void dfs(int u, int root)
    {
        if (!u)
        {
            return; // 空节点返回
        }
        res += siz[u]; // 累加双连通分量的大小
        if (u != root)
        {
            siz[root] += siz[u]; // 将u的大小合并到root
            dsu.pre[u] = root;   // 更新u的并查集祖先为root
        }
        dfs(tr[u].s[0], root); // 递归处理左子树
        dfs(tr[u].s[1], root); // 递归处理右子树
    }

    // 加边缩点操作
    void add(int a, int b)
    {
        a = dsu.root(a), b = dsu.root(b); // 找到内部并查集的祖先
        res = 0;
        if (!Dsu.iscon(a, b)) // 在全局并查集查找是否联通
        {
            Dsu.merge(a, b); // 合并全局并查集
            link(a, b);      // 连接a和b
        }
        else // 缩点
        {
            split(a, b);                 // 拆分出a到b的链
            dfs(b, b);                   // 把信息整合到祖先b
            tr[b].s[0] = tr[b].s[1] = 0; // 缩点，把它的儿子断开
        }
    }
};
```

#### 维护最大子段和
单独拿出来，实际上是因为最大子段和的维护十分特殊，涉及到![image](https://cdn.nlark.com/yuque/__latex/888ac4dc56b6d856c6780b094062bc62.svg)和![image](https://cdn.nlark.com/yuque/__latex/3e589b7e899ae1ba86974245fc104dc2.svg),由于![image](https://cdn.nlark.com/yuque/__latex/efc541079b45080327affad8793c1d7f.svg)大量用到![image](https://cdn.nlark.com/yuque/__latex/8a9d0948a1f77d64c005232efd97b862.svg)操作，我们需要在![image](https://cdn.nlark.com/yuque/__latex/17a0042cf8bb0b5dac93b7dea1780afe.svg)交换左右儿子时同时交换![image](https://cdn.nlark.com/yuque/__latex/888ac4dc56b6d856c6780b094062bc62.svg)和![image](https://cdn.nlark.com/yuque/__latex/3e589b7e899ae1ba86974245fc104dc2.svg)，这一点十分关键且容易遗漏

```cpp
template <class T>
struct LCT // 线性树（Link-Cut Tree）模板，支持单点修改、区间查询（如路径和、最大子段和等）
{
#define lc tr[x].s[0] // 定义左子树便捷访问宏
#define rc tr[x].s[1] // 定义右子树便捷访问宏

    struct Node
    {
        int s[2]; // s[0]为左子节点，s[1]为右子节点
        int fa;   // 父节点指针
        int tag;  // 翻转标记（0表示正常，1表示需要翻转子树）
        T val;    // 当前节点存储的权值
        T sum;    // 以当前节点为根的子树权值和（包含自身）
        T lmax;   // 从子树左端点开始的最大连续子段和
        T rmax;   // 从子树右端点结束的最大连续子段和
        T max;    // 子树中的最大连续子段和
    };
    std::vector<Node> tr; // 存储树节点的容器（下标从1开始对应节点编号）

    // 构造函数：根据初始数组a初始化LCT（a[0]不使用，节点1对应a[1]）
    LCT(const std::vector<T> &a) : tr(a.size())
    {
        for (int i = 1; i < a.size(); ++i) // 假设数组长度为n+1，初始化节点1~n
        {
            tr[i].val = a[i]; // 初始化节点权值
            tr[i].tag = 0;    // 初始无翻转标记
            // 单独节点时，各统计量均等于自身权值
            tr[i].sum = tr[i].lmax = tr[i].rmax = tr[i].max = a[i];
        }
    }

    // 向上更新函数：根据子节点信息更新当前节点的统计量（维护区间属性）
    void pushup(int x)
    {
        tr[x].sum = tr[lc].sum + tr[rc].sum + tr[x].val;
        tr[x].lmax = std::max(tr[lc].lmax, tr[lc].sum + tr[x].val + tr[rc].lmax);
        tr[x].rmax = std::max(tr[rc].rmax, tr[rc].sum + tr[x].val + tr[lc].rmax);
        tr[x].max = std::max({tr[lc].max, tr[rc].max, tr[lc].rmax + tr[x].val + tr[rc].lmax});
    }

    // 向下传递函数：将翻转标记传递给子节点（处理路径翻转操作）
    void pushdown(int x)
    {
        if (tr[x].tag) // 若当前节点需要翻转子树
        {
            std::swap(lc, rc); // 交换左右子树

            // 翻转后左右端点交换，因此交换左右子树的lmax和rmax
            std::swap(tr[lc].lmax, tr[lc].rmax);
            std::swap(tr[rc].lmax, tr[rc].rmax);

            // 子节点继承翻转标记
            tr[lc].tag ^= 1;
            tr[rc].tag ^= 1;

            tr[x].tag = 0; // 清除当前节点的翻转标记
        }
    };

    // 判断节点x是否不是所在Splay树的根节点（即存在父节点且是父节点的左/右孩子）
    bool notroot(int x)
    {
        return ((tr[tr[x].fa].s[0] == x) || (tr[tr[x].fa].s[1] == x));
    }

    // 递归下传标记：从根到x路径上的所有节点标记均向下传递（保证操作前路径清洁）
    void pushall(int x)
    {
        if (notroot(x)) // 若x不是根节点，先处理父节点路径
        {
            pushall(tr[x].fa);
        }
        pushdown(x); // 处理当前节点的标记
    }

    // 旋转操作：将x节点向上旋转一层，维护Splay树的平衡性质
    void rotate(int x)
    {
        int y = tr[x].fa, z = tr[y].fa; // y是x的父节点，z是y的父节点
        int k = (tr[y].s[1] == x);      // k=1表示x是y的右孩子，k=0表示左孩子

        // 若y不是根节点，将x直接连接到z的对应子树位置
        if (notroot(y))
        {
            tr[z].s[tr[z].s[1] == y] = x; // 更新z的子节点指向x
        }

        tr[x].fa = z;                // x的父节点设为z
        tr[y].s[k] = tr[x].s[k ^ 1]; // y的k方向子节点设为x的反方向子节点
        if (tr[x].s[k ^ 1])          // 若x的反方向子节点存在，更新其父节点为y
        {
            tr[tr[x].s[k ^ 1]].fa = y;
        }
        tr[x].s[k ^ 1] = y; // x的反方向子节点设为y
        tr[y].fa = x;       // y的父节点设为x

        // 旋转后子树结构变化，需要重新计算y和x的统计量
        pushup(y), pushup(x);
    }

    // Splay操作：将节点x旋转到当前Splay树的根节点（暴露x到实链中）
    void splay(int x)
    {
        pushall(x);        // 先下传x路径上的所有延迟标记
        while (notroot(x)) // 当x不是根节点时，循环旋转
        {
            int y = tr[x].fa, z = tr[y].fa; // 获取父节点和祖父节点
            if (notroot(y))                 // 若祖父节点存在（y不是根节点）
            {
                // 判断x和y是否为同方向子节点（异或为真则方向不同，执行之字形旋转；否则一字形旋转）
                ((tr[y].s[1] == x) ^ (tr[z].s[1] == y)) ? rotate(x) : rotate(y);
            }
            rotate(x); // 最后一次旋转x，使其成为根节点
        }
    }

    // Access操作：将x到根节点的路径变为实链，其他路径变为虚链（维护动态树结构）
    void access(int x)
    {
        for (int y = 0; x;) // y记录上一次访问的节点（初始为虚节点0）
        {
            splay(x);            // 将x旋转到当前Splay树的根
            tr[x].s[1] = y;      // 将x的右子树设为之前的实链（y及其子树）
            pushup(x);           // 更新x的统计量（因右子树改变）
            y = x, x = tr[x].fa; // 移动到父节点，继续处理
        }
    }

    // Makeroot操作：将x设为树的根节点（通过翻转路径实现）
    void makeroot(int x)
    {
        access(x);      // 打通x到原根的路径
        splay(x);       // 将x旋转到根
        tr[x].tag ^= 1; // 翻转路径标记（实现子树翻转，改变树的方向）
    }

    // Split操作：分离出x到y的路径，并将y设为该路径的根（便于后续查询/修改）
    void split(int x, int y) // 操作后x到y的路径成为y的子树
    {
        makeroot(x); // 将x设为根，此时x到原根路径反向
        access(y);   // 打通y到根的路径（即x到y的路径）
        splay(y);    // 将y旋转到根，此时x-y路径被单独分离出来
    }

    // Query操作：查询x到y路径上的权值和（需保证x和y连通）
    T query(int x, int y) // 返回路径和
    {
        split(x, y);      // 分离路径并将答案统计到y节点
        return tr[y].sum; // y的sum属性即为路径和
    }

    // Findroot操作：查找x所在树的根节点（路径压缩后找到最左侧节点）
    int findroot(int x)
    {
        access(x); // 打通x到根的路径
        splay(x);  // 将x旋转到根
        // 向下找到最左侧节点（无左子树的节点）
        while (tr[x].s[0])
        {
            pushdown(x);    // 下传标记
            x = tr[x].s[0]; // 移动到左子树
        }
        splay(x); // 再次旋转确保根节点正确
        return x;
    }

    // Link操作：连接x和y（要求x和y不连通，否则会形成环）
    void link(int x, int y)
    {
        makeroot(x);          // 将x设为根
        if (findroot(y) != x) // 若x和y不连通
        {
            tr[x].fa = y; // 将x的父节点设为y，建立连接
        }
    }

    // Cut操作：断开x和y的连接（要求x和y直接相连且形成树边）
    void cut(int x, int y)
    {
        makeroot(x); // 将x设为根
        // 条件：y在x的子树中，且y是x的直接子节点，且y无左子树（确保是直接相连的树边）
        if (findroot(y) == x && tr[y].fa == x && !tr[y].s[0])
        {
            tr[x].s[1] = 0; // 断开x的右子树（假设y是x的右子节点）
            tr[y].fa = 0;   // 断开y的父节点
            pushup(x);      // 更新x的统计量
        }
    }

    // Change操作：修改节点i的权值为val（单点修改）
    void change(int i, T val)
    {
        splay(i);        // 将i旋转到根，确保直接访问
        tr[i].val = val; // 修改权值
        pushup(i);       // 向上更新统计量
    }
};
```

## 并查集
并查集是维护无向图连通性的数据结构，它本质是一个森林，它通过![image](https://cdn.nlark.com/yuque/__latex/b6a68bffd59def8247ed510be1f253a4.svg)操作找到每个点的根节点，通过![image](https://cdn.nlark.com/yuque/__latex/fe5ecbec1e96a37e46f979f585190277.svg)操作合并节点，从而维护连通性。

并查集有两个重要的优化，按秩合并和路径压缩，这两种方法截然不同且适用场景也不同，但目的都是为了减小时间复杂度。但往往我们认为 路径压缩更高效，甚至可以视作均摊![image](https://cdn.nlark.com/yuque/__latex/a2006f1ac61cb1902beacb3e29fff089.svg)

先说按秩合并，按秩合并的本质是维护树高，也就是说按某个标准合并可以保证树高不会太高，假如我们用![image](https://cdn.nlark.com/yuque/__latex/1124e4fc32ab45d62f0e2fde1a6328b7.svg)数组表示树高，那么合并时如果![image](https://cdn.nlark.com/yuque/__latex/6830be653b87833351566476101d1192.svg)，我们就把![image](https://cdn.nlark.com/yuque/__latex/712ecf7894348e92d8779c3ee87eeeb0.svg)合并给![image](https://cdn.nlark.com/yuque/__latex/947eb82adf8e060dd9e14a2ced68c45a.svg)。当然我们的标准不止有树高，也可以根据子树大小按秩合并

再说路径压缩，路径压缩实际上是在![image](https://cdn.nlark.com/yuque/__latex/0de1061299022a552d861db5a5881e70.svg)过程中调整并查集结构的做法，实际上也是在减小树高，如果![image](https://cdn.nlark.com/yuque/__latex/bf98c0ddcbe9c1e535f767c78c3aa813.svg)是![image](https://cdn.nlark.com/yuque/__latex/712ecf7894348e92d8779c3ee87eeeb0.svg)所在连通块的根，且是![image](https://cdn.nlark.com/yuque/__latex/712ecf7894348e92d8779c3ee87eeeb0.svg)的![image](https://cdn.nlark.com/yuque/__latex/df976ff7fcf17d60490267d18a1e3996.svg)级祖先，那么我们第一次查找![image](https://cdn.nlark.com/yuque/__latex/bfce9e28ac7c726aba85cba2a4aeae1e.svg)自然需要跳![image](https://cdn.nlark.com/yuque/__latex/6a6b811a2879516d7418f3d7325a142d.svg)次，但我们这次操作之后，自然知道![image](https://cdn.nlark.com/yuque/__latex/e9d88480bb6cdf2e9437ca49a49d713b.svg),于是我们在![image](https://cdn.nlark.com/yuque/__latex/b6a68bffd59def8247ed510be1f253a4.svg)过程中重新调整![image](https://cdn.nlark.com/yuque/__latex/6b043ec0fc3db51c3b5ff8fede560b15.svg),使得树高直接减小为![image](https://cdn.nlark.com/yuque/__latex/53072c2388d69edc65c2377681e4e87c.svg)

#### 并查集(路径压缩)
```cpp
struct DSU
{
    int n;
    std::vector<int> pre;
    DSU(int n) : n(n), pre(n + 1)
    {
        for (int i = 1; i <= n; ++i)
        {
            pre[i] = i;
        }
    }
    int root(int x)
    {
        return pre[x] = (pre[x] == x ? x : root(pre[x]));
    }
    void merge(int x, int y)
    {
        pre[root(x)] = root(y);
    }
    bool iscon(int x, int y)
    {
        return root(x) == root(y);
    }
};
```

#### 并查集(按秩合并)
```cpp
struct DSU
{
    int n;
    std::vector<int> pre;
    std::vector<int> siz;
    DSU(int n) : n(n), pre(n + 1), siz(n + 1)
    {
        for (int i = 1; i <= n; ++i)
        {
            pre[i] = i;
            siz[i] = 1;
        }
    }
    int root(int x)
    {
        return pre[x] = (pre[x] == x ? x : root(pre[x]));
    }
    void merge(int x, int y)
    {
        int xx = root(x), yy = root(y);
        if(xx==yy)
        {
            return;
        }
        if (siz[xx] < siz[yy])
        {
            std::swap(xx, yy);
        }
        pre[yy] = xx;
        siz[xx] += siz[yy];
    }
    bool iscon(int x, int y)
    {
        return root(x) == root(y);
    }
};
```

#### 带权并查集
带权并查集，很多时候我们不仅仅需要维护连通性之间的关系，还需要维护其他信息，需要使用带权并查集，带权并查集的信息全都是该节点到根节点的信息总和。这一点是理解带权并查集的根本

我们以![image](https://cdn.nlark.com/yuque/__latex/8597b8ad64ac82614635dd0459956516.svg)为例，![image](https://cdn.nlark.com/yuque/__latex/e3e045c36b8ec3f2ba0f2d4832f089f0.svg)代表![image](https://cdn.nlark.com/yuque/__latex/0a25ff5d5f49aeb7283b1b06cf5b55d5.svg)到其根节点的边权异或和。

在带权并查集中我们仍然能使用路径压缩，但需要在压缩过程中维护正确的信息,也就是说，在我更改我的![image](https://cdn.nlark.com/yuque/__latex/0616f71e38835f175fc4c5847fd860ce.svg)时，还要维护![image](https://cdn.nlark.com/yuque/__latex/8597b8ad64ac82614635dd0459956516.svg)的正确性，因为我的初始路径在压缩后，这个路径的信息也应该被压缩到我上面

举例来说,一开始路径为![image](https://cdn.nlark.com/yuque/__latex/517b16b7ad797e4386804718fbf749d5.svg),我们路径压缩后变为![image](https://cdn.nlark.com/yuque/__latex/7ed833c49bbcb48e46d430089d18ea56.svg)，但是我们的![image](https://cdn.nlark.com/yuque/__latex/77c3adce895348f6083c425fe1ba2624.svg)节点丢失了![image](https://cdn.nlark.com/yuque/__latex/117ba86ab7a5b297a31475dcf2a82a71.svg)路径上的信息，我们在递归时直接把信息整合到到![image](https://cdn.nlark.com/yuque/__latex/1613553bfcf54eae41056a542a783634.svg)上即可,除了![image](https://cdn.nlark.com/yuque/__latex/b6a68bffd59def8247ed510be1f253a4.svg)的直接儿子外，其他儿子都需要维护![image](https://cdn.nlark.com/yuque/__latex/8597b8ad64ac82614635dd0459956516.svg)。

```cpp
struct DSU
{
    int n;
    std::vector<int> pre, val;

    int root(int x) // 路径压缩并更新信息
    {
        if (pre[x] == x)
        {
            return x;
        }
        int fa = root(pre[x]);
        val[x] ^= val[pre[x]];
        pre[x] = fa;
        return fa;
    }
    DSU(int n) : n(n), pre(n + 1), val(n + 1)
    {
        for (int i = 1; i <= n; ++i)
        {
            pre[i] = i;
            val[i] = 0;/
        }
    }
    bool merge(int u, int v, int w) // 加入一条长度为w的边
    {
        int a = root(u), b = root(v);
        if (a == b)
        {
            return false;
        }
        else
        {
            pre[b] = a;
            val[b] = val[u] ^ val[v] ^ w;
            return true;
        }
    }
};
```

####  回滚并查集
由于并查集的特性，并查集并不支持删除，但可以支持撤销操作，原理十分简单，就是把所有操作记下来，撤销就是还原之前的修改，我们称为回滚并查集，注意回滚并查集只能使用按秩合并，而不能路径压缩。

```cpp
struct DSU
{
    int n;
    std::vector<int> pre;
    std::vector<int> siz;
    std::vector<std::pair<int &, int>> rollback_siz, rollback_pre;
    DSU(int n) : n(n), pre(n + 1), siz(n + 1)
    {
        for (int i = 1; i <= n; ++i)
        {
            pre[i] = i;
            siz[i] = 1;
        }
    }
    int root(int x)
    {
        while (x != pre[x])
        {
            x = pre[x];
        }
        return x;
    }
    int Size(int x)
    {
        return siz[root(x)];
    }
    void merge(int x, int y)
    {
        int xx = root(x), yy = root(y);
        if (xx == yy)
        {
            return;
        }
        if (siz[xx] < siz[yy])
        {
            std::swap(xx, yy);
        }
        rollback_siz.push_back({siz[xx], siz[xx]});
        siz[xx] += siz[yy];
        rollback_pre.push_back({pre[yy], pre[yy]});
        pre[yy] = xx;
    }
    bool iscon(int x, int y)
    {
        return root(x) == root(y);
    }
    void rollback(int t) // 只保留前t次操作
    {
        while (rollback_siz.size() > t)
        {
            rollback_pre.back().first = rollback_pre.back().second;
            rollback_pre.pop_back();
            rollback_siz.back().first = rollback_siz.back().second;
            rollback_siz.pop_back();
        }
    }
};
```

## 根号算法
### 分块
我们把一个序列分成若干个块，我们记块长为![image](https://cdn.nlark.com/yuque/__latex/54f5fb1b07a88521e7b036e3bc7a5e33.svg)，序列长度为![image](https://cdn.nlark.com/yuque/__latex/bbf0920b9f21222367e287a018a2b47e.svg),那么共有![image](https://cdn.nlark.com/yuque/__latex/2a48b9a7de8e14ca18f938d31e5091b4.svg)个块，我们考虑对一个区间![image](https://cdn.nlark.com/yuque/__latex/371d3811de80d3e7a448b5cebe095023.svg)操作，我们考虑线段树的懒标记思想，我们对完整的块打标记，对不完整的块暴力操作。那么复杂度为块数+块长，即![image](https://cdn.nlark.com/yuque/__latex/5c7fa5e7afa7537a8ee1c887786c398c.svg)，当![image](https://cdn.nlark.com/yuque/__latex/e562523062de064a7f292cc0826b1306.svg)时最小。

特别的，我们有时候取一个固定的块长![image](https://cdn.nlark.com/yuque/__latex/54f5fb1b07a88521e7b036e3bc7a5e33.svg)往往有更小的常数，视题目而定。

分块可以对区间进行，也可以在值域上进行，分为序列分块和值域分块。

```cpp
template <class T>

class Block
{
public:
    Block(int _n) : n(_n), belong(_n + 1), val(_n + 1, 0)
    {
        blockSize = sqrt(2 * n);
        blockNum = n / blockSize + (bool)(n % blockSize);
        L.resize(blockNum + 1);
        R.resize(blockNum + 1);
        lazy.resize(blockNum + 1, 0);
        sum.resize(blockNum + 1, 0);
        for (int i = 1; i <= n; ++i)
        {
            belong[i] = (i - 1) / blockSize + 1;
        }
        for (int i = 1; i <= blockNum; ++i)
        {
            L[i] = (i - 1) * blockSize + 1;
            R[i] = i * blockSize;
        }
        R[blockNum] = n;
    }

    void singleModify(int pos, T newVal)
    {
    }
    void rangeModify(int l, int r)
    {
    }
    int rangeQuery(int l, int r)
    {
    }

private:
    int n, blockSize, blockNum;    // 序列长度，块长，块数
    std::vector<int> belong, L, R; // 块编号，左端点，右端点
    std::vector<T> val, lazy, sum;
};
```

### 分块高级技巧
值域分块

用于解决一些和值域相关的查询问题，比如查询mex，可以在O(sqrt(V))的时间内配合莫队做到

定期重构

有两种作用

第一是解决无法维护信息，我们可以不对修改操作进行实际上的更改而是先存下来修改，我们不妨设当前存下的修改数量是![image](https://cdn.nlark.com/yuque/__latex/54f5fb1b07a88521e7b036e3bc7a5e33.svg)，那么我们每次询问需要遍历这![image](https://cdn.nlark.com/yuque/__latex/54f5fb1b07a88521e7b036e3bc7a5e33.svg)个修改来求答案，但当![image](https://cdn.nlark.com/yuque/__latex/54f5fb1b07a88521e7b036e3bc7a5e33.svg)很大时我们不可接受，于是在![image](https://cdn.nlark.com/yuque/__latex/0de821a0fa000921810bd8fa6fb2cd5a.svg)时我们考虑直接把这些修改一起重构到整个数组上(如果可以O(n)解决所有修改)，那么我们的复杂度是![image](https://cdn.nlark.com/yuque/__latex/54790b2f6e2541db786950a8fcfe7993.svg)

第二是维护分块平衡，在分块中我们可能面临插入或者删除操作，当这样的操作过多时块的大小不再平衡，最坏情况下块会变成![image](https://cdn.nlark.com/yuque/__latex/0717263d0e51d0534ce3c7442392c068.svg)，我们考虑每![image](https://cdn.nlark.com/yuque/__latex/86c3cba5f89aa9686f9bc3b9bfaaaa0e.svg)次修改就重新构建整个分块

### 莫队
莫队是针对形如![image](https://cdn.nlark.com/yuque/__latex/4ef7132d0df72d9e3db76f6391960a3d.svg)次询问，每次给定![image](https://cdn.nlark.com/yuque/__latex/0ed4e429fb69de3ef9edf438480e3e46.svg)询问区间信息的暴力算法，其思想一定程度上基于分块，通过把序列分块的方式，我们离线所有询问，询问区间![image](https://cdn.nlark.com/yuque/__latex/b573de029b4c5bc9d4f696989eec3a2e.svg)按左端点所在块编号为第一关键字，右端点为第二关键字排序，然后操控指针移动暴力求解。可以证明在这样的操作顺序下，指针移动次数是![image](https://cdn.nlark.com/yuque/__latex/50c625d8680b035a427bd2893d6858d9.svg)数量级的,所以复杂度也为![image](https://cdn.nlark.com/yuque/__latex/1a7b403708521e1e205597ebf6d4d531.svg) 

#### 普通莫队
```cpp
struct Query
{
    int l, r, id;
};
template <class T>
class MoTeam
{
public:
    MoTeam(std::vector<T> &a) : n(a.size() - 1), B(sqrt(2 * n)), val(a) {}

    int be(int x)
    {
        return (x - 1) / B + 1;
    }
    void addQuery(int l, int r, int id)
    {
        Q.push_back(Query{l, r, id});
    }
    void add(T x)
    {
    }
    void del(T x)
    {
    }

    std::vector<T> work()
    {
        std::sort(begin(Q), end(Q), [&](const auto &s, const auto &t)
                  { return be(s.l) == be(t.l) ? s.r < t.r : s.l < t.l; });
        int pl = 1, pr = 0;
        for (const auto &[l, r, id] : Q)
        {
            while (pl < l)
                del(val[pl++]);
            while (pl > l)
                add(val[--pl]);
            while (pr < r)
                add(val[++pr]);
            while (pr > r)
                del(val[pr--]);
            // ans[id] = ;
        }
        return ans;
    }

private:
    int n, B;
    std::vector<T> val;
    std::vector<T> ans;
    std::vector<Query> Q;
};
```

#### 回滚莫队
回滚莫队是处理一类特殊的问题，问题的信息只满足可加性或者可减性，也就是我们只能![image](https://cdn.nlark.com/yuque/__latex/a2006f1ac61cb1902beacb3e29fff089.svg)维护加数字或者减数字，那么我们可以采用回滚莫队。我们以只加不减回滚莫队为例，回滚莫队的思想是，对于左右端点都处在一个块内的询问，我们单独处理，暴力求解，否则我们挨个块考虑，由于我们的右端点从小到大排序，所以让其不断右移即可，对于左端点，我们不具有大小关系，我们可以记录左指针移动之前的答案，在移动完左指针求解答案之后，我们把答案重新置为记录的答案，相当于回滚了答案，处理了不能减的弊端。但需要注意回滚时需要清除左边的信息,复杂度![image](https://cdn.nlark.com/yuque/__latex/1a7b403708521e1e205597ebf6d4d531.svg)



其中只加不减的经典问题为区间众数，只减不加的经典问题是区间![image](https://cdn.nlark.com/yuque/__latex/fbccaf4ac33cf6843799879b2f545a4b.svg)。后者在询问时可以用值域分块维护。

```cpp
struct Query
{
    int l, r, id;
};
template <class T>
class RollbackMoTeam
{
public:
    RollbackMoTeam(std::vector<T> &a) : n(a.size() - 1), B(sqrt(2 * n)), val(a)
    {
        blockNum = n / B + bool(n % B);
        res = last = 0;
    }

    int be(int x)
    {
        return (x - 1) / B + 1;
    }
    void addQuery(int l, int r, int id)
    {
        Q.push_back(Query{l, r, id});
    }
    void add(T x) // add和del只要一个
    {
    }
    // void del(T x)
    // {
    //}

    void clear()
    {
        res = last = 0;
        // 这里要清空之前的所有信息
    }
    T calc(int l, int r)
    {
    }

    std::vector<T> work()
    {
        std::sort(begin(Q), end(Q), [&](const auto &s, const auto &t)
                  { return be(s.l) == be(t.l) ? s.r < t.r : s.l < t.l; });

        int idx = 0;
        for (int i = 1; i <= blockNum; ++i) // 对每个块单独考虑
        {
            clear();
            int R = std::min(B * i, n);
            int pl = R + 1, pr = R;
            for (; be(Q[idx].l) == i; ++idx)
            {
                auto [l, r, id] = Q[idx];
                if (r - l + 1 <= B)
                {
                    ans[id] = calc(l, r);
                }
                else
                {
                    while (pr < r)
                    {
                        add(val[++pr]); // 右扩展
                    }
                    last = res; // 结果存为last
                    while (pl > l)
                    {
                        add(val[--pl]); // 左扩展
                    }
                    ans[id] = res; // 结果存入答案
                    while (l <= R)
                    {
                        // 清空信息 add加了什么就清空什么
                        l++;
                    }
                    res = last; // 回滚结果
                }
            }
        }
        return ans;
    }

private:
    int n, B, blockNum;
    std::vector<T> val;
    std::vector<T> ans;
    std::vector<Query> Q;
    T res, last;
};

```

#### 带修莫队
我们考虑给询问加上一维时间轴信息，该时间对应着该询问之前最后一次修改操作的编号，我们加入第三个修改指针，每次和![image](https://cdn.nlark.com/yuque/__latex/38a75e2625c40ab9912d5b014bdcfab3.svg)一样移动修正贡献即可。我们取![image](https://cdn.nlark.com/yuque/__latex/c6b0d6a03cfafa23f6a60468e11ae1a3.svg)，复杂度为![image](https://cdn.nlark.com/yuque/__latex/bbbdd5693f65821471143d7adfc77253.svg)。

```cpp
struct Query
{
    int l, r, id, time;
};
struct Modify
{
    int pos, newVal;
    // pos是修改的位置，val为修改后的值
};
template <class T>
class ModifyMoTeam
{
public:
    ModifyMoTeam(std::vector<T> &a) : n(a.size() - 1), val(a)
    {
        B = pow(n, 0.666);
    }
    void addQuery(int l, int r)
    {
        Q.push_back(Query{l, r, Q.size(), M.size()});
    }
    void addModify(int pos, T val)
    {
        M.push_back({pos, val});
    }
    void add(T x) // add和del只要一个
    {
    }
    void del(T x)
    {
    }
    void actionModify(int modifyTime, int queryTime) // type表示是加入还是删除
    {
        auto &[pos, newVal] = M[modifyTime];
        auto &[l, r, id, time] = Q[queryTime];
        if (pos >= l and pos <= r)
        {
            del(val[pos]); // 删去原本的值
            add(newVal);   // 加入新的值
        }
        std::swap(newVal, val[pos]); // 方便一会交换回来
    }

    std::vector<T> work()
    {
        std::sort(begin(Q), end(Q), [&](const auto &s, const auto &t)
                  { return s.l / B == t.l / B ? (s.r / B == t.r / B ? s.time < t.time : s.r < t.r) : s.l < t.l; });

        int pl = 1, pr = 0, pt = 0;
        for (auto [l, r, id, t] : Q)
        {
            while (pl < l)
                del(val[pl++]);
            while (pl > l)
                add(val[--pl]);
            while (pr > r)
                del(val[pr--]);
            while (pr < r)
                add(val[++pr]);
            while (pt < t)
                actionModify(++pt, id);
            while (pt > t)
                actionModify(pt--, id);
            // ans[id] = ; //
        }
        return ans;
    }

private:
    int n, B, blockNum;
    std::vector<T> val;
    std::vector<T> ans;
    std::vector<Query> Q;
    std::vector<Modify> M;
};

```

#### 树上莫队
我们通过树的欧拉序（括号序）把链转化为序列来做，我们不妨为![image](https://cdn.nlark.com/yuque/__latex/d0546b061bbe047e6e7ac5bde453ba5d.svg)，![image](https://cdn.nlark.com/yuque/__latex/6241799fb5e07444e80c08d5c8962b5c.svg)表示欧拉序，那么我们需要对询问分情况讨论：若询问![image](https://cdn.nlark.com/yuque/__latex/a969cab25db24b7b40ddd3064d3ab658.svg)是一条链（即![image](https://cdn.nlark.com/yuque/__latex/2d256c01464dc17157edb102917187e0.svg)或![image](https://cdn.nlark.com/yuque/__latex/98502ce74f5a894a0f9de72e6223c230.svg)），我们查询的区间为![image](https://cdn.nlark.com/yuque/__latex/dab5df27dba7a1202611f817828f5480.svg)，这样做的原理是非链上的节点会出现两次，我们第二次遍历删除其贡献即可。若![image](https://cdn.nlark.com/yuque/__latex/a969cab25db24b7b40ddd3064d3ab658.svg)不是一条链，我们查询的区间为![image](https://cdn.nlark.com/yuque/__latex/b330d0c2a9d9c1278d2a4858cb029f99.svg),但这样会漏掉![image](https://cdn.nlark.com/yuque/__latex/a5f1a3b1ccbcb20d75ccf0efa8b7bb12.svg)的贡献，我们需要单独统计。由于欧拉序，空间需要开两倍，请格外注意。

```cpp
struct Query
{
    int l, r, lca, id; // 路径查询参数：欧拉序区间[l,r]，最近公共祖先lca，查询编号id
};

template <class T>
class MoTeamOnTree
{
public:
    // 构造函数：初始化树的基本信息和莫队分块参数
    MoTeamOnTree(std::vector<std::vector<std::pair<int, int>>> &g, std::vector<T> &a) : n(a.size() - 1), val(a), in(n + 1), out(n + 1), siz(n + 1), son(n + 1), top(n + 1), dep(n + 1)
    {
        used.assign(2 * n + 1, 0);  // 标记节点是否被选中
        eulerOrder.resize(2 * n + 1); // 存储欧拉序遍历结果
        B = sqrt(n * 2);  // 分块大小，决定莫队算法的时间复杂度
    }

    // 添加查询：将树上路径转换为欧拉序区间
    void addQuery(int l, int r, int id)
    {
        if (in[l] > in[r]) std::swap(l, r);  // 确保左端点欧拉序更小
        int lca = getLca(l, r);  // 计算路径的最近公共祖先
        if (lca == l)
        {
            Q.push_back({in[l], in[r], 0, id});  // 路径为直链，直接记录欧拉序区间
        }
        else
        {
            Q.push_back({out[l], in[r], lca, id});  // 路径跨越LCA，记录特殊区间
        }
    }
    
    // 添加元素到当前窗口（需用户自定义实现统计逻辑）
    void add(T x) {}
    
    // 从当前窗口删除元素（需用户自定义实现统计逻辑）
    void del(T x) {}

    // 修改元素状态：添加/删除元素并更新标记
    void modify(int x)
    {
        (used[x] ? del(val[x]) : add(val[x]));  // 根据标记决定添加或删除
        used[x] = (used[x] ? 0 : 1);  // 翻转标记状态
    }

    // 执行莫队算法：处理所有查询并返回结果
    std::vector<T> work()
    {
        // 按块排序查询：保证同一块内右端点单调递增
        std::sort(begin(Q), end(Q), [&](const auto &s, const auto &t)
                  { return be(s.l) == be(t.l) ? s.r < t.r : s.l < t.l; });

        int pl = 1, pr = 0;  // 当前窗口的左右指针
        for (const auto &[l, r, lca, id] : Q)
        {
            // 移动左指针到目标位置
            while (pl < l) modify(eulerOrder[pl++]);
            while (pl > l) modify(eulerOrder[--pl]);
            // 移动右指针到目标位置
            while (pr > r) modify(eulerOrder[pr--]);
            while (pr < r) modify(eulerOrder[++pr]);
            
            if (lca) modify(lca);  // 处理LCA节点（如果存在）
            
            // ans[id] = ;  // 用户需在此处添加结果计算逻辑
            
            if (lca) modify(lca);  // 恢复LCA节点状态
        }
        return ans;
    }

private:
    int n, B;  // 节点数和分块大小
    std::vector<T> val;  // 节点权值数组
    std::vector<T> ans;  // 查询结果数组
    std::vector<bool> used;  // 元素是否在当前窗口中的标记
    std::vector<int> eulerOrder;  // 存储欧拉序遍历结果
    std::vector<Query> Q;  // 存储所有查询

    // 树链剖分所需数组
    std::vector<int> in, out, dep, top, siz, son;
    
    // 计算元素所在块的编号
    int be(int x) { return (x - 1) / B + 1; }
    
    int idx = 0;  // 欧拉序生成的全局计数器
    
    // 第一次DFS：计算子树大小、重儿子、深度和欧拉序（需用户实现）
    void dfs1(int u, int fa) {}
    
    // 第二次DFS：计算链顶和处理轻边（需用户实现）
    void dfs2(int u, int top) {}
    
    // 计算最近公共祖先（需用户实现）
    int getLca(int u, int v) {}
};
```

#### 莫队二次离线
用于解决莫队指针移动复杂度不正确的问题，也就是说我们不能![image](https://cdn.nlark.com/yuque/__latex/a2006f1ac61cb1902beacb3e29fff089.svg)移动指针，我们可以考虑存下一些不能快速计算的贡献，在莫队执行完后单独统计。

我们以区间询问逆序对为例，我们考虑右扩展![image](https://cdn.nlark.com/yuque/__latex/6fc8a7b027262204b24b9b20465ffb65.svg)时新增的贡献是![image](https://cdn.nlark.com/yuque/__latex/371d3811de80d3e7a448b5cebe095023.svg)中大于![image](https://cdn.nlark.com/yuque/__latex/038d85484bdae37008217453a0882514.svg)的数字个数，我们用![image](https://cdn.nlark.com/yuque/__latex/e881f7c9ce8a35fff199e6aeeec433f1.svg)表示![image](https://cdn.nlark.com/yuque/__latex/57f32390aa90145a1bbf349d60bd5ddb.svg)中大于![image](https://cdn.nlark.com/yuque/__latex/9c1405669cdcbe9f8f077325a6e14fdd.svg)的个数，那么该贡献可以写![image](https://cdn.nlark.com/yuque/__latex/2dd20fc66c703173dd052d70042d5455.svg)

前一部分我们可以预处理出，后一部分我们考虑存下该查询，最后统一查询即可。那么我们统一查询的数量共有![image](https://cdn.nlark.com/yuque/__latex/b4f2f0d80f2d840285231e78078ebb4e.svg)个，问题形如求![image](https://cdn.nlark.com/yuque/__latex/57f32390aa90145a1bbf349d60bd5ddb.svg)的前缀中![image](https://cdn.nlark.com/yuque/__latex/bf98c0ddcbe9c1e535f767c78c3aa813.svg)的排名。这个我们可以考虑用![image](https://cdn.nlark.com/yuque/__latex/8ebcb034111ccc4534cee7e5351a780b.svg)的插入和![image](https://cdn.nlark.com/yuque/__latex/a2006f1ac61cb1902beacb3e29fff089.svg)查询的值域分块解决。

（值域分块![image](https://cdn.nlark.com/yuque/__latex/6f2a8a631e25507ecbdc99f6c940a827.svg):我们插入一个数![image](https://cdn.nlark.com/yuque/__latex/712ecf7894348e92d8779c3ee87eeeb0.svg)时，暴力更新![image](https://cdn.nlark.com/yuque/__latex/712ecf7894348e92d8779c3ee87eeeb0.svg)所在块的每个位置的答案，对其他块打懒标记即可，复杂度为![image](https://cdn.nlark.com/yuque/__latex/8ebcb034111ccc4534cee7e5351a780b.svg),对于查询，就是每个点的答案加上所在块的懒标记答案）

需要注意的是我们解决的是答案的变化量，也就是最后前缀和才是正确的答案

## 离线分治算法
#### CDQ分治
CDQ分治是一种高效统计点对数量的分治算法，具体的说，我们对于一个区间![image](https://cdn.nlark.com/yuque/__latex/91b74cc3e8f2f10061360acd51bfe50b.svg)统计满足某种条件的点对数量，我们考虑跨过中点![image](https://cdn.nlark.com/yuque/__latex/689295fb72b63ee1db32afb2f3bbe8b8.svg)的贡献，对于没跨中间的贡献我们可以递归两边统计。

我们以三维![image](https://cdn.nlark.com/yuque/__latex/21ffbe77ebfc837bd427bbcefc0bc58a.svg)偏序为例，我们首先在最外层对![image](https://cdn.nlark.com/yuque/__latex/26fdbf8e53cb0e48da5f4ddd4aaf5a5c.svg)排序,然后我们单独对![image](https://cdn.nlark.com/yuque/__latex/427106f8802f426216fe766023b90416.svg)的![image](https://cdn.nlark.com/yuque/__latex/d29c2e5f4926e5b0e9a95305650f6e54.svg)排序，也对![image](https://cdn.nlark.com/yuque/__latex/f37974f21b50e02fb71872ed4ea1ead5.svg)的![image](https://cdn.nlark.com/yuque/__latex/d29c2e5f4926e5b0e9a95305650f6e54.svg)排序，这样我们可以用双指针扫描左边和右边区间使得![image](https://cdn.nlark.com/yuque/__latex/d29c2e5f4926e5b0e9a95305650f6e54.svg)满足条件，利用一个树状数组维护![image](https://cdn.nlark.com/yuque/__latex/b891664b42113aee13f0bac25eb998e5.svg)即可。复杂度为![image](https://cdn.nlark.com/yuque/__latex/2e1f294ec40ceb84f92961c667c63d2b.svg)

#### 整体二分
把所有的修改和询问视作一个序列按顺序存起来，我们用一个整体的二分分治函数去求解所有问题的答案，用![image](https://cdn.nlark.com/yuque/__latex/371d3811de80d3e7a448b5cebe095023.svg)表示当前处理的操作区间，![image](https://cdn.nlark.com/yuque/__latex/b573de029b4c5bc9d4f696989eec3a2e.svg)表示当前区间答案的值域范围，递归出口是![image](https://cdn.nlark.com/yuque/__latex/4441e4056c1fda34d7144ad1cc8e8c61.svg)或者![image](https://cdn.nlark.com/yuque/__latex/9ce3767815f935e81b50b702ddae46c4.svg),当![image](https://cdn.nlark.com/yuque/__latex/9ce3767815f935e81b50b702ddae46c4.svg)时区间![image](https://cdn.nlark.com/yuque/__latex/371d3811de80d3e7a448b5cebe095023.svg)的答案均为![image](https://cdn.nlark.com/yuque/__latex/c895173d3be4872abf206be4268a58cb.svg)。

## 线性基
线性基是通过一系列的线性变换/异或变换把一系列的向量转化为一组线性无关的基![image](https://cdn.nlark.com/yuque/__latex/2430560ec5c105a668925dd8fcdac841.svg)

在整数的异或线性基中，向量即为每个数的二进制表示，每个二进制位对应向量的一个位

假如说原本的数组通过异或得到的所有数字的集合为![image](https://cdn.nlark.com/yuque/__latex/55fc237afbe535f7d8434985b848a6a7.svg)，那么![image](https://cdn.nlark.com/yuque/__latex/2430560ec5c105a668925dd8fcdac841.svg)也可以得到![image](https://cdn.nlark.com/yuque/__latex/55fc237afbe535f7d8434985b848a6a7.svg)同时![image](https://cdn.nlark.com/yuque/__latex/2430560ec5c105a668925dd8fcdac841.svg)的大小最小，其大小上界为![image](https://cdn.nlark.com/yuque/__latex/a5f081dbcd26243a1ee4f07c325ca40f.svg)

通过导出的![image](https://cdn.nlark.com/yuque/__latex/2430560ec5c105a668925dd8fcdac841.svg)我们可以贪心解决异或最大值，![image](https://cdn.nlark.com/yuque/__latex/df976ff7fcf17d60490267d18a1e3996.svg)大值等问题。

#### 线性基
```cpp
/**
 * 线性基模板
 * T: 线性基的位数
 * G: 元素类型，通常为int或long long
 */
template <int T, class G>
struct LineBase
{
    std::vector<G> Base;  // 存储线性基的数组
    bool flag = false;    // 标记是否存在无法插入的元素（即是否存在异或和为0的子集）

    // 从数组初始化线性基
    LineBase(const std::vector<G> &a) : Base(T, 0)
    {
        for (int i = 1; i < a.size(); ++i)
        {
            insert(a[i]);
        }
    }

    // 默认构造函数
    LineBase() : Base(T, 0) {}

    // 插入元素x到线性基中
    void insert(G x)
    {
        for (int i = T - 1; ~i; i--)
        {
            if (x & (1ll << i))  // 如果x的第i位为1
            {
                if (!Base[i])    // 如果线性基的第i位为空
                {
                    Base[i] = x; // 插入x
                    return;
                }
                else
                {
                    x ^= Base[i]; // 否则消去x的第i位
                }
            }
        }
        flag = true; // 执行到这里说明x被消为0，存在异或和为0的子集
    }

    // 判断x能否由线性基中的元素异或得到
    bool check(G x)
    {
        for (int i = T - 1; ~i; --i)
        {
            if (x & (1ll << i))  // 如果x的第i位为1
            {
                if (!Base[i])    // 线性基的第i位为空，无法表示
                {
                    return false;
                }
                else
                {
                    x ^= Base[i]; // 消元操作
                }
            }
        }
        return true; // 能消为0，说明可以表示
    }

    // 查询线性基能表示的最大异或和
    G qmax()
    {
        G res = 0;
        for (int i = T - 1; ~i; --i)
        {
            res = std::max(res, res ^ Base[i]); // 贪心选择能使结果更大的元素
        }
        return res;
    }

    // 查询线性基能表示的最小异或和
    G qmin()
    {
        if (flag) // 存在异或和为0的子集
        {
            return 0;
        }
        for (int i = 0; i < T; ++i)
        {
            if (Base[i]) // 找到第一个非零元素即为最小值
            {
                return Base[i];
            }
        }
        return 0; // 线性基为空的情况
    }

    // 查询第k小的异或和
    G val(G k)
    {
        std::vector<G> tmp(T);
        G res = 0;
        G cnt = 0;
        k -= flag; // 减去0的情况
        if (!k)
        {
            return 0;
        }

        // 重构线性基，使其变为上三角形式
        for (int i = 0; i < T; ++i)
        {
            G now = Base[i];
            for (int j = i - 1; ~j; j--)
            {
                if (now & (1ll << j))
                {
                    now ^= Base[j];
                }
            }
            if (now)
            {
                tmp[cnt++] = now;
            }
        }

        if (k >= (1ll << cnt)) // 超出范围
        {
            return -1;
        }

        // 根据k的二进制位选择对应的基向量
        for (int i = 0; i < cnt; ++i)
        {
            if (k & (1ll << i))
            {
                res ^= tmp[i];
            }
        }
        return res;
    }

    // 查询val的排名（即比val小的异或和数量+1）
    G rank(int val)
    {
        if (val > qmax()) // 超出最大值
        {
            return -1;
        }
        
        G res = 0;
        if (flag) // 存在0的情况
        {
            res++;
        }
        
        std::vector<G> st(T);
        int cnt = 0;
        
        // 收集所有非零基向量的位置
        for (int i = 0; i < T; ++i)
        {
            if (Base[i])
            {
                st[cnt++] = i;
            }
        }
        
        // 计算排名
        for (int i = 0; i < cnt; ++i)
        {
            if (val >> st[i] & 1)
            {
                res += 1ll << i; // 累加贡献
            }
        }
        return res;
    }

    // 查询线性基能表示的不同异或和的数量
    G num()
    {
        return rank(qmax()); // 即最大值的排名
    }
};
```

#### 前缀线性基
可以理解为可持久化线性基，本质就是建立了不同版本的线性基。我们用![image](https://cdn.nlark.com/yuque/__latex/dcd16daf74aebc0cc754100ea4687b7b.svg)表示第![image](https://cdn.nlark.com/yuque/__latex/f7f33cfac20ec37aaea0774bd069b82b.svg)个版本的线性基第![image](https://cdn.nlark.com/yuque/__latex/2443fbcfeb7e85e1d62b6f5e4f27207e.svg)个位的基，用![image](https://cdn.nlark.com/yuque/__latex/26ca62e6b757d93bdf3ad6fb83b0deb4.svg)表示该基最晚出现的位置（贪心），如果新加入的数可以导出某个基且出现位置更晚，我们就和原本的基贪心的交换位置。因为我们对于区间询问![image](https://cdn.nlark.com/yuque/__latex/371d3811de80d3e7a448b5cebe095023.svg)，我们会查![image](https://cdn.nlark.com/yuque/__latex/72cb3a229067770aeb6caa625a65a1a1.svg)版本的线性基，如果某个位置![image](https://cdn.nlark.com/yuque/__latex/2443fbcfeb7e85e1d62b6f5e4f27207e.svg)的基的最晚出现位置![image](https://cdn.nlark.com/yuque/__latex/1d7bdcb80376fed4b9a389987c7a639d.svg)，就说明这个基是可用的。

```cpp
/**
 * 可持久化线性基模板
 * Z: 线性基的位数
 * G: 元素类型，通常为int或long long
 */
template <int Z, class G>
struct PreLineBase
{
    // p[i][j]: 第i个版本中第j位的线性基元素
    // pos[i][j]: 第i个版本中第j位线性基元素的插入位置
    std::vector<std::array<int, Z>> p;
    std::vector<std::array<int, Z>> pos;

    // 构造函数，从数组a初始化可持久化线性基
    PreLineBase(const std::vector<G> &a) : p(a.size()), pos(a.size())
    {
        // 初始化第0个版本
        for (int i = 0; i < Z; ++i)
        {
            p[0][i] = pos[0][i] = 0;
        }
        // 逐个插入元素，生成新版本
        for (int i = 1; i < a.size(); ++i)
        {
            insert(a[i], i);
        }
    }

    // 插入元素x，生成新版本idx
    void insert(G x, int idx)
    {
        // 继承前一个版本的数据
        p[idx] = p[idx - 1];
        pos[idx] = pos[idx - 1];
        int cur = idx;  // 当前元素的插入位置

        // 从高位到低位处理每一位
        for (int i = Z - 1; i >= 0; --i)
        {
            if (x >> i & 1)  // 如果x的第i位为1
            {
                if (!p[idx][i])  // 如果线性基的第i位为空
                {
                    p[idx][i] = x;     // 插入x
                    pos[idx][i] = cur; // 记录插入位置
                    break;
                }
                
                // 贪心策略：保留插入位置较后的元素
                if (pos[idx][i] < cur)
                {
                    std::swap(p[idx][i], x);
                    std::swap(pos[idx][i], cur);
                }
                
                // 消元操作
                x ^= p[idx][i];
            }
        }
    }

    // 查询区间[l,r]内元素能组成的最大异或和
    G querymax(int l, int r)
    {
        G ans = 0;
        // 从高位到低位贪心选择
        for (int i = Z - 1; i >= 0; --i)
        {
            // 只考虑插入位置在[l,r]内的元素
            if (pos[r][i] >= l)
            {
                ans = std::max(ans, ans ^ p[r][i]);
            }
        }
        return ans;
    }

    // 判断区间[l,r]内元素能否异或得到x
    bool isexist(int l, int r, G x)
    {
        // 从高位到低位处理
        for (int i = Z - 1; i >= 0; --i)
        {
            if ((x >> i & 1) and pos[r][i] < l)
            {
                // 如果x的第i位为1，但对应线性基元素的插入位置小于l，无法生成
                return false;
            }
            else if (x >> i & 1)
            {
                // 消元操作
                x ^= p[r][i];
            }
        }
        // 如果能消为0，则可以生成
        return x == 0;
    }
};
```

前缀线性基也是可以建在树上的，类似于主席树维护树上信息，我们每次基于父节点的版本插入新版本。但查询链上的线性基不能差分，我们考虑对于一条链![image](https://cdn.nlark.com/yuque/__latex/838c98c94a4322ee88230f6f92e2ac73.svg)，我们求出![image](https://cdn.nlark.com/yuque/__latex/452cad0634d1fa5c60b6fdbbf31ee93c.svg)的线性基和![image](https://cdn.nlark.com/yuque/__latex/dc1b50d0a97438d456406a3ab5b7b7de.svg)的线性基暴力合并即可，这样复杂度为![image](https://cdn.nlark.com/yuque/__latex/49a3d22ae93e5950c22c53cc28ffc401.svg)

#### 可删除线性基
线性基本身是不支持删除操作的，但我们可以通过离线的手段达到同样的效果。具体的说，我们离线每个数字的被删除时间，我们类似前缀线性基一样记录一个最晚的被删除时间，这样查询时比较当前时间和该基的最晚删除时间即可判断是否可用。

```cpp
template <int Z, class T>
struct DeleteLineBase
{
    const int inf = 1e9;
    std::vector<T> Base;
    std::vector<int> ti; // 第i位的线性基最迟的删除时间
    DeleteLineBase(const std::vector<std::pair<int, int>> &a) : Base(Z, 0), ti(Z, inf)
    // 插入这个数和删除的时间  需要离线所有操作
    {
        for (int i = 1; i < a.size(); ++i)
        {
            insert(a[i].first, a[i].second);
        }
    }
    DeleteLineBase() : Base(Z, 0), ti(Z, inf)
    {
    }
    void insert(T x, int t)
    {
        for (int i = Z - 1; i >= 0; --i)
        {
            if (x >> i & 1)
            {
                if (ti[i] < t) // 贪心让被删除的时间更靠后
                {
                    std::swap(t[i], i);
                    std::swap(x, Base[i]);
                }
                x ^= Base[i];
            }
        }
    }
    T querymax(int t)
    {
        T res = 0;
        for (int i = Z - 1; i >= 0; --i)
        {
            if (ti[i] > t)
            {
                res = std::max(res, res ^ Base[i]);
            }
        }
        return res;
    }
};
```

## 堆
对于![image](https://cdn.nlark.com/yuque/__latex/a9c327ff81c313f934549ba01d77108b.svg)不再过多介绍

### 可删堆
用两个![image](https://cdn.nlark.com/yuque/__latex/a9c327ff81c313f934549ba01d77108b.svg)来实现，其中一个用来存要删除的数字，每次取![image](https://cdn.nlark.com/yuque/__latex/b828fb001cf6c5ad824d9d588244a1cd.svg)时判断是否需要弹出即可。

```cpp
template<class T>
struct Heap
{
    Heap() {}
    std::priority_queue<T> h, del;
    void erase(T x)
    {
        del.push(x);
    }
    void add(T x)
    {
        h.push(x);
    }
    int size()
    {
        return h.size() - del.size();
    }
    void pop()
    {
        assert(size());
        while (del.size() and del.top() == h.top())
        {
            h.pop();
            del.pop();
        }
        h.pop();
    }
    T top()
    {
        assert(size());
        while (del.size() and del.top() == h.top())
        {
            h.pop();
            del.pop();
        }
        return h.top();
    }
};
```

### 对顶堆
动态维护序列中第![image](https://cdn.nlark.com/yuque/__latex/df976ff7fcf17d60490267d18a1e3996.svg)大的数字，使用一个大根堆和一个小根堆动态维护即可。

堆实现 只支持加数字

```cpp
template <class T>
struct Heap
{
    std::priority_queue<T> a;
    std::priority_queue<T, std::vector<T>, std::greater<T>> b;

    void add(T x)
    {
        if (b.empty() or x >= b.top())
        {
            b.push(x);
        }
        else
        {
            a.push(x);
        }
    }
    T query(int k)
    {
        while (b.size() > k)
        {
            a.push(b.top());
            b.pop();
        }
        while (b.size() < k)
        {
            b.push(a.top());
            a.pop();
        }
        return b.top();
    }
};
```

![image](https://cdn.nlark.com/yuque/__latex/73d6921efa5a6d9656c8964d295ce2ad.svg)实现，支持加或者删数字

```cpp
template <class T>
struct Heap
{
    std::multiset<T> a;
    std::multiset<T> b;
    void add(T x)
    {
        if (b.empty() || x >= *b.begin())
        {
            b.insert(x);
        }
        else
        {
            a.insert(x);
        }
    }
    // 删除元素（如果存在）
    bool remove(T x)
    {
        // 先检查是否在b中
        auto it = b.find(x);
        if (it != b.end())
        {
            b.erase(it);
            return true;
        }
        // 再检查是否在a中
        it = a.find(x);
        if (it != a.end())
        {
            a.erase(it);
            return true;
        }
        // 元素不存在
        return false;
    }
    T query(int k)
    {
        while (b.size() > k)
        {
            auto val = *b.begin();
            b.erase(b.begin());
            a.insert(val);
        }
        while (b.size() < k)
        {
            auto val = *a.rbegin();
            a.erase(std::prev(a.end()));
            b.insert(val);
        }
        return *b.begin();
    }
    int size() const
    {
        return a.size() + b.size();
    }
};
```

### 可并堆（![image](https://cdn.nlark.com/yuque/__latex/f5e7401836f57f59370dbb9061a0be24.svg)实现）
请注意大根堆是![image](https://cdn.nlark.com/yuque/__latex/d28b8d358d3db04621b910f97e8c45bd.svg)，小根堆是![image](https://cdn.nlark.com/yuque/__latex/48ba0a94a8e55bde68004921b67a752e.svg)

使用教程：

我们在![image](https://cdn.nlark.com/yuque/__latex/11e86a4c2be45c24a2ad4c6d3284e6a1.svg)函数内自己开一个迭代器数组，当加上某个数，删除某个数，修改某个数，需要根据返回的![image](https://cdn.nlark.com/yuque/__latex/c69a88f07461809ec0544cd4316c6fa1.svg)自动更改迭代器为新迭代器或者![image](https://cdn.nlark.com/yuque/__latex/51e3ca1dce1f194f1e0121e3c6d8a1de.svg)，如果是删除堆顶，我们一开始传入数据时传入每个数字的下标，删除堆顶时手动把堆顶的下标对应的迭代器置为![image](https://cdn.nlark.com/yuque/__latex/51e3ca1dce1f194f1e0121e3c6d8a1de.svg)

```cpp
#include <bits/stdc++.h>
#include <bits/extc++.h> // 包含pbds库（部分编译器可能需要用#include <ext/pb_ds/priority_queue.hpp>）
namespace pbds = __gnu_pbds;
template <typename T, typename Compare = std::less<T>>
class mergeHeap
{
private:
    using Heap = pbds::priority_queue<T, Compare, pbds::binomial_heap_tag>;
    Heap heap_;

public:
    using it = typename Heap::point_iterator;
    mergeHeap() = default;
    it add(const T &value)
    {
        return heap_.push(value);
    }
    const T &top() const { return heap_.top(); }
    void pop() { heap_.pop(); }
    void erase(it t) { heap_.erase(t); }
    void merge(mergeHeap &other)
    {
        if (!other.empty())
            heap_.join(other.heap_);
    }
    bool empty() { return heap_.empty(); }
    int size() { return heap_.size(); }
    void clear() { heap_.clear(); }
    void swap(mergeHeap &other) { heap_.swap(other.heap_); }
    it update(it t, const T &new_value)
    {
        erase(t);
        return add(new_value); // 返回新的迭代器
    }
};
template <typename T>
using MinBinomialHeap = mergeHeap<T, std::greater<T>>;
template <typename T>
using MaxBinomialHeap = mergeHeap<T, std::less<T>>;

```

## 其他
#### 珂朵莉树
珂朵莉树（ODT）用于维护序列，其核心是一个![image](https://cdn.nlark.com/yuque/__latex/60904de69bdbaba6b978887e00fbcc5e.svg)的结构体![image](https://cdn.nlark.com/yuque/__latex/767e2bc28b23ee0a19f3bac38f112f49.svg)容器,其中![image](https://cdn.nlark.com/yuque/__latex/8597b8ad64ac82614635dd0459956516.svg)是![image](https://cdn.nlark.com/yuque/__latex/d84d8de6490c6b3a087e92ce5b4ffe02.svg)类型使得在![image](https://cdn.nlark.com/yuque/__latex/767e2bc28b23ee0a19f3bac38f112f49.svg)中该值可以被修改。那么![image](https://cdn.nlark.com/yuque/__latex/767e2bc28b23ee0a19f3bac38f112f49.svg)会自动按照左端点升序排序，每个节点都代表一个区间，该区间内每个位置的值相同，都为对应的![image](https://cdn.nlark.com/yuque/__latex/8597b8ad64ac82614635dd0459956516.svg)。

其核心操作为![image](https://cdn.nlark.com/yuque/__latex/b91f76bb7d004ce34fe062242045cc95.svg)和![image](https://cdn.nlark.com/yuque/__latex/349d7d978e8b84c06351c77fdbe77d22.svg),分裂和覆盖，在数据随机的情况下![image](https://cdn.nlark.com/yuque/__latex/349d7d978e8b84c06351c77fdbe77d22.svg)可以保证区间数量不会很多进而保证复杂度。

```cpp

template <class T>
class ODT
{

private:
    const T inf = std::numeric_limits<T>::max() / 2;
    struct Node
    {
        int l, r;      // 区间左右端点（闭区间 [l, r]）
        mutable T val; // 值（mutable 允许在 set 中修改值）

        // 用于 set 排序的运算符：按左端点 l 从小到大排序
        bool operator<(const Node &a) const
        {
            return l < a.l;
        }

        // 构造函数：默认构造一个单点区间或指定区间
        Node(int L, int R, T Val) : l(L), r(R), val(Val) {}
    };
    std::set<Node> s;                             // 有序集合存储所有区间节点，自动按左端点排序
    using IT = typename std::set<Node>::iterator; // 使用using代替#define

public:
    ODT()
    {
        // 初始化时插入一个虚拟节点作为哨兵（防止越界）
        // 哨兵节点的右边界设为极大值，确保所有合法区间都在其左侧
        s.insert(Node(0, inf, 0)); // 假设数据范围为 0~1e9，可根据实际需求调整
    }

    IT split(int pos)
    {
        /*
         * 功能：将区间在 pos 处分裂为 [l, pos-1] 和 [pos, r] 两段
         * 返回值：后半段 [pos, r] 的迭代器
         * 原理：利用 set 的有序性找到第一个左端点 >= pos 的节点，
         *       若该节点左端点等于 pos，说明已存在分裂点，直接返回；
         *       否则分裂前一个节点，生成两个新区间
         */
        IT it = s.lower_bound(Node(pos)); // 找到第一个左端点 >= pos 的节点
        if (it != s.end() && it->l == pos)
        {
            // 若存在左端点为 pos 的节点，直接返回（已分裂过）
            return it;
        }
        // 否则需要分裂前一个节点
        it--;                     // 移动到前一个节点（该节点的 l < pos <= r）
        int L = it->l, R = it->r; // 原节点的左右边界
        T Val = it->val;          // 原节点的值
        s.erase(it);              // 删除原节点
        // 插入左半段 [L, pos-1]
        s.insert(Node(L, pos - 1, Val));
        // 插入右半段 [pos, R] 并返回其迭代器
        return s.insert(Node(pos, R, Val)).first;
    }

    void assign(int l, int r, T val)
    {
        /*
         * 功能：将区间 [l, r] 内的所有值覆盖为 val
         * 步骤：
         * 1. 分裂右端点 r+1，得到后半段迭代器 itr
         * 2. 分裂左端点 l，得到前半段迭代器 itl
         * 3. 删除 [itl, itr) 区间内的所有节点（即原 [l, r] 区间的所有分段）
         * 4. 插入新节点 [l, r, val] 表示覆盖后的区间
         */
        IT itr = split(r + 1);     // 分裂出 [r+1, ...]
        IT itl = split(l);         // 分裂出 [l, ...]
        s.erase(itl, itr);         // 删除 [l, r] 区间内的所有旧分段
        s.insert(Node(l, r, val)); // 插入新的覆盖区间
    }

    void add(int l, int r, T val)
    {
        /*
         * 功能：将区间 [l, r] 内的所有值增加 val
         * 步骤：
         * 1. 分裂区间两端点，确保 [l, r] 是若干连续节点的集合
         * 2. 遍历 [itl, itr) 区间内的所有节点，逐个增加 val
         */
        IT itr = split(r + 1); // 分裂右端点
        IT itl = split(l);     // 分裂左端点
        for (; itl != itr; ++itl)
        {
            itl->val += val; // 对每个节点的值进行加法操作
        }
    }

    T kth(int l, int r, int k)
    {
        /*
         * 功能：查询区间 [l, r] 内的第 k 小值（k 从 1 开始）
         * 步骤：
         * 1. 分裂区间两端点，获取所有包含在 [l, r] 内的节点
         * 2. 收集这些节点的值和长度，按值排序
         * 3. 遍历排序后的节点，累加长度直到找到第 k 小值
         */
        std::vector<std::pair<T, int>> vp; // 存储（值，区间长度）
        IT itr = split(r + 1);             // 分裂右端点
        IT itl = split(l);                 // 分裂左端点
        for (; itl != itr; ++itl)
        {
            vp.push_back({itl->val, itl->r - itl->l + 1});
        }
        std::sort(vp.begin(), vp.end()); // 按值从小到大排序
        for (auto [val, len] : vp)
        {
            k -= len; // 扣除当前区间的长度
            if (k <= 0)
            { // 找到第 k 小值
                return val;
            }
        }
        return -1; // 若未找到（理论上不应发生）
    }

    T RangeQuery(int l, int r)
    {
        /*
         * 功能：查询区间 [l, r] 内所有值的和
         * 步骤：
         * 1. 分裂区间两端点，获取所有包含在 [l, r] 内的节点
         * 2. 遍历节点，计算每个节点的区间长度 × 值，累加求和
         */
        IT itr = split(r + 1); // 分裂右端点
        IT itl = split(l);     // 分裂左端点
        T res = 0;
        for (; itl != itr; ++itl)
        {
            res += (itl->r - itl->l + 1) * itl->val; // 区间长度 × 值
        }
        return res;
    }
};

```

#### 单调栈
通过维护一个单调的栈来求出左边/右边第一个大于/小于我的位置

```cpp
template <class T>
struct stack
{
    int n;
    int tt;
    std::vector<T> l, r, L, R; // 左边第一个大于 右边第一个 大于 左边第一个大于等于 右边第一个大于等于
    std::vector<int> q;
    stack(const std::vector<T> &a) : n(a.size()), l(n), r(n), L(n), R(n), q(n)
    {

        l.assign(n, 0);
        L.assign(n, 0);
        r.assign(n, n); // 这里的n就是n+1
        R.assign(n, n);
        q.assign(n, 0);
        tt = 0;
        for (int i = 1; i <= n - 1; ++i)
        {
            while (tt && a[q[tt]] <= a[i])
            {
                R[q[tt]] = i;
                tt--;
            }
            l[i] = q[tt];
            q[++tt] = i;
        }
        q.assign(n, 0);
        tt = 0;
        for (int i = 1; i <= n - 1; ++i)
        {
            while (tt && a[q[tt]] < a[i])
            {
                r[q[tt]] = i;
                tt--;
            }
            L[i] = q[tt];
            q[++tt] = i;
        }
    }
};
```

#### 笛卡尔树
笛卡尔树是把一个序列建立成一颗二叉搜索树，整棵树的中序遍为长度为![image](https://cdn.nlark.com/yuque/__latex/df378375e7693bdcf9535661c023c02e.svg)的顺序排列（即![image](https://cdn.nlark.com/yuque/__latex/eba12c090f7327b3086c52caa0dc429d.svg),同时满足堆的性质，以小根堆为例，也就是![image](https://cdn.nlark.com/yuque/__latex/d819c7b3f2143b409fed4dbc7bedfcaa.svg)

性质：笛卡尔树每个点的子树下标连续,同时子树的根是子树中值最小/最大的节点。

构建过程（小根堆笛卡尔树）：我们按元素的下标插入，设当前插入的下标为![image](https://cdn.nlark.com/yuque/__latex/2443fbcfeb7e85e1d62b6f5e4f27207e.svg),显然新插入的元素应该在树的最右边，那么我们用一个栈维护最右边的树链，通过不断弹出栈顶来从链底开始向上遍历直到找到一个![image](https://cdn.nlark.com/yuque/__latex/036441a335dd85c838f76d63a3db2363.svg)满足![image](https://cdn.nlark.com/yuque/__latex/8d306d131bed8365b2bf332a93081831.svg)，那么我们把![image](https://cdn.nlark.com/yuque/__latex/2443fbcfeb7e85e1d62b6f5e4f27207e.svg)置为![image](https://cdn.nlark.com/yuque/__latex/036441a335dd85c838f76d63a3db2363.svg)的右儿子，把链底到![image](https://cdn.nlark.com/yuque/__latex/036441a335dd85c838f76d63a3db2363.svg)通过栈弹出的这条链作为![image](https://cdn.nlark.com/yuque/__latex/2443fbcfeb7e85e1d62b6f5e4f27207e.svg)的左儿子。

显然该过程可以保证笛卡尔树的两个性质，由于每个点只会入栈一次和出栈一次，复杂度为![image](https://cdn.nlark.com/yuque/__latex/e65a67ac353abeeff44c359310d05c02.svg)

请注意:只有在权值两两不同时建出的笛卡尔树才唯一

```cpp
class DescartesTree
{
public:
    int n, root;
    std::vector<int> lc, rc;
    DescartesTree(std::vector<int> &a) : n(a.size) - 1, lc(n + 1), rc(n + 1)
    {
        root = std::min_element(begin(a) + 1, end(a)) - begin(a);
        std::vector<int> stk(n + 1, 0);
        int top = 0;
        for (int i = 1; i <= n; ++i)
        {
            int k = top;
            while (k and a[stk[k]] > a[i])
                --k;
            if (k)
                rc[stk[k]] = i;
            if (k < top)
                lc[i] = stk[k + 1];
            stk[++k] = i;
            top = k;
        }
    }
};
```

#### 二维前缀和
```cpp
template <class T>
struct TwoDimensionalPrefix
{
    std::vector<std::vector<T>> pre;
    TwoDimensionalPrefix(std::vector<std::vector<T>> &a, int n, int m)
    {
        pre.assign(n + 1, std::vector<int>(m + 1, 0));
        for (int i = 1; i <= n; ++i)
        {
            for (int j = 1; j <= m; ++j)
            {
                pre[i][j] = a[i][j] + pre[i - 1][j] + pre[i][j - 1] - pre[i - 1][j - 1];
            }
        }
    }
    T query(int x1, int y1, int x2, int y2) // 传入左上角和右下角的坐标
    {
        return pre[x2][y2] - pre[x1 - 1][y2] - pre[x2][y1 - 1] + pre[x1 - 1][y1 - 1];
    }
};
```

#### 动态Bitset
手写![image](https://cdn.nlark.com/yuque/__latex/759411de49355c93f91977786e8ef4a6.svg)

```cpp
using ull = unsigned long long;
using ll = long long;
class Bitset
{
private:
    int n;                       // 实际位数
    static constexpr int B = 64; // 每个块包含的位数

public:
    std::vector<unsigned long long> bits; // 存储位数据（改为private）
    Bitset(int n_) : n(n_), bits((n_ + B - 1) / B) {}
    Bitset() = default;
    void norm()
    {
        if (n <= 0 or bits.empty())
            return;
        if (n % B != 0)
            bits.back() &= getMask(n % B);
    }

    static constexpr unsigned long long getMask(int len)
    {
        return len >= 64 ? ~0ULL : ((1ULL << len) - 1);
    }
    void init(int n_)
    {
        n = n_;
        bits.assign((n_ + B - 1) / B, 0);
    }

    Bitset &set(int pos)
    {
        bits[pos / B] |= 1ULL << (pos % B);
        return *this;
    }

    Bitset &set()
    {
        std::fill(bits.begin(), bits.end(), ~0ULL);
        norm();
        return *this;
    }

    Bitset &reset(int pos)
    {
        bits[pos / B] &= ~(1ULL << (pos % B));
        return *this;
    }

    Bitset &reset()
    {
        std::fill(bits.begin(), bits.end(), 0ULL);
        return *this;
    }

    Bitset &flip(int pos)
    {
        bits[pos / B] ^= 1ULL << (pos % B);
        return *this;
    }

    Bitset &flip()
    {
        for (auto &x : bits)
            x = ~x;
        norm();
        return *this;
    }

    Bitset &flip(int l, int r)
    {
        assert(0 <= l && l <= r && r < n);
        int lb = l / B, rb = r / B;
        if (lb == rb)
        {
            int shift = l % B, len = r - l + 1;
            bits[lb] ^= getMask(len) << shift;
        }
        else
        {
            bits[lb] ^= (~0ULL << (l % B));
            for (int i = lb + 1; i < rb; ++i)
                bits[i] ^= ~0ULL;
            bits[rb] ^= getMask((r % B) + 1);
        }
        return *this;
    }

    bool test(int pos) const
    {
        return (bits[pos / B] >> (pos % B)) & 1;
    }

    bool operator[](int pos) const
    {
        return test(pos);
    }

    int count() const
    {
        int res = 0;
        for (auto x : bits)
            res += __builtin_popcountll(x);
        return res;
    }

    bool any() const
    {
        for (auto x : bits)
            if (x)
                return true;
        return false;
    }

    bool none() const
    {
        return !any();
    }

    int size() const
    {
        return n;
    }

    std::string to_string() const
    {
        std::string res(n, '0');
        for (int i = 0; i < n; ++i)
        {
            if (test(n - 1 - i))
                res[i] = '1';
        }
        return res;
    }

    int find_first() const
    {
        for (int i = 0; i < (int)bits.size(); ++i)
        {
            if (bits[i])
                return i * B + __builtin_ctzll(bits[i]);
        }
        return -1;
    }

    int find_next(int pos) const
    {
        ++pos;
        if (pos >= n)
            return -1;
        int i = pos / B, j = pos % B;
        unsigned long long rem = bits[i] >> j;
        if (rem)
            return i * B + j + __builtin_ctzll(rem);
        for (int k = i + 1; k < (int)bits.size(); ++k)
        {
            if (bits[k])
                return k * B + __builtin_ctzll(bits[k]);
        }
        return -1;
    }

    Bitset &operator&=(const Bitset &rhs)
    {
        for (int i = 0; i < (int)bits.size(); ++i)
            bits[i] &= rhs.bits[i];
        return *this;
    }

    Bitset &operator|=(const Bitset &rhs)
    {
        for (int i = 0; i < (int)bits.size(); ++i)
            bits[i] |= rhs.bits[i];
        return *this;
    }

    Bitset &operator^=(const Bitset &rhs)
    {
        for (int i = 0; i < (int)bits.size(); ++i)
            bits[i] ^= rhs.bits[i];
        norm();
        return *this;
    }
    friend Bitset operator&(Bitset lhs, const Bitset &rhs)
    {
        lhs &= rhs;
        return lhs;
    }

    friend Bitset operator|(Bitset lhs, const Bitset &rhs)
    {
        lhs |= rhs;
        return lhs;
    }

    friend Bitset operator^(Bitset lhs, const Bitset &rhs)
    {
        lhs ^= rhs;
        return lhs;
    }
    void resize(int new_n)
    {
        int new_blocks = (new_n + B - 1) / B;
        bits.resize(new_blocks, 0ULL);
        n = new_n;
        norm();
    }

    Bitset &operator<<=(int shift)
    {
        if (shift <= 0)
            return *this;
        int x = shift / B, y = shift % B;
        if (x >= (int)bits.size())
        {
            reset();
            return *this;
        }
        if (y == 0)
        {
            for (int i = bits.size() - 1; i >= x; --i)
                bits[i] = bits[i - x];
            std::fill(bits.begin(), bits.begin() + x, 0ULL);
        }
        else
        {
            for (int i = bits.size() - 1; i > x; --i)
                bits[i] = (bits[i - x] << y) | (bits[i - x - 1] >> (B - y));
            bits[x] = bits[0] << y;
            std::fill(bits.begin(), bits.begin() + x, 0ULL);
        }
        norm();
        return *this;
    }

    Bitset &operator>>=(int shift)
    {
        if (shift <= 0)
            return *this;
        int x = shift / B, y = shift % B;
        if (x >= (int)bits.size())
        {
            reset();
            return *this;
        }
        if (y == 0)
        {
            for (int i = 0; i + x < (int)bits.size(); ++i)
                bits[i] = bits[i + x];
            std::fill(bits.begin() + (bits.size() - x), bits.end(), 0ULL);
        }
        else
        {
            for (int i = 0; i + x + 1 < (int)bits.size(); ++i)
                bits[i] = (bits[i + x] >> y) | (bits[i + x + 1] << (B - y));
            if (x < (int)bits.size())
                bits[bits.size() - 1 - x] = bits[bits.size() - 1] >> y;
            for (int i = bits.size() - x; i < (int)bits.size(); ++i)
                bits[i] = 0ULL;
        }
        norm();
        return *this;
    }

    friend Bitset operator<<(Bitset lhs, int shift)
    {
        lhs <<= shift;
        return lhs;
    }

    friend Bitset operator>>(Bitset lhs, int shift)
    {
        lhs >>= shift;
        return lhs;
    }

    Bitset(const Bitset &other) : n(other.n), bits(other.bits) {}

    Bitset &operator=(const Bitset &other)
    {
        if (this != &other)
        {
            n = other.n;
            bits = other.bits;
        }
        return *this;
    }

    Bitset(Bitset &&other) noexcept : n(other.n), bits(std::move(other.bits))
    {
        other.n = 0;
    }

    Bitset &operator=(Bitset &&other) noexcept
    {
        if (this != &other)
        {
            n = other.n;
            bits = std::move(other.bits);
            other.n = 0;
        }
        return *this;
    }
};
```

递归实现（码量小 推荐）

```cpp
#include <bits/stdc++.h>

using i64 = long long;

constexpr int N = 5e5 + 1;

template <int SIZE>
void solve(int n)
{
    if (SIZE < n)
    {
        solve<std::min(SIZE * 2, N)>(n);
        return;
    }
}

int main()
{
    int n;
    std::cin >> n;
    solve<1>(n);
}
```

#### set维护不交区间
如果认为区间![image](https://cdn.nlark.com/yuque/__latex/5bef1d2559a9a09eb7b5214f8ea6ad64.svg)和区间![image](https://cdn.nlark.com/yuque/__latex/be2ee7fdf410b03992555ec65e6b95a1.svg)不相邻的话 我们把所有坐标乘![image](https://cdn.nlark.com/yuque/__latex/2b89979f54ec02a7bf87aa0c1ea58ff9.svg)最后除![image](https://cdn.nlark.com/yuque/__latex/2b89979f54ec02a7bf87aa0c1ea58ff9.svg)即可。

```cpp
struct DIU
{
    using Node = std::array<int, 2>;

    // 用静态 lambda 作为比较器
    inline static auto cmp = [](const Node &a, const Node &b)
    {
        return a[1] < b[0];
    };

    std::set<Node, decltype(cmp)> st{cmp}; // 在类内直接初始化

    void add(int l, int r) // 插入[l,r]且保证一开始没有[l,r]
    {
        st.insert({l, r});
    }
    void insert(int l, int r) // 区间覆盖
    {
        auto it = st.find({l, l});
        if (it != st.end())
        {
            auto [L, R] = *it;
            st.erase(it);
            l = std::min(l, L);
            r = std::max(r, R);
        }
        it = st.find({r, r});
        if (it != st.end())
        {
            auto [L, R] = *it;
            st.erase(it);
            l = std::min(l, L);
            r = std::max(r, R);
        }
        // 合并前面和后面

        it = st.lower_bound({l, l});
        while (it != st.end())
        {
            auto [L, R] = *it;
            if (L > r)
            {
                break;
            }
            ++it;
            st.erase(std::prev(it));
        }
        // 删中间

        it = st.find({l - 1, l - 1});
        if (it != st.end())
        {
            auto [L, R] = *it;
            l = L;
            st.erase(it);
        }
        it = st.find({r + 1, r + 1});
        if (it != st.end())
        {
            auto [L, R] = *it;
            r = R;
            st.erase(it);
        }
        // 合并前面和后面

        st.insert({l, r});
    }

    void erase(int l, int r) // 区间删除[l,r]
    {
        auto it = st.find({l, l}); // 看l是不是0
        if (it != st.end())
        {
            auto [L, R] = *it;
            st.erase(it);
            if (L <= l - 1)
            {
                st.insert({L, l - 1});
            }
            if (R > r)
            {
                st.insert({r + 1, R});
            }
        }
        // 删掉开头

        it = st.lower_bound({l, l});
        while (it != st.end())
        {
            auto [L, R] = *it;
            if (L > r)
            {
                break;
            }
            ++it;
            st.erase(std::prev(it));
            if (R > r)
            {
                st.insert({r + 1, R});
            }
        }
        // 顺着删知道删完
    }

    // 分裂区间
    void split()
    {
    }
    // 合并区间
    void merge()
    {
    }
};

```


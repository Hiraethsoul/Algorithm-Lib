##  一些概念
基图：即把有向图中的有向边改为无向边得到的图称作基图

弱连通：对于有向图中两点![image](https://cdn.nlark.com/yuque/__latex/838c98c94a4322ee88230f6f92e2ac73.svg)，如果我们转化为基图后![image](https://cdn.nlark.com/yuque/__latex/838c98c94a4322ee88230f6f92e2ac73.svg)联通,那么称![image](https://cdn.nlark.com/yuque/__latex/838c98c94a4322ee88230f6f92e2ac73.svg)弱联通

完全图:任意两点间都有一条无向边的图称作完全图，![image](https://cdn.nlark.com/yuque/__latex/df378375e7693bdcf9535661c023c02e.svg)个点的完全图记作![image](https://cdn.nlark.com/yuque/__latex/150d408c21f2566620d01dbe4ab803f4.svg)

子图：对于一个图![image](https://cdn.nlark.com/yuque/__latex/92232bff4c7103ad09227936b16c6ce8.svg)，如果另一个图![image](https://cdn.nlark.com/yuque/__latex/93007824d6d94eae4fc3c12a43ecd7a4.svg)满足![image](https://cdn.nlark.com/yuque/__latex/467a2f54372f7ecf089d3a9f0dbe1df5.svg)且![image](https://cdn.nlark.com/yuque/__latex/1e280e7010b5095e23f094054f87a116.svg)则![image](https://cdn.nlark.com/yuque/__latex/a15e5e56fb190d4b9b12b0d7e50c0995.svg)称作![image](https://cdn.nlark.com/yuque/__latex/bf5a6fee97def1f1319baa14f3a40806.svg)的子图

导出子图:选定一个点集![image](https://cdn.nlark.com/yuque/__latex/9f493997c33913987175caf4a4849955.svg)，再加上两端都在![image](https://cdn.nlark.com/yuque/__latex/8fae9a91d8214e0e28876e48f155ad0c.svg)中的边，即为点集![image](https://cdn.nlark.com/yuque/__latex/8fae9a91d8214e0e28876e48f155ad0c.svg)的导出子图

平面图:将所有点和边铺在平面上，可以满足每条边之间两两不相交的图称作平面图，对于平面图![image](https://cdn.nlark.com/yuque/__latex/92232bff4c7103ad09227936b16c6ce8.svg)满足![image](https://cdn.nlark.com/yuque/__latex/da42bbff20c1f9cf42f4281ad31a947c.svg) 且根据欧拉公式，平面图满足![image](https://cdn.nlark.com/yuque/__latex/33615dc7dda8eb7d7e09ffe2b90bd2ef.svg)其中![image](https://cdn.nlark.com/yuque/__latex/098c42693c059aa0c7f680f02d2bd670.svg)是面的个数,![image](https://cdn.nlark.com/yuque/__latex/44f7dc40bf2619f2414884760f8cd0ff.svg)是图连通块的个数

## 树上问题：
### 树的重心
我们不妨设树的大小为![image](https://cdn.nlark.com/yuque/__latex/df378375e7693bdcf9535661c023c02e.svg)

树的重心定义为，当树以重心为根时，每个子树的大小不超出![image](https://cdn.nlark.com/yuque/__latex/fa7bcd294cefd4f4fc0363c5eac966e3.svg)。

性质：一棵树最多只能有两个重心。

求重心的方法：

在我们求出以任意一点为根的子树大小后，我们从根开始![image](https://cdn.nlark.com/yuque/__latex/3554585ecb04a4bf73b5938d239b0fe5.svg)。如果某个点的所有儿子的子树大小都![image](https://cdn.nlark.com/yuque/__latex/a533d66320f61308427177a75d303b2c.svg)，那么该点为重心，直接返回。否则我们递归子树大小超过![image](https://cdn.nlark.com/yuque/__latex/fa7bcd294cefd4f4fc0363c5eac966e3.svg)的儿子即可（显然只有一个）。

```cpp
struct TreeCentroid
{
    int n;
    std::vector<std::vector<std::pair<int, int>>> g; // 邻接表
    std::vector<int> siz;                            // 子树大小

    TreeCentroid(int n) : n(n), g(n + 1), siz(n + 1) {}

    void addEdge(int u, int v, int w)
    {
        g[u].emplace_back(v, w);
        g[v].emplace_back(u, w);
    }

    void dfsSize(int u, int fa)
    {
        siz[u] = 1;
        for (const auto &[v, w] : g[u])
        {
            if (v != fa)
            {
                dfsSize(v, u);
                siz[u] += siz[v];
            }
        }
    }

    int findCentroid(int u)
    {
        dfsSize(u, 0);
        return getRoot(u, 0, siz[u]);
    }

private:
    int getRoot(int u, int fa, int total_size)
    {
        for (const auto &[v, w] : g[u])
        {
            if (v != fa && 2 * siz[v] > total_size)
            {
                return getRoot(v, u, total_size);
            }
        }
        return u;
    }
};
```

### 树的直径
直径求法：

我们通过二次![image](https://cdn.nlark.com/yuque/__latex/40e0b9f3427d7c821289b81883ff5776.svg)解决直径问题，也就是说我们先以任意点为根，找到最深的点，再次从最深的点开始二次![image](https://cdn.nlark.com/yuque/__latex/b8100f4f2280a1a3172a3a0dc8425bb3.svg),得到最大深度即直径。正确性显然.

```cpp

template <class T>
struct TreeDiameter
{
    int n;
    std::vector<std::vector<std::pair<int, int>>> g; // 邻接表（无向图）
    std::vector<int> fa;                             // 父节点记录（用于路径回溯）

    TreeDiameter(int n) : n(n), g(n + 1), fa(n + 1) {}

    // 添加无向边 u-v
    void addEdge(int u, int v, int w)
    {
        g[u].emplace_back(v, w);
        g[v].emplace_back(u, w);
    }

    // BFS 求最远节点（返回节点编号）
    std::pair<int, T> bfs(int start)
    {
        std::vector<T> dep(n + 1, -1);
        std::queue<int> q;
        q.push(start);
        dep[start] = 0;
        fa[start] = -1;

        while (!q.empty())
        {
            int u = q.front();
            q.pop();
            for (auto [v, w] : g[u])
            {
                if (dep[v] == -1)
                {
                    dep[v] = dep[u] + w;
                    fa[v] = u;
                    q.push(v);
                }
            }
        }
        int maxPos = std::max_element(dep.begin(), dep.end()) - dep.begin();
        return std::make_pair(maxPos, dep[maxPos]);
    }

    // 求树的直径（返回直径长度和端点 {u, v}）
    std::pair<T, std::pair<int, int>> getDiameter()
    {
        auto [x, dis1] = bfs(1); // 第一次BFS
        auto [y, dis2] = bfs(x); // 第二次BFS
        return {dis2, {x, y}};
    }
};
```

直径的性质

![image](https://cdn.nlark.com/yuque/__latex/0eb30e845f1370ce04407adc80e2b3ac.svg)树上任意一点，离它最远的一点必然是直径两端点之一

![image](https://cdn.nlark.com/yuque/__latex/ba4c3f97371ffa47698bd1290a56dda1.svg)两个联通块合并，新联通块的直径两端点一定是原先的四个直径端点中的其中两个

![image](https://cdn.nlark.com/yuque/__latex/d2740f66b368443ea5c0fe97baef35f5.svg)我们可以扩展![image](https://cdn.nlark.com/yuque/__latex/2b89979f54ec02a7bf87aa0c1ea58ff9.svg)中的结论，我们将直径的定义扩展为点权+边权的情况下仍然成立

![image](https://cdn.nlark.com/yuque/__latex/29163297c5061d9c3003a867913d3444.svg)一棵树可以拥有多条直径，其所有直径共用一个中点，中点有可能在边上

### 树链求交
我们对于一棵树的两条链![image](https://cdn.nlark.com/yuque/__latex/838c98c94a4322ee88230f6f92e2ac73.svg)和![image](https://cdn.nlark.com/yuque/__latex/a969cab25db24b7b40ddd3064d3ab658.svg)，我们考虑求出它们的交链端点



首先可以证明的是 最终交链的端点只可能在集合![image](https://cdn.nlark.com/yuque/__latex/55fc237afbe535f7d8434985b848a6a7.svg)中，其中![image](https://cdn.nlark.com/yuque/__latex/55fc237afbe535f7d8434985b848a6a7.svg)是四个点任选两个点求![image](https://cdn.nlark.com/yuque/__latex/a5f1a3b1ccbcb20d75ccf0efa8b7bb12.svg)以后的点，显然这样的点最多只有![image](https://cdn.nlark.com/yuque/__latex/d41a7a5e223768165613c07299d3e16a.svg)个，我们可以通过求距离的方法判断每个点是否在链上，那么同时在![image](https://cdn.nlark.com/yuque/__latex/838c98c94a4322ee88230f6f92e2ac73.svg)和![image](https://cdn.nlark.com/yuque/__latex/a969cab25db24b7b40ddd3064d3ab658.svg)上的点可以成为候选点，若候选点个数![image](https://cdn.nlark.com/yuque/__latex/86a2c1ed2220cb13d90100430dd59e14.svg),那么树链完全无交，若候选点个数![image](https://cdn.nlark.com/yuque/__latex/548cf77809eeb91ee73cae4848fda6a8.svg)，那么该候选点为唯一交点，若![image](https://cdn.nlark.com/yuque/__latex/0e89aed9c3fe21ad62da8c0b713c10b6.svg)，那么取这些点的直径即可。如果精细实现![image](https://cdn.nlark.com/yuque/__latex/a5f1a3b1ccbcb20d75ccf0efa8b7bb12.svg)的话可以做到常数时间复杂度

```cpp
bool cmp(int a, int b) { return dep[a] < dep[b]; }
path merge(path u, path v)
{
    int d[4], c[2];
    if (!u.x || !v.x)
        return path(0, 0);
    d[0] = lca(u.x, v.x);
    d[1] = lca(u.x, v.y);
    d[2] = lca(u.y, v.x);
    d[3] = lca(u.y, v.y);
    c[0] = lca(u.x, u.y);
    c[1] = lca(v.x, v.y);
    sort(d, d + 4, cmp);
    sort(c, c + 2, cmp);
    if (dep[c[0]] <= dep[d[0]] && dep[c[1]] <= dep[d[2]])
        return path(d[2], d[3]);
    else
        return path(0, 0);
}
```

### 重链剖分
<font style="color:rgba(0, 0, 0, 0.87);">重链剖分可以将树上的任意一条路径划分成不超过</font>![image](https://cdn.nlark.com/yuque/__latex/1b0fce2bd1f5925667628ba7a81a4635.svg)<font style="color:rgba(0, 0, 0, 0.87);">条连续的链，每条链上的点深度互不相同。同时会给树的点重新编号为</font>![image](https://cdn.nlark.com/yuque/__latex/65a3fe4bfdefd5ee1936a2f0c526111a.svg)<font style="color:rgba(0, 0, 0, 0.87);">序。</font>

![image](https://cdn.nlark.com/yuque/__latex/65a3fe4bfdefd5ee1936a2f0c526111a.svg)<font style="color:rgba(0, 0, 0, 0.87);">序的定义:按先遍历重儿子的顺序得到的</font>![image](https://cdn.nlark.com/yuque/__latex/3554585ecb04a4bf73b5938d239b0fe5.svg)<font style="color:rgba(0, 0, 0, 0.87);">序。</font>

<font style="color:rgba(0, 0, 0, 0.87);"></font>

<font style="color:rgba(0, 0, 0, 0.87);">重链剖分的性质:</font>

<font style="color:rgba(0, 0, 0, 0.87);"></font>

<font style="color:rgba(0, 0, 0, 0.87);">1：每条重链上的</font>![image](https://cdn.nlark.com/yuque/__latex/65a3fe4bfdefd5ee1936a2f0c526111a.svg)<font style="color:rgba(0, 0, 0, 0.87);">序连续。</font>

<font style="color:rgba(0, 0, 0, 0.87);">2：每个点子树内的</font>![image](https://cdn.nlark.com/yuque/__latex/65a3fe4bfdefd5ee1936a2f0c526111a.svg)<font style="color:rgba(0, 0, 0, 0.87);">序连续，节点</font>![image](https://cdn.nlark.com/yuque/__latex/77c3adce895348f6083c425fe1ba2624.svg)<font style="color:rgba(0, 0, 0, 0.87);">子树内的</font>![image](https://cdn.nlark.com/yuque/__latex/65a3fe4bfdefd5ee1936a2f0c526111a.svg)<font style="color:rgba(0, 0, 0, 0.87);">序范围是</font>![image](https://cdn.nlark.com/yuque/__latex/6437a9cafad4ca56400ec617f44658fd.svg)

3：每个点到根节点的路径上，最多只会有![image](https://cdn.nlark.com/yuque/__latex/1b0fce2bd1f5925667628ba7a81a4635.svg)个轻儿子。

4：每条路径能被划分为最多![image](https://cdn.nlark.com/yuque/__latex/1b0fce2bd1f5925667628ba7a81a4635.svg)条重链。

关于第三个和第四个性质的证明:

<font style="color:rgb(64, 64, 64);">每次经过轻儿子，子树大小至少会减半</font><font style="color:rgb(64, 64, 64);">，因此最多下降 </font>![image](https://cdn.nlark.com/yuque/__latex/1b0fce2bd1f5925667628ba7a81a4635.svg)<font style="color:rgb(64, 64, 64);">次。</font><font style="color:rgb(64, 64, 64);">。</font>

```cpp
template <class T>
class TreePre
{

private:
    int n;
    int idx = 0;
    int root;
    std::vector<std::vector<std::pair<int, int>>> &g;
    void dfs1(int u, int f)
    {
        fa[u] = f;
        siz[u] = 1;
        for (auto [v, w] : g[u])
        {
            if (v != f)
            {
                dep[v] = dep[u] + 1;
                dis[v] = dis[u] + w;
                dfs1(v, u);
                siz[u] += siz[v];
                if (siz[son[u]] < siz[v])
                {
                    son[u] = v;
                }
            }
        }
    }
    void dfs2(int u, int tp)
    {
        dfn[u] = ++idx;
        idfn[idx] = u;
        top[u] = tp;
        if (son[u])
        {
            dfs2(son[u], tp);
        }
        for (auto [v, w] : g[u])
        {
            if (v != fa[u] and v != son[u])
            {
                dfs2(v, v);
            }
        }
    }

public:
    TreePre(std::vector<std::vector<std::pair<int, int>>> &g, int root)
        : g(g), n(g.size() - 1), root(root), dep(n + 1), top(n + 1), son(n + 1), fa(n + 1), siz(n + 1), dfn(n + 1), idfn(n + 1), dis(n + 1)
    {
        dep[root] = 1;
        dis[root] = 0;
        dfs1(root, 0);
        dfs2(root, root);
    }
    std::vector<int> dfn, idfn, siz, fa, dep, top, son;
    std::vector<T> dis;
    int kthAncester(int u, int k) // k级祖先
    {
        if (dep[u] <= k)
        {
            return -1;
        }
        int d = dep[u] - k;
        while (dep[top[u]] > d)
        {
            u = fa[top[u]];
        }
        return idfn[dfn[u] - dep[u] + d];
    }
    int getLca(int u, int v) // u和v在指定根下的lca
    {
        while (top[u] != top[v])
        {
            if (dep[top[u]] > dep[top[v]])
            {
                u = fa[top[u]];
            }
            else
            {
                v = fa[top[v]];
            }
        }
        return dep[u] < dep[v] ? u : v;
    }
    T getDistance(int u, int v) // u和v之间的距离
    {
        return dis[u] + dis[v] - 2 * dis[getLca(u, v)];
    }
    bool isAncester(int u, int v) // u是不是v的祖先
    {
        return dfn[u] <= dfn[v] and dfn[u] + siz[u] - 1 >= dfn[v];
    }

    auto getRoad(int u, int v) // 得到uv之间路径的dfn序
    {
        std::vector<std::pair<int, int>> res;
        while (top[u] != top[v])
        {
            if (dep[top[u]] < dep[top[v]])
            {
                std::swap(u, v);
            }
            res.push_back({dfn[top[u]], dfn[u]});
            u = fa[top[u]];
        }
        if (dep[u] > dep[v])
        {
            std::swap(u, v);
        }
        res.push_back({dfn[u], dfn[v]});
        return res;
    }

    int rootedFather(int u, int root) // u在root为根的情况下的父节点
    {
        if (!isAncester(u, root)) // u不是root的祖先 那么父节点不变
        {
            return fa[u];
        }
        auto it = std::upper_bound(g[u].begin(), g[u].end(), root, [&](int x, int y)
                                   { return dfn[x] < dfn[y]; });
        --it;
        return *it;
        // 把u的邻点按dfn序排序后 dfn最大且  dfn[u]<=dfn[root]的点
    }

    int rootedSize(int u, int root) // root为根的情况下u的子树大小
    {
        if (root == u)
        {
            return n;
        }
        if (!isAncester(u, root)) // u不是根的祖先
        {
            return siz[u];
        }
        return n - siz[rootedFather(u, root)];
    }
    int rootedLca(int root, int u, int v)
    {
        return getLca(u, v) ^ getLca(u, root) ^ getLca(v, root);
    }
};
```

### 点分治
点分治的思想是统计经过根的路径的贡献，对于不经过根的路径，我们分治下去直至每个点都做为根被统计贡献。在这样的情况下，不断选择树的重心分治是最优的选择，可以证明在该条件下访问点的数量为![image](https://cdn.nlark.com/yuque/__latex/4fdce66a3ca18398b05c1efc03c7aa4f.svg)级别的。也就是说，我们通过一种特殊的遍历顺序得到了所有路径的信息。

特别的，如果我们存下来点分治过程中经过的节点，我们称作点分治序，每个点对应的可结合的点的点分治序都是一个连续的区间。



在以每个点为根统计答案时，我们考虑两种不同的方法进行求解。

不妨设当前根为![image](https://cdn.nlark.com/yuque/__latex/77c3adce895348f6083c425fe1ba2624.svg),

![image](https://cdn.nlark.com/yuque/__latex/53072c2388d69edc65c2377681e4e87c.svg)对于![image](https://cdn.nlark.com/yuque/__latex/77c3adce895348f6083c425fe1ba2624.svg)的每一颗子树，我们挨个遍历并且和之前遍历到的子树信息进行结合统计答案。在遍历完一颗子树后要加入该子树的信息。在遍历完所有子树后，要清空信息。这样的方法能保证在统计时就不重不漏。请注意清空信息！

![image](https://cdn.nlark.com/yuque/__latex/2b89979f54ec02a7bf87aa0c1ea58ff9.svg)我们直接把所有![image](https://cdn.nlark.com/yuque/__latex/77c3adce895348f6083c425fe1ba2624.svg)的信息统计出来并计算答案，注意到这时候可能有单个子树之中的点结合，这部分是非法答案，我们考虑容斥减掉对应的贡献。具体的说，考虑一个函数![image](https://cdn.nlark.com/yuque/__latex/58ba269d451c840840a314916884c803.svg)表示以![image](https://cdn.nlark.com/yuque/__latex/b6a68bffd59def8247ed510be1f253a4.svg)为根，当前权值为![image](https://cdn.nlark.com/yuque/__latex/8597b8ad64ac82614635dd0459956516.svg)的贡献，我们要加上![image](https://cdn.nlark.com/yuque/__latex/4fa621f4a6002fc708dcd41c42b3309a.svg)，减去所有的![image](https://cdn.nlark.com/yuque/__latex/b7a888f67bc251d010fe71da6e0d1950.svg)

```cpp
struct PointerDivide
{
    std::vector<std::vector<std::pair<int, int>>> &g;
    std::vector<int> siz, dfn, vis;
    std::vector<std::vector<int>> pdt;
    int root;

    void dfsSize(int u, int fa)
    {
        siz[u] = 1;
        for (auto [v, w] : g[u])
        {
            if (v != fa and !vis[v])
            {
                dfsSize(v, u);
                siz[u] += siz[v];
            }
        }
    }
    int getRoot(int u, int fa, int Size)
    {
        for (auto [v, w] : g[u])
        {
            if (v != fa and !vis[v] and 2 * siz[v] > Size)
            {
                return getRoot(v, u, Size);
            }
        }
        return u;
    }
    void build(int u)
    {
        vis[u] = true;
        dfn.push_back(u);
        for (auto [v, w] : g[u])
        {
            if (!vis[v])
            {
                dfsSize(v, -1);
                v = getRoot(v, -1, siz[v]);
                // pdt[u].push_back(v);
                build(v);
            }
        }
    }
    PointerDivide(std::vector<std::vector<std::pair<int, int>>> &g) : g(g), siz(g.size()), vis(g.size())
    {
        dfsSize(1, 0);
        root = getRoot(1, 0, siz[1]);
        build(root);
    }
};

```

### 树上启发式合并
这是一个离线做法，本质就是对于每个节点都通过![image](https://cdn.nlark.com/yuque/__latex/ab9beef7db741e3cc3445e9070df572e.svg)求答案，但是通过保留重儿子的答案使复杂度降为优秀的![image](https://cdn.nlark.com/yuque/__latex/4fdce66a3ca18398b05c1efc03c7aa4f.svg)

具体做法是，对于以![image](https://cdn.nlark.com/yuque/__latex/77c3adce895348f6083c425fe1ba2624.svg)为根的子树，我们先递归其轻儿子，但是信息我们不做保留，注意这次![image](https://cdn.nlark.com/yuque/__latex/3554585ecb04a4bf73b5938d239b0fe5.svg)并不是在求轻儿子的对![image](https://cdn.nlark.com/yuque/__latex/77c3adce895348f6083c425fe1ba2624.svg)结点的答案，而是递归轻儿子求其自己的答案，递归结束后回到当前节点，我们再递归其重儿子，标记重儿子并且保留信息，然后我们开始统计该节点![image](https://cdn.nlark.com/yuque/__latex/77c3adce895348f6083c425fe1ba2624.svg)的答案，由于重儿子的信息被保留，我们只需要计算轻儿子的贡献即可，这里实际上加上了轻儿子的贡献，统计完后在此更新该节点的答案，如果该节点![image](https://cdn.nlark.com/yuque/__latex/0a25ff5d5f49aeb7283b1b06cf5b55d5.svg)不是其父节点的重儿子，还需要清除贡献,清除贡献前置重儿子为空，这样会把该节点轻重儿子的贡献全部删去，保证了正确性

```cpp

// 对于以u为根的子树
// 1先统计其轻儿树的答案 统计完后删除信息
// 2再统计其重子树的答案 统计完后保留信息
// 3将重子树的信息合并到u上
// 4再遍历u的轻子树 把轻子树的信息合并到u上
// 5判断u的信息是否需要传给父节点（如果u是其父节点的重儿子就需要传递信息）

// 以求子树颜色种类为例
template <class T>
struct DSUOnTree
{
    int n;
    std::vector<std::vector<std::pair<int, int>>> g; // 邻接表
    std::vector<int> siz, son;
    std::vector<T> ans; // 子树大小、重儿子,每个节点的答案
    int root;
    int heavyNode = 0;              // 当前处理的重儿子节点


    int typeCnt = 0;                // 颜色种类数量
    std::vector<int> col, colorCnt; // 原始颜色数组  颜色出现次数数组

    DSUOnTree(std::vector<std::vector<std::pair<int, int>>> &g, std::vector<int> &col, int root) : n(g.size() - 1), g(g), siz(n + 1), son(n + 1), ans(n + 1), root(root), col(col), colorCnt(n + 1, 0) {}
    // 预处理重儿子
    void preProcess(int u, int f)
    {
        siz[u] = 1;
        for (auto [v, w] : g[u])
        {
            if (v != f)
            {
                preProcess(v, u);
                siz[u] += siz[v];
                if (siz[son[u]] < siz[v])
                {
                    son[u] = v;
                }
            }
        }
    }

    // 添加/删除节点信息（需根据题目实现）
    void update(int u, int f, int val)
    {
        // 示例：统计子树颜色种类数
        if (val == 1)
        {
            colorCnt[col[u]]++;
            typeCnt += (colorCnt[col[u]] == 1);
        }
        else
        {
            colorCnt[col[u]]--;
            typeCnt -= (colorCnt[col[u]] == 0);
        }
    }

    // 遍历子树统计/清除信息
    void traverse(int u, int f, int val)
    {
        update(u, f, val);
        for (auto [v, w] : g[u])
        {
            if (v != f && v != heavyNode)
            {
                traverse(v, u, val);
            }
        }
    }

    // 主算法
    void solve(int u, int f, bool keep)
    {
        // 1. 先处理轻儿子（不保留信息）
        for (auto [v, w] : g[u])
        {
            if (v != f && v != son[u])
            {
                solve(v, u, false);
            }
        }

        // 2. 处理重儿子（保留信息）
        if (son[u])
        {
            solve(son[u], u, true);
            heavyNode = son[u];
        }

        // 3. 再次遍历轻儿子并合并信息
        for (auto [v, w] : g[u])
        {
            if (v != f && v != son[u])
            {
                traverse(v, u, 1);
            }
        }
        update(u, f, 1); // 添加当前节点信息
        // 4. 此处可保存当前节点的答案
        ans[u] = typeCnt;

        heavyNode = 0;

        // 5. 如果需要清除信息
        if (!keep)
        {
            traverse(u, f, -1);
            typeCnt = 0;
        }
    }
    // 对外接口
    void compute()
    {
        preProcess(root, 0); // 假设根节点是1
        solve(root, 0, true);
    }
};
```

### 基环树与基环树森林
基环树又名环套树，是![image](https://cdn.nlark.com/yuque/__latex/53bd15bd9229cd48a311be75b1a51db2.svg)个点![image](https://cdn.nlark.com/yuque/__latex/53bd15bd9229cd48a311be75b1a51db2.svg)条边的无向连通图，我们看待基环树的思路往往是环和树分开，这个思想是处理基环树的关键，也就是说，基环树实际上是一个环，且环上每个点都悬挂着一颗以该点为根的子树，如果我们破环成链，那么形状将是一条长链，链上每个节点都有一颗子树(可能为空)



我们往往对基环树问题有两种处理方法

![image](https://cdn.nlark.com/yuque/__latex/53072c2388d69edc65c2377681e4e87c.svg) 对于在基环树上贪心的问题，我们往往先在每棵小树上![image](https://cdn.nlark.com/yuque/__latex/3554585ecb04a4bf73b5938d239b0fe5.svg)合并信息到环上，然后再对环单独处理。

![image](https://cdn.nlark.com/yuque/__latex/2b89979f54ec02a7bf87aa0c1ea58ff9.svg)对于基环树一些性质的题目，以基环树直径为例，我们往往要破环成链，分类讨论。具体的说，我们任选环上某条边记为![image](https://cdn.nlark.com/yuque/__latex/838c98c94a4322ee88230f6f92e2ac73.svg),我们将其断开，那么剩下的结构将是一棵树，我们可以朴素的求出它的直径，这是不经过![image](https://cdn.nlark.com/yuque/__latex/838c98c94a4322ee88230f6f92e2ac73.svg)边的最大直径，然后我们考虑一定经过![image](https://cdn.nlark.com/yuque/__latex/838c98c94a4322ee88230f6f92e2ac73.svg)边的最大直径，我们不难发现，直径一定是破环后的链的一个前缀+一个后缀+该边拼凑而成，我们要先对每棵小树处理出它的最大深度![image](https://cdn.nlark.com/yuque/__latex/194d47626354143208e9eb2dd1785d70.svg)，那么![image](https://cdn.nlark.com/yuque/__latex/4cf3cfedf483a088b9b9035b002d5963.svg)，![image](https://cdn.nlark.com/yuque/__latex/e37455e37d86c4519ffbe5e69aab8b52.svg)是链左边端点到该点的长度，我们求出前后缀![image](https://cdn.nlark.com/yuque/__latex/e73a4bbeae47057f73628a1f8e32a605.svg)后，遍历取最大即可

#### 基环树
```cpp
struct RingTree
{
    std::vector<std::vector<std::pair<int, int>>> g; // 基环树上的小树
    std::vector<int> ring, ringVal;                  // 环,环的出点的权值
    // ringVal[i]对应的是 ring[i]和ring[i+1]的权值

    RingTree(std::vector<std::vector<std::pair<int, int>>> e) : g(e.size())
    {
        int n = e.size() - 1;
        std::vector<int> vis(n + 1, 0), deg(n + 1, 0);
        for (int u = 1; u <= n; ++u)
        {
            for (auto [v, w] : e[u])
            {
                deg[v]++;
            }
        }
        auto dfs1 = [&](auto dfs1, int u) -> void
        {
            vis[u] = 1;
            for (auto [v, w] : e[u])
            {
                if (!vis[v])
                {
                    // dsu.merge(u, v);
                    g[v].emplace_back(u, w);
                    deg[v]--;
                    if (deg[v] == 1)
                    {
                        dfs1(dfs1, v);
                    }
                }
            }
        };
        for (int i = 1; i <= n; ++i)
        {
            if (!vis[i] and deg[i] == 1) // 从叶子开始剥离树的结构
            {
                dfs1(dfs1, i);
            }
        }
        auto dfs2 = [&](auto dfs2, int u) -> void
        {
            ring.push_back(u);
            vis[u] = 1;
            for (auto [v, w] : e[u])
            {
                if (!vis[v])
                {
                    ringVal.push_back(w);
                    dfs2(dfs2, v);
                }
            }
        };
        for (int i = 1; i <= n; ++i)
        {
            if (!vis[i]) // 一定是环点
            {
                dfs2(dfs2, i); // 找到整个环
                for (auto [v, w] : e[ring.back()])
                {
                    if (v == ring.front())
                    {
                        ringVal.push_back(w); // 把环起点和终点的边权加入
                        break;
                    }
                }
            }
        }
    }
};
```

基环树森林是一个更特殊的情况，它往往比基环树更加常见，其题目往往有特征为每个点只有唯一的入点或唯一的出点，也就是说我们可以理解为，在树上它有唯一的父亲，那么如果我们连边![image](https://cdn.nlark.com/yuque/__latex/4716fb6a73f120872be92a83b9e6c4e9.svg)，将会得到一个基环树森林，基环树的处理手法和基环树如出一辙，无非就是对多棵树处理。



注意有些时候题目可能不是单纯的基环树森林，它可能是树森林和基环树森林的并集，需要分类讨论

#### 基环树森林
```cpp
struct RingTreeForest
{
    int cnt = 0;
    int n;
    std::vector<int> &fa; // 基环树的森林的出边/父边
    std::vector<int> onRing, root, ringLen, pos, posOnRing;
    // onRing[i]表示i是否在环上，root[i]表示i所在的树的根，ringLen存所有环的长度，pos[i]表示i点在哪个环上，posOnRing[i]表示i在环上的位置
    std::vector<std::vector<int>> ring, id;
    // ring[i]存环i的所有点，下标从0开始
    std::vector<std::vector<int>> g;
    RingTreeForest(std::vector<int> &b) : n(b.size()), fa(b), g(n), onRing(n, 0), root(n, 0), pos(n, 0), posOnRing(n, 0), ring(n)
    {
        std::vector<int> vis(n, 0);
        for (int u = 1; u <= n - 1; ++u)
        {
            int v = u;
            while (!vis[v] and v) // 防止跳到0
            {
                vis[v] = u;
                v = fa[v];
            }
            if (vis[v] == u and v) // 跳到的不是0于是成环
            {
                ++cnt;
                int k = v, cur = 0;
                do
                {
                    ring[cnt].push_back(k);
                    onRing[k] = 1;
                    pos[k] = cnt;
                    root[k] = k;
                    posOnRing[k] = cur++;
                    k = fa[k];
                } while (k != v);
                ringLen.push_back(cur);
                // update a new ring
            }
        }
        for (int i = 1; i <= n - 1; ++i)
        {
            if (!onRing[i] and fa[i]) // 不在环上且fa不为空
            {
                g[fa[i]].push_back(i);
            }
        }
    }
};
```

### 虚树
虚树是指我们在原本树的基础上抽离出一颗新的树，虚树只由关键点以及关键点的![image](https://cdn.nlark.com/yuque/__latex/858a6c9e508e3c03d8fe094829312fc8.svg)构成，在预处理一些信息以后我们可以在虚树上求解只涉及关键点的答案。复杂度由![image](https://cdn.nlark.com/yuque/__latex/e65a67ac353abeeff44c359310d05c02.svg)降为![image](https://cdn.nlark.com/yuque/__latex/7ada92f77c45d7ca414ff5e8bacc75df.svg)，其中![image](https://cdn.nlark.com/yuque/__latex/9f493997c33913987175caf4a4849955.svg)为关键点的数量。



构建方法：

因为多个点的![image](https://cdn.nlark.com/yuque/__latex/a5f1a3b1ccbcb20d75ccf0efa8b7bb12.svg)可能是同一个点，为了保证复杂度我们不能多次加入。

我们首先将关键点集合按![image](https://cdn.nlark.com/yuque/__latex/65a3fe4bfdefd5ee1936a2f0c526111a.svg)序排序，然后将相邻点的![image](https://cdn.nlark.com/yuque/__latex/577a57ac0bd9f4a9b7ca375d7565485a.svg)加入点集。

之后再次按![image](https://cdn.nlark.com/yuque/__latex/65a3fe4bfdefd5ee1936a2f0c526111a.svg)序排序并去重。然后把相邻的两个点![image](https://cdn.nlark.com/yuque/__latex/838c98c94a4322ee88230f6f92e2ac73.svg)连边![image](https://cdn.nlark.com/yuque/__latex/7eebf65bf9c0378669f180e22cf25510.svg)

```cpp
template <class T>
struct VirtualTreePre
{
    TreePre<T> pre;
    int root;
    std::vector<std::vector<std::pair<int, int>>> vt;
    VirtualTreePre(std::vector<std::vector<std::pair<int, int>>> &g, int root) : pre(g, root), root(root), vt(g.size()) {}

    void build(std::vector<int> a)
    {
        a.push_back(root);
        std::sort(begin(a), end(a), [&](int u, int v)
                  { return pre.dfn[u] < pre.dfn[v]; });
        for (int i = a.size() - 1; i; --i)
        {
            a.push_back(pre.getLca(a[i], a[i - 1]));
        }
        std::sort(begin(a), end(a), [&](int u, int v)
                  { return pre.dfn[u] < pre.dfn[v]; });
        a.erase(std::unique(begin(a), end(a)), end(a));
        for (auto u : a)
        {
            vt[u].clear();
        }
        for (int i = 1; i < a.size(); ++i)
        {
            int lca = pre.getLca(a[i], a[i - 1]);
            vt[lca].emplace_back(a[i], pre.dis[a[i]] - pre.dis[lca]);
        }
    }
};
```

### 树哈希
树哈希主要解决树的同构问题，即快速判断两颗树的结构是否相同

首先我们得有一个哈希函数![image](https://cdn.nlark.com/yuque/__latex/18f3c2855f0e85a1ac2257f64d917144.svg),树哈希想要不被卡关键在于哈希函数的设置不能是线性函数![image](https://cdn.nlark.com/yuque/__latex/75370d9ccc484987509db9254703f5bf.svg)，我们可以设置成![image](https://cdn.nlark.com/yuque/__latex/c9d9d1316bcd86a2429b47068b595bab.svg)，对于整棵树哈希值的计算，我们的公式是![image](https://cdn.nlark.com/yuque/__latex/96131c8160bc587bc09dd1a43853ab6f.svg)

有了这两个前置知识，我们分有根树和无根树来讨论

![image](https://cdn.nlark.com/yuque/__latex/53072c2388d69edc65c2377681e4e87c.svg)有根树，这种情况十分简单，我们从指定的根开始![image](https://cdn.nlark.com/yuque/__latex/3554585ecb04a4bf73b5938d239b0fe5.svg)，求出根节点的哈希值，如果两个根节点的哈希值相同，那么两颗有根树同构

![image](https://cdn.nlark.com/yuque/__latex/2b89979f54ec02a7bf87aa0c1ea58ff9.svg)无根树，对于无根树的同构，我们有两种方法。

其一是先求出树的一个或两个重心，以重心为根![image](https://cdn.nlark.com/yuque/__latex/3554585ecb04a4bf73b5938d239b0fe5.svg)求出哈希值，如果有两个重心就把两个哈希值异或起来，然后对比即可，需要注意的是，如果存在两个重心，就必须求两个重心为根的哈希值，否则会出错  
其二是求出以每个点为根的哈希值，然后异或起来得到最终哈希值，操作方法是朴素的换根![image](https://cdn.nlark.com/yuque/__latex/cdaf04cddf57ae63edeafceb53eb4044.svg)，模板代码给出的就是换根![image](https://cdn.nlark.com/yuque/__latex/cdaf04cddf57ae63edeafceb53eb4044.svg)做法

```cpp
using u64 = unsigned long long;

template <class T>
struct Rand
{
    std::mt19937 myrand;
    Rand(const long long seed = time(0)) : myrand(seed) {}
    T operator()(T l, T r)
    {
        return std::uniform_int_distribution<T>(l, r)(myrand);
    }
};
Rand<u64> rd;

u64 f(u64 x)
{
    const static u64 r1 = rd(1 << 20, 1 << 24);
    const static u64 r2 = rd(1 << 25, 1 << 30);
    const static u64 mask = (1ll << 31) - 1;

    auto h = [&](u64 y)
    {
        return (u64)y * y * y * r1 + r2;
    };
    return h(x & mask) + h(x >> 31);
}

struct Treehash // 得到每个点为根的hash值 On
{
    int n;
    std::vector<std::vector<int>> g;
    std::vector<u64> hash;
    u64 ans = 0;
    void dfs1(int u, int fa)
    {
        hash[u] = 1;
        for (auto v : g[u])
        {
            if (v == fa)
            {
                continue;
            }
            dfs1(v, u);
            hash[u] += f(hash[v]);
        }
    }
    void dfs2(int u, int fa)
    {
        for (auto v : g[u])
        {
            if (v == fa)
            {
                continue;
            }
            hash[v] = hash[v] + f(hash[u] - f(hash[v]));
            dfs2(v, u);
        }
    }
    Treehash(std::vector<std::vector<int>> &e) : n(e.size() - 1), g(e), hash(n + 1)
    {
        dfs1(1, 0);
        dfs2(1, 0);
        for (int i = 1; i <= n; ++i)
        {
            ans ^= hash[i];
        }
    }
};
```

### 快速LCA
我们考虑用![image](https://cdn.nlark.com/yuque/__latex/3554585ecb04a4bf73b5938d239b0fe5.svg)序求两个点的![image](https://cdn.nlark.com/yuque/__latex/a5f1a3b1ccbcb20d75ccf0efa8b7bb12.svg)

结论：不妨设![image](https://cdn.nlark.com/yuque/__latex/e208d0741403c70e793cd9807c43f767.svg)，那么![image](https://cdn.nlark.com/yuque/__latex/f692d00cddeb43fb80d2db36602ec54e.svg)是![image](https://cdn.nlark.com/yuque/__latex/65a3fe4bfdefd5ee1936a2f0c526111a.svg)序上![image](https://cdn.nlark.com/yuque/__latex/54ce647379be048e603ddeae282ca28a.svg)区间内深度最小的点的父亲

正确性显然：按![image](https://cdn.nlark.com/yuque/__latex/117860b103cca58fceb5d241c4d3b237.svg)是否有祖先关系讨论即可。

用返回最小位置的![image](https://cdn.nlark.com/yuque/__latex/fcd5b9e4e7009628bacef402bc06d6bf.svg)表预处理可以做到![image](https://cdn.nlark.com/yuque/__latex/a2006f1ac61cb1902beacb3e29fff089.svg)查询。

```cpp
template <class T>
class FastLCA
{
    int n;
    std::vector<std::vector<std::pair<int, int>>> g;
    TreePre<T> pre;
    ST<T> *st;

public:
    FastLCA(std::vector<std::vector<std::pair<int, int>>> &g, int root) : n(g.size() - 1), g(g), pre(g, root)
    {
        std::vector<int> reLabel(n + 1);
        for (int i = 1; i <= n; ++i)
        {
            reLabel[pre.dfn[i]] = pre.dep[i];
        }
        st = new ST(reLabel);
    }
    int getLca(int u, int v)
    {
        if (u == v)
        {
            return u;
        }
        u = pre.dfn[u], v = pre.dfn[v];
        if (u > v)
        {
            std::swap(u, v);
        }
        return pre.fa[pre.idfn[(*st)(u + 1, v)]];
    }
};
```

### 长链剖分
类似于重链剖分，其区别在于重儿子的定义。在此处重儿子的定义为最大深度最深的儿子。

用于快速求树上![image](https://cdn.nlark.com/yuque/__latex/df976ff7fcf17d60490267d18a1e3996.svg)级祖先，![image](https://cdn.nlark.com/yuque/__latex/9a4b19897e03daeb7e8beeecf02e82cc.svg)预处理，![image](https://cdn.nlark.com/yuque/__latex/a2006f1ac61cb1902beacb3e29fff089.svg)查询。

```cpp
// 长链剖分类（用于高效处理树上的k级祖先查询）
struct LongChainSplit
{
    int n;                              // 节点数量（编号1~n）
    std::vector<std::vector<int>> up;   // 存储每个链顶向上的节点序列
    std::vector<std::vector<int>> down; // 存储每个链顶向下的节点序列（沿重儿子）
    std::vector<std::vector<int>> &g;   // 树的邻接表（引用传递）
    std::vector<std::vector<int>> f;    // 倍增表，f[u][i]表示u的2^i级祖先
    std::vector<int> len;               // len[u]：u为根的子树中最长链长度
    std::vector<int> son;               // son[u]：u的重儿子（最长链方向）
    std::vector<int> dep;               // dep[u]：u的深度（根为1）
    std::vector<int> top;               // top[u]：u所在长链的链顶节点
    std::vector<int> lg;                // lg数组：预处理log2值
    int bit;                            // 倍增的最大位数

    // 第一次DFS：预处理深度、重儿子、倍增表
    void dfs1(int u, int fa)
    {
        f[u][0] = fa; // u的1级祖先是fa
        // 预处理倍增表（2^i级祖先）
        for (int i = 1; i <= bit; i++)
        {
            f[u][i] = f[f[u][i - 1]][i - 1]; // 2^i = 2^(i-1) + 2^(i-1)
        }
        // 遍历子节点
        for (auto v : g[u])
        {
            if (v != fa)
            {
                dep[v] = dep[u] + 1; // 更新深度
                dfs1(v, u);
                // 更新重儿子（选择子树链最长的）
                if (len[v] > len[son[u]])
                {
                    son[u] = v;
                }
            }
        }
        len[u] = len[son[u]] + 1; // u的最长链长度 = 重儿子的最长链长度 + 1
    }

    // 第二次DFS：构建长链（剖分链）
    void dfs2(int u, int tp)
    {
        top[u] = tp; // 记录u所在链的链顶
        // 如果是链顶，预处理该链的向上和向下序列
        if (u == tp)
        {
            // 向上序列：从u开始向上跳len[u]次（到根或链外）
            for (int i = u, j = 0; j < len[u]; j++, i = f[i][0])
            {
                up[tp].push_back(i);
            }
            // 向下序列：从u开始沿重儿子走len[u]次
            for (int i = u, j = 0; j <= len[u]; j++, i = son[i])
            {
                down[tp].push_back(i);
            }
        }
        // 优先处理重儿子（保证长链连续）
        if (son[u])
        {
            dfs2(son[u], tp);
        }
        // 处理其他轻儿子（新链的起点）
        for (auto v : g[u])
        {
            if (v != f[u][0] && v != son[u])
            {
                dfs2(v, v);
            }
        }
    }

    // 查询x的k级祖先
    int query(int x, int k)
    {
        if (!k)
            return x; // 0级祖先是自己
        // 先跳到x的2^lg[k]级祖先
        x = f[x][lg[k]];
        k -= (1 << lg[k]);         // 剩余需要跳的步数
        k -= dep[x] - dep[top[x]]; // 调整到链顶的相对位置
        x = top[x];
        // 根据k的正负决定向上/向下查找
        if (k >= 0)
        {
            return up[x][k]; // 从链顶向上跳k步
        }
        else
        {
            return down[x][-k]; // 从链顶向下跳-k步
        }
    }

    // 构造函数：初始化并预处理
    LongChainSplit(std::vector<std::vector<int>> &g, int root) : g(g),            // 树的邻接表
                                                                 n(g.size() - 1), // 节点数（假设编号1~n）
                                                                 up(n + 1),       // 初始化up数组
                                                                 down(n + 1),     // 初始化down数组
                                                                 len(n + 1),      // 初始化len数组
                                                                 son(n + 1),      // 初始化son数组
                                                                 dep(n + 1),      // 初始化dep数组
                                                                 top(n + 1),      // 初始化top数组
                                                                 lg(n + 1)        // 初始化lg数组
    {
        // 预处理log2值（查询时快速计算二进制最高位）
        lg[0] = lg[1] = 0;
        for (int i = 2; i <= n; i++)
        {
            lg[i] = lg[i >> 1] + 1;
        }
        // 计算倍增的位数（最大2^bit >= n）
        bit = std::__lg(n) + 1;
        // 初始化倍增表
        f.assign(n + 1, std::vector<int>(bit + 1));
        dep[root] = 1;    // 根节点深度为1
        dfs1(root, 0);    // 第一次DFS预处理
        dfs2(root, root); // 第二次DFS构建长链
    }
};

```

## 拓扑排序
拓扑排序是处理![image](https://cdn.nlark.com/yuque/__latex/8bca7aa7adef4d08a4a69af78d62516c.svg)的算法，其本质是按顺序处理每个点，处理该点时它的所有前驱点已经处理完毕，从而保证信息不会遗漏。它有如下的性质:

只有![image](https://cdn.nlark.com/yuque/__latex/8bca7aa7adef4d08a4a69af78d62516c.svg)才存在拓扑序，拓扑序是一个点的有序排列，其大小等于原图总点数。拓扑序不止一种，但在没有特殊性质下，拓扑序计数没有多项式时间解，但我们可以通过改队列为优先队列求出最大/最小拓扑序，当然也能判断图是不是![image](https://cdn.nlark.com/yuque/__latex/8bca7aa7adef4d08a4a69af78d62516c.svg)

在![image](https://cdn.nlark.com/yuque/__latex/8bca7aa7adef4d08a4a69af78d62516c.svg)上跑拓扑排序![image](https://cdn.nlark.com/yuque/__latex/a4b21aac24e324060119f8c1f9a32b59.svg)，可以解决![image](https://cdn.nlark.com/yuque/__latex/8bca7aa7adef4d08a4a69af78d62516c.svg)最长路，![image](https://cdn.nlark.com/yuque/__latex/8bca7aa7adef4d08a4a69af78d62516c.svg)路径计数,![image](https://cdn.nlark.com/yuque/__latex/922df7b1977f5ad7a705f2db8ca5cd8b.svg)点对可达情况等等

对于![image](https://cdn.nlark.com/yuque/__latex/8bca7aa7adef4d08a4a69af78d62516c.svg)点对可达情况我们可以![image](https://cdn.nlark.com/yuque/__latex/ad108092e57963659c7f5553fcaff7fd.svg)优化,即![image](https://cdn.nlark.com/yuque/__latex/c50a7a954ef5b1e090adbfe6c296f036.svg)

```cpp
struct Toposort
{
    int n;                           // 节点数量
    std::vector<std::vector<int>> g; // 邻接表
    std::vector<int> order;          // 存储拓扑序

    // 构造函数，初始化节点数量
    Toposort(int n) : n(n), g(n + 1) {}

    // 添加有向边 u->v
    void addEdge(int u, int v)
    {
        g[u].push_back(v);
    }

    // 执行拓扑排序，返回是否成功（无环）
    bool sort()
    {
        std::vector<int> deg(n + 1, 0);
        order.clear();
        order.reserve(n);

        // 计算入度
        for (int u = 1; u <= n; ++u)
        {
            for (int v : g[u])
            {
                ++deg[v];
            }
        }
        std::queue<int> q;
        // 找出所有入度为0的节点
        for (int u = 1; u <= n; ++u)
        {
            if (deg[u] == 0)
            {
                q.push(u);
            }
        }

        while (!q.empty())
        {
            int u = q.front();
            q.pop();
            order.push_back(u);
            // 减少相邻节点的入度
            for (int v : g[u])
            {
                if (--deg[v] == 0)
                {
                    q.push(v);
                }
            }
        }

        // 如果拓扑序包含所有节点，则无环
        return order.size() == n;
    }

    // 获取拓扑排序结果
    const std::vector<int> &getOrder() const
    {
        return order;
    }
};
```

## 最短路
### 单源最短路
首先我们最短路算法的精髓主要是松弛，松弛的定义为对于一条边![image](https://cdn.nlark.com/yuque/__latex/8ab4e50c20d37aabf90503557085f344.svg),如果满足![image](https://cdn.nlark.com/yuque/__latex/46c4bba2d46cde6cbf7bace5a150ea5d.svg)

我们让![image](https://cdn.nlark.com/yuque/__latex/b930455eb94161cea6b5ea8e98eb008c.svg)就叫松弛成功

#### BFS
由于队列先进先出的特性，在边权只有![image](https://cdn.nlark.com/yuque/__latex/3b617ee2a74a046024b372506ba30481.svg)时我们可以采用![image](https://cdn.nlark.com/yuque/__latex/b8100f4f2280a1a3172a3a0dc8425bb3.svg)求解最短路。

对于边权为![image](https://cdn.nlark.com/yuque/__latex/22d0feea96d3bb2fc273f7598ce748c1.svg)的情况，我们放到队列的头，对于边权为![image](https://cdn.nlark.com/yuque/__latex/53072c2388d69edc65c2377681e4e87c.svg)的情况，我们放到队列的尾。

#### BellmanFord
![image](https://cdn.nlark.com/yuque/__latex/098339a1390709864619c7db1ab2513c.svg)是暴力的松弛算法，根据松弛的定义我们知道每个点达到最优态最多需要![image](https://cdn.nlark.com/yuque/__latex/d20e38c984dfa040bc8dd22f7aa97d82.svg)轮，每轮松弛需要遍历所有的边松弛。特别的，如果到了第![image](https://cdn.nlark.com/yuque/__latex/53bd15bd9229cd48a311be75b1a51db2.svg)轮还能松弛成功的话，就说明有负环.

复杂度![image](https://cdn.nlark.com/yuque/__latex/023710761254052f2b1fdef291bd2c43.svg)

但是根据算法流程，我们发现![image](https://cdn.nlark.com/yuque/__latex/974326d285053855960de024f95073dc.svg)算法可以计算最多经过![image](https://cdn.nlark.com/yuque/__latex/df976ff7fcf17d60490267d18a1e3996.svg)条边的最短路，只需要松弛![image](https://cdn.nlark.com/yuque/__latex/6a6b811a2879516d7418f3d7325a142d.svg)轮即可

```cpp
template <class T>
struct BellmanFord
{
    int n;                                           // 节点数量
    const T INF = std::numeric_limits<T>::max() / 2; // 无穷大值
    std::vector<std::vector<std::pair<int, int>>> g; // 邻接表
    std::vector<T> dis;                              // 最短距离
    std::vector<int> pre;                            // 前驱节点

    // 构造函数，初始化节点数量
    BellmanFord(int n)
        : n(n),
          g(n + 1),
          dis(n + 1, INF),
          pre(n + 1, -1) {}

    // 添加有向边 u->v，权重为 w
    void addEdge(int u, int v, int w)
    {
        g[u].emplace_back(v, w);
    }
    // 执行 Bellman-Ford 算法
    // 参数：起点 st，可选参数 k 表示最多经过 k 条边
    [[nodiscard]] bool run(int st, int k = -1)
    {
        dis.assign(n + 1, INF);
        pre.assign(n + 1, -1);
        dis[st] = 0;

        bool cycle = false;                        // 标记负环
        int nums = (k == -1) ? n : k; // 迭代轮数

        for (int i = 1; i <= nums; ++i)
        {
            bool relaxed = false;
            auto lastDist = dis; // 保存上一轮距离，防止串联

            for (int u = 1; u <= n; ++u)
            {
                if (lastDist[u] == INF)
                    continue;
                for (const auto &[v, w] : g[u])
                {
                    if (lastDist[u] + w < dis[v])
                    {
                        dis[v] = lastDist[u] + w;
                        pre[v] = u;
                        relaxed = true;
                    }
                }
            }
            // 如果第 n 轮仍有松弛操作，说明存在负权环
            if (i == nums && relaxed && k == -1)
            {
                cycle = true;
            }
            // 如果本轮没有松弛操作，可以提前终止
            if (!relaxed)
                break;
        }
        return cycle;
    }
    // 获取最短距离数组
    const std::vector<T> &getDistance() const
    {
        return dis;
    }
};
```

#### Spfa
由于![image](https://cdn.nlark.com/yuque/__latex/974326d285053855960de024f95073dc.svg)的复杂度不够优秀，我们引入它的优化版![image](https://cdn.nlark.com/yuque/__latex/cdab6df32b1b78b580c54ef5aa7af7bb.svg)，我们发现每轮松弛有很多没必要的状态被操作，这大大浪费了时间.

所以![image](https://cdn.nlark.com/yuque/__latex/7f70e3c74396083d6726a318a02b3028.svg)算法在![image](https://cdn.nlark.com/yuque/__latex/098339a1390709864619c7db1ab2513c.svg)的基础上采用了一个队列，队列里记录了可能会松弛成功的点，加快了算法的执行速度。同样![image](https://cdn.nlark.com/yuque/__latex/cdab6df32b1b78b580c54ef5aa7af7bb.svg)也能判断负环，我们用一个![image](https://cdn.nlark.com/yuque/__latex/b2ca4e0df4fb46dfe7d4931072c41ddd.svg)记录松弛次数即可

作为处理负环的最短路算法,在一般的图上十分高效,但仍可以被毒瘤数据卡成![image](https://cdn.nlark.com/yuque/__latex/023710761254052f2b1fdef291bd2c43.svg)的复杂度,尽管如此![image](https://cdn.nlark.com/yuque/__latex/7f70e3c74396083d6726a318a02b3028.svg)仍然是我们在面对负数边权时最好的选择

```cpp
template <class T>
class SPFA
{
private:
    int n;                                           // 节点数量
    const T INF = std::numeric_limits<T>::max() / 2; // 无穷大值
    std::vector<std::vector<std::pair<int, int>>> g; // 邻接表
    std::vector<T> dis;                            // 最短距离
    std::vector<int> pre;                            // 前驱节点
    std::vector<int> inQueue;                        // 节点是否在队列中
    std::vector<int> relaxCount;                     // 节点松弛次数

public:
    // 构造函数，初始化节点数量
    SPFA(int n)
        : n(n),
          g(n + 1),
          dis(n + 1, INF),
          pre(n + 1, -1),
          inQueue(n + 1, 0),
          relaxCount(n + 1, 0) {}

    // 添加有向边 u->v，权重为 w
    void addEdge(int u, int v, int w)
    {
        g[u].emplace_back(v, w);
    }

    // 执行 SPFA 算法
    // 参数：起点 st
    // 返回值：pair<bool, bool>
    //   first: 是否成功找到最短路径
    //   second: 是否存在负权环
    [[nodiscard]] std::pair<bool, bool> run(int st)
    {
        // 初始化
        dis.assign(n + 1, INF);
        pre.assign(n + 1, -1);
        inQueue.assign(n + 1, 0);
        relaxCount.assign(n + 1, 0);
        dis[st] = 0;
        std::queue<int> q;
        q.push(st);
        inQueue[st] = 1;
        while (!q.empty())
        {
            int u = q.front();
            q.pop();
            inQueue[u] = 0;

            for (const auto &[v, w] : g[u])
            {
                if (dis[u] + w < dis[v])
                {
                    dis[v] = dis[u] + w;
                    pre[v] = u;
                    relaxCount[v] = relaxCount[u] + 1;

                    // 如果松弛次数超过n次，说明存在负权环
                    if (relaxCount[v] >= n)
                    {
                        return {false, true};
                    }

                    if (!inQueue[v])
                    {
                        q.push(v);
                        inQueue[v] = 1;
                    }
                }
            }
        }

        return {true, false};
    }

    // 获取最短距离数组
    const std::vector<T> &getDistance() const
    {
        return dis;
    }

    // 获取从起点到终点的最短路径
    std::vector<int> getPath(int target) const
    {
        std::vector<int> path;
        if (pre[target] == -1 && dis[target] == INF)
        {
            return path; // 不可达
        }

        for (int u = target; u != -1; u = pre[u])
        {
            path.push_back(u);
        }
        std::reverse(path.begin(), path.end());
        return path;
    }

    // 检查图中是否存在负权环
    bool has_negative_cycle()
    {
        // 需要重新初始化
        dis.assign(n + 1, 0);     // 使用0初始化以检测所有可能的负环
        inQueue.assign(n + 1, 1); // 初始所有节点都在队列中
        relaxCount.assign(n + 1, 0);

        std::queue<int> q;
        for (int i = 1; i <= n; ++i)
        {
            q.push(i);
        }

        while (!q.empty())
        {
            int u = q.front();
            q.pop();
            inQueue[u] = 0;

            for (const auto &[v, w] : g[u])
            {
                if (dis[u] + w < dis[v])
                {
                    dis[v] = dis[u] + w;
                    relaxCount[v] = relaxCount[u] + 1;

                    if (relaxCount[v] >= n)
                    {
                        return true;
                    }

                    if (!inQueue[v])
                    {
                        q.push(v);
                        inQueue[v] = 1;
                    }
                }
            }
        }
        return false;
    }
};
```

#### Dijkstra
Dijkstra是我们最为常用的最短路算法之一，可以处理无负边图的最短路，常规堆优化的最短路复杂度为![image](https://cdn.nlark.com/yuque/__latex/4f650d8e7e678f57d035feab7749ed3a.svg),如果我们使用![image](https://cdn.nlark.com/yuque/__latex/f5e7401836f57f59370dbb9061a0be24.svg)中的斐波那契堆优化，那么复杂度将是![image](https://cdn.nlark.com/yuque/__latex/8e4c0aceecaf0638ce319c5fb931019b.svg)

特别的，当边权只有![image](https://cdn.nlark.com/yuque/__latex/22d0feea96d3bb2fc273f7598ce748c1.svg)和![image](https://cdn.nlark.com/yuque/__latex/53072c2388d69edc65c2377681e4e87c.svg)时,我们使用![image](https://cdn.nlark.com/yuque/__latex/b8100f4f2280a1a3172a3a0dc8425bb3.svg)求解最短路



由于![image](https://cdn.nlark.com/yuque/__latex/f5e7401836f57f59370dbb9061a0be24.svg)中的配对堆不支持配模板，因此该板子没写类模板封装，需要手动改数据类型。

```cpp
struct Dijkstra
{
    using Edge = std::pair<int, int>; // first: 目标节点, second: 边权重

    // 自定义比较函数，按距离排序
    struct Compare
    {
        bool operator()(const Edge &a, const Edge &b) const
        {
            return a.second > b.second; // 小根堆
        }
    };

    // 使用配对堆（最接近斐波那契堆的实现）
    using Heap = __gnu_pbds::priority_queue<
        Edge,
        Compare,
        __gnu_pbds::pairing_heap_tag>;

    std::vector<int> dis;
    const int INF = std::numeric_limits<int>::max() / 2;
    int n;

    // 初始化
    Dijkstra(int n) : n(n), dis(n + 1) {}

    // 执行Dijkstra算法
    void run(int S, const std::vector<std::vector<Edge>> &g)
    {
        dis.assign(n + 1, INF);
        std::vector<bool> vis(n + 1, false);
        std::vector<Heap::point_iterator> handles(n + 1);
        Heap pq;

        dis[S] = 0;
        handles[S] = pq.push({S, 0});

        while (!pq.empty())
        {
            auto [u, d] = pq.top();
            pq.pop();

            if (vis[u])
                continue;
            vis[u] = true;

            for (const auto &[v, w] : g[u])
            {
                if (!vis[v] && dis[v] > dis[u] + w)
                {
                    dis[v] = dis[u] + w;
                    if (handles[v] != nullptr)
                    {
                        pq.modify(handles[v], {v, dis[v]});
                    }
                    else
                    {
                        handles[v] = pq.push({v, dis[v]});
                    }
                }
            }
        }
    }

    // 获取结果
    const std::vector<int> &getDistance() const
    {
        return dis;
    }
};
```

还能不能优化呢？如果还要追求更极致的效率，需要发掘一些性质

比如：如果边权总和有限/最短路不会很长，我们可以用桶配合距离实现最小堆的功能，这样可以做到![image](https://cdn.nlark.com/yuque/__latex/fdf264192b783f02198831921a7e54b0.svg)

#### 最短路计数
我们不妨设源点为![image](https://cdn.nlark.com/yuque/__latex/53072c2388d69edc65c2377681e4e87c.svg)，我们要求源点到其他点最短路的条数，考虑![image](https://cdn.nlark.com/yuque/__latex/4dc575314dfc9be173edc5e447b1d3c0.svg)的过程，我们开一个![image](https://cdn.nlark.com/yuque/__latex/433b8a66a6efa08fd812b9e20c8af568.svg)数组记录最短路条数,如果![image](https://cdn.nlark.com/yuque/__latex/46c4bba2d46cde6cbf7bace5a150ea5d.svg)，那么![image](https://cdn.nlark.com/yuque/__latex/ee002624f993fdafecd0ba588da0fa90.svg)将成为新的最短路,所以我们让![image](https://cdn.nlark.com/yuque/__latex/f49f656a8d497e74d8527024468cd8f4.svg),而如果是![image](https://cdn.nlark.com/yuque/__latex/0bbbcc47ce81675f67dde55146b232e7.svg),那么![image](https://cdn.nlark.com/yuque/__latex/a770a282bbfa0ae1ec474b7ed311656d.svg)的最短路将会更多,我们让![image](https://cdn.nlark.com/yuque/__latex/cc38e9245bf5ab90882e64c5684151b1.svg)

注意先判![image](https://cdn.nlark.com/yuque/__latex/c2cf4ce42b51f3374f25647b464ae753.svg),无论是大于还是等于都要入队

#### 差分约束
差分约束用来求解一形如![image](https://cdn.nlark.com/yuque/__latex/eb3e478df49ee56e2f258cee797293b1.svg)的不等式组的可行解问题，我们通过建立有向图来解决

我们把每个未知数转化为图上的每个点,我们建立虚拟源点0,向每个点连边权为0的有向边。

对于一个未知数![image](https://cdn.nlark.com/yuque/__latex/712ecf7894348e92d8779c3ee87eeeb0.svg),从超级源点到它的距离就是一个可行解

我们接下来详细介绍如何建图，分求最大解和最小解两种情况



![image](https://cdn.nlark.com/yuque/__latex/0eb30e845f1370ce04407adc80e2b3ac.svg) 求最大可行解

未知数![image](https://cdn.nlark.com/yuque/__latex/f8b64cc73b7848a50ed9317d01128637.svg)的最大可行解为，从源点到![image](https://cdn.nlark.com/yuque/__latex/712ecf7894348e92d8779c3ee87eeeb0.svg)的最短路![image](https://cdn.nlark.com/yuque/__latex/4789bb91f1dfcdd08d6d28be56efd967.svg)

首先我们将所有不等式转化为![image](https://cdn.nlark.com/yuque/__latex/37aedba5d7c0a9f2630bb6f11b2cac1b.svg)我们连边![image](https://cdn.nlark.com/yuque/__latex/4a76d1fb42915ebf020be4afda1738e8.svg)边权为![image](https://cdn.nlark.com/yuque/__latex/a42a4fc28b384cc408de066beed57485.svg)

如果不等式形如![image](https://cdn.nlark.com/yuque/__latex/5a540f5a417af9405fdc338cf393d50c.svg) 我们转化为![image](https://cdn.nlark.com/yuque/__latex/ff2abe2811e0a09af3c75a22dc5d080c.svg)

如果不等式形如![image](https://cdn.nlark.com/yuque/__latex/a4f4d18140e5c868ddfc930da15fbe1e.svg) 我们转化为![image](https://cdn.nlark.com/yuque/__latex/b2a7d830cb6c9871492e1b8f5755292f.svg) 其中![image](https://cdn.nlark.com/yuque/__latex/0bd4f2263cc8b0dee284455e1ddb1c75.svg)为超级源点



![image](https://cdn.nlark.com/yuque/__latex/ba4c3f97371ffa47698bd1290a56dda1.svg)求最小可行解

未知数![image](https://cdn.nlark.com/yuque/__latex/712ecf7894348e92d8779c3ee87eeeb0.svg)的最小可行解为，从源点到![image](https://cdn.nlark.com/yuque/__latex/712ecf7894348e92d8779c3ee87eeeb0.svg)的最长路![image](https://cdn.nlark.com/yuque/__latex/4789bb91f1dfcdd08d6d28be56efd967.svg)

首先我们将所有不等式转化为![image](https://cdn.nlark.com/yuque/__latex/82ae8f89f687aa873f2da44b52a6694e.svg) 我们连边![image](https://cdn.nlark.com/yuque/__latex/96347643d8bb9b546d99516788a81be8.svg) 边权为![image](https://cdn.nlark.com/yuque/__latex/a42a4fc28b384cc408de066beed57485.svg)

如果不等式形如![image](https://cdn.nlark.com/yuque/__latex/9ccd978c5487547e73c242bbabbf7f1d.svg) 我们转化为![image](https://cdn.nlark.com/yuque/__latex/49d64c4845c26efd6f751fa09064fa88.svg)

如果不等式形如![image](https://cdn.nlark.com/yuque/__latex/18b4ace02763c6bf74d2d8a687006822.svg) 我们转化为![image](https://cdn.nlark.com/yuque/__latex/de286c6a92bdbc2a936ea9fef40371c2.svg)其中![image](https://cdn.nlark.com/yuque/__latex/0bd4f2263cc8b0dee284455e1ddb1c75.svg)为超级源点



我们选择合适的最短路算法求解即可 如果存在负环，那么原不等式组无解（一般用SPFA）

#### **分层图最短路**
分层图最短路是将原本的一层图复制变成多层图帮助我们求解答案的一个![image](https://cdn.nlark.com/yuque/__latex/621c3d854e3e58826c741a0391b55796.svg)，题目往往形如，对一个边带权图![image](https://cdn.nlark.com/yuque/__latex/92232bff4c7103ad09227936b16c6ce8.svg),要求![image](https://cdn.nlark.com/yuque/__latex/9f9d0eca9a9b7ba6abe71b1bc412f036.svg)的最短路，但是我们可以免费走![image](https://cdn.nlark.com/yuque/__latex/38a3f4d664b7a723d138f9d57be0c783.svg)条边，我们复制![image](https://cdn.nlark.com/yuque/__latex/38a3f4d664b7a723d138f9d57be0c783.svg)层相同的图，在层与层之间连边权为![image](https://cdn.nlark.com/yuque/__latex/22d0feea96d3bb2fc273f7598ce748c1.svg)的边，这样就达到了免费走边的目的，如果当前在第![image](https://cdn.nlark.com/yuque/__latex/2443fbcfeb7e85e1d62b6f5e4f27207e.svg)层图，相当于走了![image](https://cdn.nlark.com/yuque/__latex/fb05ae8899c90dea2d5be54e255b941d.svg)条免费边

#### **最短路树和最短路DAG**
最短路树:

在我们求解以![image](https://cdn.nlark.com/yuque/__latex/55fc237afbe535f7d8434985b848a6a7.svg)为起点的单源最短路时,我们每次对一个点成功松弛时,即![image](https://cdn.nlark.com/yuque/__latex/d9e4497d8c9e2738b4695316c913cae9.svg)时,我们令![image](https://cdn.nlark.com/yuque/__latex/00e9f4db12769db4a17ddd967ede8db2.svg),也就是说我们记录每个点的前驱,最终会形成一棵树的结构,称作最短路树.最短路树时处理变形最短路问题的关键方法.

最短路DAG:

我们求解完单源最短路径之后,假设起点为![image](https://cdn.nlark.com/yuque/__latex/55fc237afbe535f7d8434985b848a6a7.svg)，我们建立一张新图，我们对于每条边![image](https://cdn.nlark.com/yuque/__latex/09cdc23606203931426c6186eb0ce6f3.svg),如果有![image](https://cdn.nlark.com/yuque/__latex/b8d1498d24e0b28715e1f0c581feb25d.svg),那么我们在新图上连边![image](https://cdn.nlark.com/yuque/__latex/e6cdff7e69798d28b0aabed29902e773.svg)，这样我们将得到一张![image](https://cdn.nlark.com/yuque/__latex/fa19270340385d0ec45ae7e3097d9f8f.svg),对于这张![image](https://cdn.nlark.com/yuque/__latex/fa19270340385d0ec45ae7e3097d9f8f.svg)的所有生成树，都是一个合法的最短路树，因此我们可以套用矩阵树定理求解最短路树数量

#### **删边/带修最短路**
这是一个非常经典的问题,题目形式为![image](https://cdn.nlark.com/yuque/__latex/34c7b563b30bde3c748139530686798e.svg)次询问，每次询问删去某条边![image](https://cdn.nlark.com/yuque/__latex/9f9d0eca9a9b7ba6abe71b1bc412f036.svg)的最短路,删除非永久化.

每次询问的![image](https://cdn.nlark.com/yuque/__latex/9f9d0eca9a9b7ba6abe71b1bc412f036.svg)相同.

我们用![image](https://cdn.nlark.com/yuque/__latex/12f71d61444186dbfb5f133177d64b42.svg)表示最短路树上![image](https://cdn.nlark.com/yuque/__latex/a969cab25db24b7b40ddd3064d3ab658.svg)的路径 ![image](https://cdn.nlark.com/yuque/__latex/a428bd244ddaa5c11de20ca9cfd9d494.svg)表示原最短路长度

我们先求出![image](https://cdn.nlark.com/yuque/__latex/8df10313086d51034ff8c0dc0a98165c.svg),注意到![image](https://cdn.nlark.com/yuque/__latex/8df10313086d51034ff8c0dc0a98165c.svg)是一段连续的边的区间

如果询问删去的边不属于![image](https://cdn.nlark.com/yuque/__latex/8df10313086d51034ff8c0dc0a98165c.svg)，那么![image](https://cdn.nlark.com/yuque/__latex/d94add20cd1ed4d64c64e392b043f4aa.svg)

如果询问删去的边属于![image](https://cdn.nlark.com/yuque/__latex/8df10313086d51034ff8c0dc0a98165c.svg),我们预处理出每条非最短路边的贡献，对于一条非最短路边![image](https://cdn.nlark.com/yuque/__latex/09cdc23606203931426c6186eb0ce6f3.svg)，我们把经过这条边的最短路表示为![image](https://cdn.nlark.com/yuque/__latex/40b7df4a19302a9858327e65b0b280e0.svg),不难发现![image](https://cdn.nlark.com/yuque/__latex/5ff46176e95d9c7377e0735ed5f37692.svg)有贡献的区间是![image](https://cdn.nlark.com/yuque/__latex/b573de029b4c5bc9d4f696989eec3a2e.svg),其中![image](https://cdn.nlark.com/yuque/__latex/5e588dfc5879cf1d6455640acebad04c.svg)为![image](https://cdn.nlark.com/yuque/__latex/8df10313086d51034ff8c0dc0a98165c.svg)和![image](https://cdn.nlark.com/yuque/__latex/95b596e9632e8b9732d10e71ef9f23f9.svg)第一个非重合点的位置，![image](https://cdn.nlark.com/yuque/__latex/740edc18f8ba4d2392d7dcb479b98489.svg)为![image](https://cdn.nlark.com/yuque/__latex/c816f5e807f06209199e7533f7929fe5.svg)和![image](https://cdn.nlark.com/yuque/__latex/cf10000379e4e7ead32aa33061dbed05.svg)第一个非重合点的位置。我们可以通过最短路树上![image](https://cdn.nlark.com/yuque/__latex/cdaf04cddf57ae63edeafceb53eb4044.svg)求出所有点的![image](https://cdn.nlark.com/yuque/__latex/0ed4e429fb69de3ef9edf438480e3e46.svg),这里的贡献的含义是，删去这个区间的边后我可以用![image](https://cdn.nlark.com/yuque/__latex/bcc00018e02ea399f7a9a7d058ffb90b.svg)代替,因此我们使用区间![image](https://cdn.nlark.com/yuque/__latex/8a93d856ced2a133a990fa45a2130524.svg)线段树直接维护最短路值![image](https://cdn.nlark.com/yuque/__latex/40b7df4a19302a9858327e65b0b280e0.svg)，每次询问单点查询即可 

```cpp

template <class G>
class EdgeDeleteShortestPath
{
public:
    SegmentTree<G> *Tree;//区间min线段树
    const G inf = std::numeric_limits<G>::max() / 2;//上限
    std::map<std::pair<int, int>, int> mp;
    std::vector<G> disS, disT;//S为起点的dis数组  T为起点的dis数组
    std::vector<int> preS, preT;//
    G before;//before表示最开始的最短路
    EdgeDeleteShortestPath(int S, int T, std::vector<std::vector<std::pair<int, G>>> &g)
    {
        int n = g.size() - 1;
        Dijkstra dijk(n);
        dijk.run(S, g);
        before = dijk.dis[T];
        preS = dijk.getPre();
        disS = dijk.getDistance();
        dijk.run(T, g);
        preT = dijk.getPre();
        disT = dijk.getDistance();
        std::vector<int> path; // 从s->t
        int now = S;
        while (now != -1)
        {
            path.push_back(now);
            now = preT[now];
            if (path.size() >= 2)
            {
                mp[{path[path.size() - 2], path.back()}] = path.size() - 1;
                mp[{path.back(), path[path.size() - 2]}] = path.size() - 1; // 记录路径是第几条边
            }
        }
        std::vector<std::vector<int>> treeS(n + 1), treeT(n + 1); // 最短路树
        for (int i = 1; i <= n; ++i)
        {
            if (preS[i] != -1)
            {
                treeS[preS[i]].push_back(i);
            }
            if (preT[i] != -1)
            {
                treeT[preT[i]].push_back(i);
            }
        }
        int PathSum = path.size() - 1;

        std::vector<int> dpS(n + 1, 0), dpT(n + 1, 0);
        auto dfsS = [&](auto dfsS, int u) -> void
        {
            for (auto v : treeS[u])
            {
                if (mp.contains(std::make_pair(u, v))) // 说明还在干线上
                {
                    dpS[v] = mp[{std::make_pair(u, v)}] + 1;
                    dfsS(dfsS, v);
                }
                else
                {
                    dpS[v] = dpS[u];
                    dfsS(dfsS, v);
                }
            }
        };
        dpS[S] = 1;
        dfsS(dfsS, S);
        auto dfsT = [&](auto dfsT, int u) -> void
        {
            for (auto v : treeT[u])
            {
                if (mp.contains(std::make_pair(u, v))) // 说明还在干线上
                {
                    dpT[v] = mp[{std::make_pair(u, v)}] - 1;
                    dfsT(dfsT, v);
                }
                else
                {
                    dpT[v] = dpT[u];
                    dfsT(dfsT, v);
                }
            }
        };
        dpT[T] = path.size() - 1;
        dfsT(dfsT, T);
        std::vector<G> cur(path.size(), inf);
        Tree = new SegmentTree<G>(cur);
        for (int u = 1; u <= n; ++u)
        {
            for (auto [v, w] : g[u])
            {
                if (!mp.contains({u, v})) // 说明不是最短路边需要更新答案
                {
                    if (dpS[u] <= dpT[v] and dpT[v] <= path.size() - 1 and dpS[u] >= 1)
                    {
                        Tree->rangeGetMin(dpS[u], dpT[v], disS[u] + disT[v] + w);
                    }
                }
            }
        }
    }
    G getShortestPath(int u, int v)
    {
        if (!mp.contains({u, v}))
        {
            return before;
        }
        else
        {
            return Tree->rangeQuerySum(mp[{u, v}], mp[{u, v}]);
        }
    }
};
```

#### **平面图最小割**
我们有如下定理:

对于一个平面图来说，![image](https://cdn.nlark.com/yuque/__latex/9f9d0eca9a9b7ba6abe71b1bc412f036.svg)的最小割等价于在其对偶图上的最短路。

实际上我们最大的困难在于把平面图转化为其对偶图

#### **同余最短路**
<font style="color:rgba(0, 0, 0, 0.87);">当出现形如给定</font>![image](https://cdn.nlark.com/yuque/__latex/df378375e7693bdcf9535661c023c02e.svg)<font style="color:rgba(0, 0, 0, 0.87);">个整数，求这</font>![image](https://cdn.nlark.com/yuque/__latex/df378375e7693bdcf9535661c023c02e.svg)<font style="color:rgba(0, 0, 0, 0.87);">个整数能拼凑出多少个其他整数（</font>![image](https://cdn.nlark.com/yuque/__latex/df378375e7693bdcf9535661c023c02e.svg)<font style="color:rgba(0, 0, 0, 0.87);">个整数可以重复取），以及给定</font>![image](https://cdn.nlark.com/yuque/__latex/df378375e7693bdcf9535661c023c02e.svg)<font style="color:rgba(0, 0, 0, 0.87);">个整数，求这</font>![image](https://cdn.nlark.com/yuque/__latex/df378375e7693bdcf9535661c023c02e.svg)<font style="color:rgba(0, 0, 0, 0.87);">个整数不能拼凑出的最小(最大)的整数，或者至少要拼几次才能拼出模</font>![image](https://cdn.nlark.com/yuque/__latex/ffd1905f6d4d60accedfa6b91be93ea9.svg)<font style="color:rgba(0, 0, 0, 0.87);">余</font>![image](https://cdn.nlark.com/yuque/__latex/38a3f4d664b7a723d138f9d57be0c783.svg)<font style="color:rgba(0, 0, 0, 0.87);"> 的数的问题时可以使用同余最短路的方法。</font>

<font style="color:rgba(0, 0, 0, 0.87);">我们用例题来说明，给你</font>![image](https://cdn.nlark.com/yuque/__latex/b18a308fc00eb68098bf3ecfe09373a4.svg)<font style="color:rgba(0, 0, 0, 0.87);">，请你求出</font>![image](https://cdn.nlark.com/yuque/__latex/38f40f4a7ab66b4dd1810d798f24e8a9.svg)<font style="color:rgba(0, 0, 0, 0.87);">能构成</font>![image](https://cdn.nlark.com/yuque/__latex/9fecdf7124098487eca9a7026cc23426.svg)<font style="color:rgba(0, 0, 0, 0.87);">区间内多少个不同的数字?</font>

<font style="color:rgba(0, 0, 0, 0.87);">我们不妨设</font>![image](https://cdn.nlark.com/yuque/__latex/6c10824666d10b9c6691d40dc6ce58ef.svg)<font style="color:rgba(0, 0, 0, 0.87);">，我们考虑不使用最小数字</font>![image](https://cdn.nlark.com/yuque/__latex/712ecf7894348e92d8779c3ee87eeeb0.svg)<font style="color:rgba(0, 0, 0, 0.87);">的情况下，求出该表达式</font>![image](https://cdn.nlark.com/yuque/__latex/b4d4e1065648dde4da6752b5ce95fdae.svg)<font style="color:rgba(0, 0, 0, 0.87);">的最小数字，具体的说，假如余数为</font>![image](https://cdn.nlark.com/yuque/__latex/2443fbcfeb7e85e1d62b6f5e4f27207e.svg)<font style="color:rgba(0, 0, 0, 0.87);">的最小数为</font>![image](https://cdn.nlark.com/yuque/__latex/2addd237806c5ad1ae2619c7bc89e57b.svg)<font style="color:rgba(0, 0, 0, 0.87);">,那么所有的</font>![image](https://cdn.nlark.com/yuque/__latex/b4c5a7817383fdabab099a0209806c75.svg)<font style="color:rgba(0, 0, 0, 0.87);">都能构成。那么怎么求出最小数呢，我们可以进行的操作为</font>![image](https://cdn.nlark.com/yuque/__latex/c535a5cc9e463cfdbb3bc888875dbf0d.svg)<font style="color:rgba(0, 0, 0, 0.87);">和</font>![image](https://cdn.nlark.com/yuque/__latex/529a40219b56b2aa37e98395c02f8734.svg)<font style="color:rgba(0, 0, 0, 0.87);">，不难发现这是一个有向边，边权分别为</font>![image](https://cdn.nlark.com/yuque/__latex/bf98c0ddcbe9c1e535f767c78c3aa813.svg)<font style="color:rgba(0, 0, 0, 0.87);">和</font>![image](https://cdn.nlark.com/yuque/__latex/02bab26178a0cd05dae15ad487830237.svg)<font style="color:rgba(0, 0, 0, 0.87);">，这启发我们使用最短路算法得到所有的</font>![image](https://cdn.nlark.com/yuque/__latex/2addd237806c5ad1ae2619c7bc89e57b.svg)<font style="color:rgba(0, 0, 0, 0.87);">,那么最终答案为</font>![image](https://cdn.nlark.com/yuque/__latex/83daa5732ffd8402a3af79743824fabf.svg)<font style="color:rgba(0, 0, 0, 0.87);">,注意源点为</font>![image](https://cdn.nlark.com/yuque/__latex/22d0feea96d3bb2fc273f7598ce748c1.svg)<font style="color:rgba(0, 0, 0, 0.87);">且</font>![image](https://cdn.nlark.com/yuque/__latex/6f50b398225061e623f23fee6b489494.svg)

### 全源最短路
全源最短路实际上是求出图上任意两点间的最短路。

我们分稠密图和稀疏图来分别考虑

对于稠密图而言，![image](https://cdn.nlark.com/yuque/__latex/37d8c832aad00878c296429fe3e6611f.svg)算法是最好的选择，因为时间复杂度与![image](https://cdn.nlark.com/yuque/__latex/8377449edd44d84f3384ba3e5c0e6233.svg)无关，我们可以在![image](https://cdn.nlark.com/yuque/__latex/a77815a52a2d0050828079fb142b1410.svg)的时间内解决该问题

对于稀疏图来说，我们有两种选择，对于没有负边的图，我们可以跑![image](https://cdn.nlark.com/yuque/__latex/df378375e7693bdcf9535661c023c02e.svg)次![image](https://cdn.nlark.com/yuque/__latex/ca699979457d297637084a4a45cff152.svg)算法来实现，复杂度![image](https://cdn.nlark.com/yuque/__latex/de6746be7a247e6d7400ea6e3b264d59.svg),对于有负权的图，我们只能采用全源最短路算法![image](https://cdn.nlark.com/yuque/__latex/0e19aa16e76465c4446675c3a3ca2300.svg)算法，复杂度为![image](https://cdn.nlark.com/yuque/__latex/c225b34764a8f676a36ef47fd24b6880.svg)

#### Floyd
```cpp
template <class T>
class Floyd
{
private:
    int n;                                           // 节点数量
    const T INF = std::numeric_limits<T>::max() / 2; // 防止加法溢出
    std::vector<std::vector<T>> dp;                  // 距离矩阵
    std::vector<std::vector<int>> next;              // 路径重建矩阵

public:
    // 构造函数，初始化节点数量
    Floyd(int n)
        : n(n),
          dp(n + 1, std::vector<T>(n + 1, INF)),
          next(n + 1, std::vector<int>(n + 1, -1))
    {

        // 初始化对角线为0
        for (int i = 1; i <= n; ++i)
        {
            dp[i][i] = 0;
            next[i][i] = i;
        }
    }

    // 添加无向边 u-v，权重为 w（自动处理重边）
    void addEdge(int u, int v, T w)
    {
        dp[u][v] = std::min(dp[u][v], w);
        dp[v][u] = std::min(dp[v][u], w);
        next[u][v] = v;
        next[v][u] = u;
    }

    // 执行 Floyd-Warshall 算法
    void run()
    {
        for (int k = 1; k <= n; ++k)
        {
            for (int i = 1; i <= n; ++i)
            {
                for (int j = 1; j <= n; ++j)
                {
                    if (dp[i][k] + dp[k][j] < dp[i][j])
                    {
                        dp[i][j] = dp[i][k] + dp[k][j];
                        next[i][j] = next[i][k];
                    }
                }
            }
        }
    }

    // 获取距离矩阵
    const std::vector<std::vector<T>> &getDistanceMatrix() const
    {
        return dp;
    }

    // 获取两点间的最短距离
    T getDistance(int u, int v) const
    {
        return dp[u][v];
    }

    // 获取两点间的最短路径
    std::vector<int> getPath(int u, int v) const
    {
        std::vector<int> path;

        // 不可达情况
        if (next[u][v] == -1)
        {
            return path;
        }
        path.push_back(u);
        while (u != v)
        {
            u = next[u][v];
            path.push_back(u);
        }
        return path;
    }

    // 检查图中是否存在负权环
    bool hasNegativeCycle() const
    {
        for (int i = 1; i <= n; ++i)
        {
            if (dp[i][i] < 0)
            {
                return true;
            }
        }
        return false;
    }
};
```

#### Johnson
![image](https://cdn.nlark.com/yuque/__latex/b8dabd5ded3ce30b1a81122b03b546bb.svg)算法实际上也是跑![image](https://cdn.nlark.com/yuque/__latex/53bd15bd9229cd48a311be75b1a51db2.svg)轮![image](https://cdn.nlark.com/yuque/__latex/ca699979457d297637084a4a45cff152.svg)算法的做法，但我们提前处理了负边权,方法如下

我们建立超级虚拟源点![image](https://cdn.nlark.com/yuque/__latex/22d0feea96d3bb2fc273f7598ce748c1.svg)，向每个点连接边权为![image](https://cdn.nlark.com/yuque/__latex/22d0feea96d3bb2fc273f7598ce748c1.svg)的有向边，然后我们跑![image](https://cdn.nlark.com/yuque/__latex/7f70e3c74396083d6726a318a02b3028.svg)算法得到![image](https://cdn.nlark.com/yuque/__latex/22d0feea96d3bb2fc273f7598ce748c1.svg)向每个点的最短路![image](https://cdn.nlark.com/yuque/__latex/c828e5141cfdb4a9256e544a78afb045.svg)，然后我们重新设定边权，对原先的边![image](https://cdn.nlark.com/yuque/__latex/8ab4e50c20d37aabf90503557085f344.svg),我们改为![image](https://cdn.nlark.com/yuque/__latex/87d1382d502f63ebf5421307e30c7523.svg),可以证明这种操作可以使新的边权为非负数,然后我们利用新边权跑![image](https://cdn.nlark.com/yuque/__latex/df378375e7693bdcf9535661c023c02e.svg)轮![image](https://cdn.nlark.com/yuque/__latex/4dc575314dfc9be173edc5e447b1d3c0.svg)算法，最终两条边实际的最短路![image](https://cdn.nlark.com/yuque/__latex/604683e5ede6d31508745ef2b2143b07.svg),其中![image](https://cdn.nlark.com/yuque/__latex/bb4bc641b647a8ce62fbcc5e9e00b1bf.svg)是![image](https://cdn.nlark.com/yuque/__latex/4dc575314dfc9be173edc5e447b1d3c0.svg)的结果

实现完全基于![image](https://cdn.nlark.com/yuque/__latex/7f70e3c74396083d6726a318a02b3028.svg)和![image](https://cdn.nlark.com/yuque/__latex/e299f71c3f867691e2acf88d1c1fe434.svg)算法，在此不给出代码

#### 无向图最小环
我们不难想到有朴素的![image](https://cdn.nlark.com/yuque/__latex/4dc575314dfc9be173edc5e447b1d3c0.svg)算法，即对每条边![image](https://cdn.nlark.com/yuque/__latex/8ab4e50c20d37aabf90503557085f344.svg),我求出删去该边后![image](https://cdn.nlark.com/yuque/__latex/77c3adce895348f6083c425fe1ba2624.svg)到![image](https://cdn.nlark.com/yuque/__latex/a770a282bbfa0ae1ec474b7ed311656d.svg)的最短路![image](https://cdn.nlark.com/yuque/__latex/bb4bc641b647a8ce62fbcc5e9e00b1bf.svg),然后此时的最小环为![image](https://cdn.nlark.com/yuque/__latex/4bcdb1315a98544fcb5c893df87322da.svg)，对每条边处理答案取小即可,但复杂度十分爆炸，高达![image](https://cdn.nlark.com/yuque/__latex/ca965dcd19b5f9bfad28cdc1e4bc393f.svg)

于是我们考虑改进![image](https://cdn.nlark.com/yuque/__latex/ba6eebf4caee9e7216e0377ffefffd1b.svg)算法，我们注意到![image](https://cdn.nlark.com/yuque/__latex/ba6eebf4caee9e7216e0377ffefffd1b.svg)算法的执行过程，当外层枚举到![image](https://cdn.nlark.com/yuque/__latex/df976ff7fcf17d60490267d18a1e3996.svg)时，此时所有点之间的最短路只经过![image](https://cdn.nlark.com/yuque/__latex/625e2419f556a374c98bd82262d84678.svg)区间内的点。我们记![image](https://cdn.nlark.com/yuque/__latex/78e67e65b02d7d2d489508ec9e7e6531.svg)为原始边权，![image](https://cdn.nlark.com/yuque/__latex/ce2cb0689e77cdd917f7533413454058.svg)为最短路，我们不难想到外层枚举到![image](https://cdn.nlark.com/yuque/__latex/df976ff7fcf17d60490267d18a1e3996.svg)时，处理经过点![image](https://cdn.nlark.com/yuque/__latex/df976ff7fcf17d60490267d18a1e3996.svg)的环路，其中![image](https://cdn.nlark.com/yuque/__latex/6a6b811a2879516d7418f3d7325a142d.svg)是最大点，于是我们双层循环枚举![image](https://cdn.nlark.com/yuque/__latex/a1170a444f2006784f140aea7fd6baa4.svg)，![image](https://cdn.nlark.com/yuque/__latex/a1170a444f2006784f140aea7fd6baa4.svg)分别为![image](https://cdn.nlark.com/yuque/__latex/6a6b811a2879516d7418f3d7325a142d.svg)的两个邻点，取环路长度为![image](https://cdn.nlark.com/yuque/__latex/955a9696497c49676337bc61bd1a0c5d.svg),然后正常跑剩下的![image](https://cdn.nlark.com/yuque/__latex/ba6eebf4caee9e7216e0377ffefffd1b.svg)算法

```cpp
template <class T>
class FloydMinCycle
{
private:
    int n;                                           // 节点数量
    const T INF = std::numeric_limits<T>::max() / 2; // 无穷大值
    std::vector<std::vector<T>> dist;                // 最短距离矩阵
    std::vector<std::vector<T>> g;                   // 原始图邻接矩阵
    T mincycle;                                      // 最小环长度

public:
    // 构造函数，初始化节点数量
    FloydMinCycle(int n)
        : n(n),
          dist(n + 1, std::vector<T>(n + 1, INF)),
          g(n + 1, std::vector<T>(n + 1, INF)),
          mincycle(INF)
    {

        // 初始化对角线为0
        for (int i = 1; i <= n; ++i)
        {
            dist[i][i] = g[i][i] = 0;
        }
    }

    // 添加无向边 u-v，权重为 w（自动处理重边）
    void addEdge(int u, int v, T w)
    {
        g[u][v] = g[v][u] = std::min(g[u][v], w);
        dist[u][v] = dist[v][u] = g[u][v];
    }

    // 执行 Floyd 最小环算法
    void findMinCycle()
    {
        mincycle = INF;
        for (int k = 1; k <= n; ++k)
        {
            // 检查以k为最大节点的环
            for (int i = 1; i < k; ++i)
            {
                for (int j = i + 1; j < k; ++j)
                {
                    // 防止三个INF相加溢出
                    if (dist[i][j] < INF && g[i][k] < INF && g[k][j] < INF)
                    {
                        mincycle = std::min(
                            mincycle,
                            dist[i][j] + g[i][k] + g[k][j]);
                    }
                }
            }
            // 更新最短路径
            for (int i = 1; i <= n; ++i)
            {
                for (int j = 1; j <= n; ++j)
                {
                    if (dist[i][k] < INF && dist[k][j] < INF)
                    {
                        dist[i][j] = std::min(
                            dist[i][j],
                            dist[i][k] + dist[k][j]);
                    }
                }
            }
        }
    }

    // 获取最小环长度
    T getMinCycleLength() const
    {
        return mincycle;
    }

    // 检查图中是否存在环
    bool hasCycle() const
    {
        return mincycle < INF;
    }
};
```

#### 有向图最小平均值环
```cpp
// 点标号为 1,2,...,n, 0为虚拟源点向其他点连权值为0的单向边.
// f[i][v] : 从 0 到 v 恰好经过 i 条路的最短路
ll f[N][N] = {Inf};
int u[M], v[M], w[M];
f[0][0] = 0;
for (int i = 1; i < n + 1; i++)
    for (int j = 0; j < m; j++)
        f[i][v[j]] = min(f[i][v[j]], f[i - 1][u[j]] + w[j]);

double ans = Inf;
for (int i = 1; i <= n; i++)
{
    double t = -Inf;
    for (int j = 1; j < n; j++)
        t = max(t, (f[n][i] - f[j][i]) / (double)(n - j));
    ans = min(t, ans);
}
```

### 多源最短路
这里的多源是指有多个起点，对于非源点的节点，我们只需求出到其最近源点的距离，称为多源最短路问题

朴素的最短路算法在多源最短路仍然使用，以![image](https://cdn.nlark.com/yuque/__latex/4dc575314dfc9be173edc5e447b1d3c0.svg)算法为例，我们只需要把初始的多个源点都设置![image](https://cdn.nlark.com/yuque/__latex/68e00cf80f560956e1f1f5783bdf6f0a.svg),并全部![image](https://cdn.nlark.com/yuque/__latex/5260653b99c9fb4539a4bf096513e428.svg)到优先队列中即可，然后跑正常的![image](https://cdn.nlark.com/yuque/__latex/4dc575314dfc9be173edc5e447b1d3c0.svg)算法,同理我们也有多源![image](https://cdn.nlark.com/yuque/__latex/40e0b9f3427d7c821289b81883ff5776.svg)算法

### 最长路
我们分情况考虑，如果图是一张![image](https://cdn.nlark.com/yuque/__latex/8bca7aa7adef4d08a4a69af78d62516c.svg),我们在![image](https://cdn.nlark.com/yuque/__latex/8bca7aa7adef4d08a4a69af78d62516c.svg)上拓扑排序朴素![image](https://cdn.nlark.com/yuque/__latex/cdaf04cddf57ae63edeafceb53eb4044.svg)即可，复杂度![image](https://cdn.nlark.com/yuque/__latex/fdf264192b783f02198831921a7e54b0.svg)

但如果是一张普通图，由于![image](https://cdn.nlark.com/yuque/__latex/4dc575314dfc9be173edc5e447b1d3c0.svg)的特性只能处理最短路，我们考虑用![image](https://cdn.nlark.com/yuque/__latex/7f70e3c74396083d6726a318a02b3028.svg)来解决这个问题,操作方法很简单，只需要边权取反跑最短路即可，如果存在负环，说明最长路无穷大,复杂度最坏![image](https://cdn.nlark.com/yuque/__latex/023710761254052f2b1fdef291bd2c43.svg)

## 生成树
生成树问题是在一个无向图![image](https://cdn.nlark.com/yuque/__latex/92232bff4c7103ad09227936b16c6ce8.svg)中找到![image](https://cdn.nlark.com/yuque/__latex/1bd41e6141bc9ddfb482ae500d0be6f7.svg)条边，并且这![image](https://cdn.nlark.com/yuque/__latex/1bd41e6141bc9ddfb482ae500d0be6f7.svg)条边满足联通这![image](https://cdn.nlark.com/yuque/__latex/9f493997c33913987175caf4a4849955.svg)个点，然后我们会得到一个树形结构称为生成树.常见问题有最小生成树，次小生成树等

### 最小生成树
我们来讨论最小生成树问题，有三种主流算法![image](https://cdn.nlark.com/yuque/__latex/f79b73a2ea1e95d66a115c7bb855dbc1.svg)

我们仍然分稠密图和稀疏图来考虑

在稀疏图中，![image](https://cdn.nlark.com/yuque/__latex/94c80859235655e6d9d246ad07cf53a1.svg)拥有![image](https://cdn.nlark.com/yuque/__latex/0d0481b29c5335e76648563b10b9eb3a.svg)的复杂度，相比于另外二者压倒式的好用。

其思想基于按边权排序，贪心的选,正确性显然

#### Kruskal
```cpp
template <class T>
struct Kruskal
{
    int n;
    int comp;
    DSU dsu;
    std::vector<std::array<int, 3>> g;

    Kruskal(int n) : n(n), dsu(n), comp(n) {}

    void addEdge(int u, int v, int w)
    {
        g.push_back({w, u, v});
    }

    T getMstWeight()
    {
        // 排序边，按照边的权重升序排序
        std::sort(g.begin(), g.end());

        T mstWeight = 0;
        for (auto &[w, u, v] : g)
        {
            if (!dsu.iscon(u, v))
            {
                dsu.merge(u, v);
                mstWeight += w;
                --comp;
            }
        }
        if (comp != 1)
        {
            return -1;
        }
        return mstWeight;
    }
};
```

在稠密图中,边权![image](https://cdn.nlark.com/yuque/__latex/8377449edd44d84f3384ba3e5c0e6233.svg)达到了![image](https://cdn.nlark.com/yuque/__latex/f2d5f588234eb61a559ff90c41511b85.svg)级别，我们就考虑使用堆优化的![image](https://cdn.nlark.com/yuque/__latex/7152d1ec71de5e42bc46d418662651f3.svg)算法，![image](https://cdn.nlark.com/yuque/__latex/7152d1ec71de5e42bc46d418662651f3.svg)算法类似于![image](https://cdn.nlark.com/yuque/__latex/4dc575314dfc9be173edc5e447b1d3c0.svg)算法，我们不断从堆中取出取出当前![image](https://cdn.nlark.com/yuque/__latex/786622fbcfaa0730fbd550d338948a5d.svg)最小的点更新答案，并遍历这个点的出边更新其他点的![image](https://cdn.nlark.com/yuque/__latex/786622fbcfaa0730fbd550d338948a5d.svg),朴素算法是![image](https://cdn.nlark.com/yuque/__latex/6db513571343f1b8952f12e02a6649aa.svg)的，我们用![image](https://cdn.nlark.com/yuque/__latex/f5e7401836f57f59370dbb9061a0be24.svg)中的配对堆做到![image](https://cdn.nlark.com/yuque/__latex/a2006f1ac61cb1902beacb3e29fff089.svg)修改![image](https://cdn.nlark.com/yuque/__latex/5766b36eb57b42893cecb2e481b8469c.svg)值，复杂度![image](https://cdn.nlark.com/yuque/__latex/d8ea71e4d11edc18df11215bd226e858.svg) 需要注意的是这里的![image](https://cdn.nlark.com/yuque/__latex/7b8c0c9f183cf83d1ead7a3daaee56b1.svg)表示![image](https://cdn.nlark.com/yuque/__latex/77c3adce895348f6083c425fe1ba2624.svg)点到已经选定的点的最小距离

![image](https://cdn.nlark.com/yuque/__latex/7152d1ec71de5e42bc46d418662651f3.svg)算法的正确性显然，相当于我们从任意一点开始，不断选最小的边开枝散叶，直至结束为止.

#### Prim
```cpp
struct PrimMST
{
    const int INF = 1e9;                             // 定义无穷大常量
    int n;                                           // 顶点数量(下标从1开始)
    std::vector<std::vector<std::pair<int, int>>> g; // 邻接表存储图

    // 构造函数，初始化顶点数量
    PrimMST(int n) : n(n), g(n + 1) {}

    // 添加无向边
    void addEdge(int u, int v, int w)
    {
        g[u].emplace_back(v, w);
        g[v].emplace_back(u, w);
    }

    // 执行Prim算法，返回最小生成树权值和，无法构成返回-1
    int compute()
    {
        int Sum = 0;
        int Num = 0;

        // 定义配对堆类型，存储(距离, 顶点)对，使用小根堆
        using PairingHeap = __gnu_pbds::priority_queue<
            std::pair<int, int>,
            std::greater<std::pair<int, int>>,
            __gnu_pbds::pairing_heap_tag>;

        PairingHeap pq;
        std::vector<PairingHeap::point_iterator> handlers(n + 1);

        // 初始化优先队列，所有节点距离设为INF，起点距离为0
        handlers[1] = pq.push({0, 1});
        for (int i = 2; i <= n; ++i)
        {
            handlers[i] = pq.push({INF, i});
        }

        while (!pq.empty())
        {
            auto [dist, u] = pq.top();
            pq.pop();

            if (dist == INF)
            {
                return -1; // 存在不连通节点
            }

            Sum += dist;
            Num++;
            handlers[u] = nullptr; // 标记已处理

            // 遍历邻接节点
            for (const auto &[v, w] : g[u])
            {
                if (handlers[v] != nullptr && w < handlers[v]->first)
                {
                    pq.modify(handlers[v], {w, v});
                }
            }
        }

        return (Num == n) ? Sum : -1;
    }
};
```

我们还有第三种![image](https://cdn.nlark.com/yuque/__latex/67ca15b1b4ac65f7bcb0c3250083057b.svg)算法![image](https://cdn.nlark.com/yuque/__latex/927d90b3c07c576fc90fb26d94eeb5f7.svg)，适用于其他特殊情况，在特殊条件下也十分好用

其核心思想是减少联通块的个数，我们每次遍历所有边![image](https://cdn.nlark.com/yuque/__latex/8ab4e50c20d37aabf90503557085f344.svg)如果![image](https://cdn.nlark.com/yuque/__latex/77c3adce895348f6083c425fe1ba2624.svg)和![image](https://cdn.nlark.com/yuque/__latex/a770a282bbfa0ae1ec474b7ed311656d.svg)不在同一联通块内,就用![image](https://cdn.nlark.com/yuque/__latex/c9b08ae6d9fed72562880f75720531bc.svg)更新两个联通块之间的最小边,然后每次我们将这些边加入答案，并合并连通块。不难发现每次连通块个数减少一半,复杂度![image](https://cdn.nlark.com/yuque/__latex/a2641bd48f794d1791bafd3f43b013a8.svg) 

常规题目我们一般不考虑此算法，但在某些题目中,两点间的边权由特定关系决定，如果我们能快速得到最小边，就会考虑采用![image](https://cdn.nlark.com/yuque/__latex/927d90b3c07c576fc90fb26d94eeb5f7.svg)算法了

#### Boruvka
```cpp
template <class T>
struct BoruvkaMST
{
    int n;                                           // 顶点数量(下标从1开始)
    int comp;                                        // 当前连通块数量
    std::vector<std::vector<std::pair<int, int>>> g; // 邻接表存储图
    DSU dsu;                                         // 并查集结构

    // 构造函数，初始化顶点数量和并查集
    BoruvkaMST(int n) : n(n), comp(n), dsu(n + 1), g(n + 1) {}

    // 添加无向边
    void addEdge(int u, int v, int w)
    {
        g[u].emplace_back(v, w);
        g[v].emplace_back(u, w);
    }

    // 执行Borůvka算法，返回最小生成树权值和，无法构成返回-1
    T compute()
    {
        constexpr T inf = std::numeric_limits<T>::max() / 2;
        T totalWeight = 0;
        bool hasChanges = true;

        while (hasChanges && comp > 1)
        {
            hasChanges = false;
            std::vector<T> min(n + 1, inf);   // 当前连通块的最小边权值
            std::vector<int> match(n + 1, 0); // 最小边对应的相邻连通块

            // 第一步：寻找每个连通块的最小出边
            for (int u = 1; u <= n; ++u)
            {
                int rootU = dsu.root(u);
                for (const auto &[v, w] : g[u])
                {
                    int rootV = dsu.root(v);
                    if (rootU != rootV && w < min[rootU])
                    {
                        min[rootU] = w;
                        match[rootU] = rootV;
                    }
                }
            }

            // 第二步：合并连通块
            for (int u = 1; u <= n; ++u)
            {
                if (match[u] != 0)
                {
                    int rootU = dsu.root(u);
                    int rootV = dsu.root(match[u]);
                    if (rootU != rootV)
                    {
                        dsu.merge(rootU, rootV);
                        totalWeight += min[u];
                        --comp;
                        hasChanges = true;
                    }
                }
            }
        }
        return comp == 1 ? totalWeight : -1;
    }
};
```

### 生成树计数
对于常规的生成树计数，我们可以通过矩阵树定理求解，代码模板在组合数学中的生成树计数中。

#### 最小生成树计数
考虑kruskal算法配合矩阵树定理，我们在对边排序以后，依次考虑每一组权值相同的边，对于这一组的边，我们知道最终连完之后的连通性是相同的,无论其顺序如何，也就是说联通块的情况是相同的，我们将这一组的所有边全部连接，对每个联通块都跑矩阵树定理，并把每个联通块得到的答案相乘，之后将每个联通块都缩成一个点，然后考虑下一组边，直至只剩一个联通块即可,正确性是显然的

### 最小度限制生成树
题目形如求一个图的![image](https://cdn.nlark.com/yuque/__latex/67ca15b1b4ac65f7bcb0c3250083057b.svg)，但需要满足点![image](https://cdn.nlark.com/yuque/__latex/e3bc9311145a2c1e0e863bd79c060bc7.svg)，我们不难发现这个问题具有凸完全单调性，我们可以通过朴素的![image](https://cdn.nlark.com/yuque/__latex/aec00776e59995548ce31665f7636bb9.svg)二分在![image](https://cdn.nlark.com/yuque/__latex/9fa3c296fb07f02fa248075b3da760c7.svg)的时间内解决

### 曼哈顿最小生成树
考虑平面上有![image](https://cdn.nlark.com/yuque/__latex/df378375e7693bdcf9535661c023c02e.svg)个二维数点，定义两点间距离为曼哈顿距离![image](https://cdn.nlark.com/yuque/__latex/4377f1eb5689050132b716241c297957.svg)，求最小生成树

通过对绝对值的拆分，最终该距离去掉绝对值符号仅有四种可能

![image](https://cdn.nlark.com/yuque/__latex/4e10e1c49273b89f33f34e8abea35cce.svg) 或![image](https://cdn.nlark.com/yuque/__latex/a12761218816264d5a5a033011ac8372.svg)

![image](https://cdn.nlark.com/yuque/__latex/638d0d35a0027e5da95b8e042c647198.svg)或![image](https://cdn.nlark.com/yuque/__latex/9fa937340cd62524744e1dfc37ac175b.svg)

<font style="color:rgba(0, 0, 0, 0.85);">这一变形的关键意义在于：</font><font style="color:rgb(0, 0, 0) !important;">曼哈顿距离可以表示为点在 4 个 “变换坐标系” 下的投影差值</font>

<font style="color:rgb(0, 0, 0) !important;">在每种变换坐标系中，每个点都能找到离自己最近的几个候选点作为可能的边。细节不过多阐述</font>

```cpp
#include <bits/stdc++.h>
using ll = long long;
const int N = 200010; 
int n, m, i, j, w[N], c[N], bit[N], f[N];
ll ans;
struct P
{
    int x, y, p;
    P() {}
    P(int _x, int _y, int _p) { x = _x, y = _y, p = _p; }
} a[N], b[N], e[N << 2];

bool cmp(const P &a, const P &b)
{
    return a.x == b.x ? a.y < b.y : a.x < b.x;
}
bool cmpe(const P &a, const P &b)
{
    return a.p < b.p;
}
int lower(int x)
{
    int l = 1, r = n, t, mid;
    while (l <= r)
    {
        mid = (l + r) >> 1;
        if (c[mid] <= x)
        {
            l = (t = mid) + 1;
        }
        else
        {
            r = mid - 1;
        }
    }
    return t;
}
int dis(int x, int y)
{
    return std::abs(a[x].x - a[y].x) + std::abs(a[x].y - a[y].y);
}
void ins(int x, int p)
{
    for (; x <= n; x += x & -x)
    {
        if (w[p] <= w[bit[x]])
        {
            bit[x] = p;
        }
    }
}
int ask(int x)
{
    int t = 0;
    for (; x; x -= x & -x)
    {
        if (w[bit[x]] <= w[t])
        {
            t = bit[x];
        }
    }
    return t;
}

int F(int x)
{
    return f[x] == x ? x : f[x] = F(f[x]);
}
void solve()
{
    for (sort(b + 1, b + n + 1, cmp), sort(c + 1, c + n + 1), i = 1; i <= n; i++)
    {
        if (j = ask(lower(b[i].y)))
        {
            e[++m] = P(b[i].p, j, dis(b[i].p, j));
        }
        ins(lower(b[i].y), b[i].p);
    }
}
std::vector<std::pair<int, int>> res;
ll ManhattanMst()
{
    for (w[0] = ~0U >> 1, m = ans = 0, i = 1; i <= n; i++)
    {
        f[i] = i;
    }
    for (i = 1; i <= n; i++)
    {
        b[i] = P(-a[i].x, a[i].x - a[i].y, i);
        c[i] = b[i].y;
        w[i] = a[i].x + a[i].y;
        bit[i] = 0;
    }
    solve();
    for (i = 1; i <= n; i++)
    {
        b[i] = P(-a[i].y, a[i].y - a[i].x, i);
        c[i] = b[i].y;
        bit[i] = 0;
    }
    solve();
    for (i = 1; i <= n; i++)
    {
        b[i] = P(a[i].y, -a[i].x - a[i].y, i);
        c[i] = b[i].y;
        w[i] = a[i].x - a[i].y;
        bit[i] = 0;
    }
    solve();
    for (i = 1; i <= n; i++)
    {
        b[i] = P(-a[i].x, a[i].y + a[i].x, i);
        c[i] = b[i].y;
        bit[i] = 0;
    }
    solve();
    sort(e + 1, e + m + 1, cmpe);
    for (ans = 0, i = 1; i <= m; i++)
    {
        if (F(e[i].x) != F(e[i].y))
        {
            res.push_back({e[i].x, e[i].y});
            f[f[e[i].x]] = f[e[i].y];
            ans += e[i].p;
        }
    }
    return ans;
}
int main()
{
    std::ios::sync_with_stdio(0);
    std::cin.tie(0);
    std::cin >> n;
    for (i = 1; i <= n; i++)
    {
        std::cin >> a[i].x >> a[i].y;
    }
    std::cout << ManhattanMst() << '\n';
    for (auto [x, y] : res)
    {
        std::cout << x << ' ' << y << '\n';
    }
    return 0;
}
```

### 最小直径生成树
首先我们有结论，一个无向图的最小直径生成树即以该图的绝对中心为起点跑出的最短路树

因此我们首先的问题在于找到图的绝对中心（该点到图上所有点的最远距离最小）

问题在于图的绝对中心可能在点也可能在边上，我们需要分别讨论这两种情况

具体过程如下：

![image](https://cdn.nlark.com/yuque/__latex/53072c2388d69edc65c2377681e4e87c.svg)使用多源最短路求出任意两点间最短路

![image](https://cdn.nlark.com/yuque/__latex/2b89979f54ec02a7bf87aa0c1ea58ff9.svg)求出![image](https://cdn.nlark.com/yuque/__latex/9907b851879b80600db84de61c622e78.svg)表示离![image](https://cdn.nlark.com/yuque/__latex/2443fbcfeb7e85e1d62b6f5e4f27207e.svg)点第![image](https://cdn.nlark.com/yuque/__latex/036441a335dd85c838f76d63a3db2363.svg)近的点是谁

![image](https://cdn.nlark.com/yuque/__latex/a7720a85557fdd660de5e2da1dfa7c07.svg)我们考虑中心在某个节点的情况，暴力遍历更新答案即可

![image](https://cdn.nlark.com/yuque/__latex/afb0613a26341d701b3967ba170aa30c.svg)我们考虑中心在边上的情况，我们不妨设![image](https://cdn.nlark.com/yuque/__latex/b6c262a1ae972f9d5c381d97ef1bf515.svg)为直径，那么我们枚举所有的边![image](https://cdn.nlark.com/yuque/__latex/5ff46176e95d9c7377e0735ed5f37692.svg)，如果出现![image](https://cdn.nlark.com/yuque/__latex/490a374c29e71c5fd83520ccf0cd5600.svg),我们用![image](https://cdn.nlark.com/yuque/__latex/348c5718d86cccc36ca3a1322975fb0d.svg)更新答案。

复杂度为![image](https://cdn.nlark.com/yuque/__latex/c5c89d603ba2a1d24ec9c8d9e69aced3.svg)，具体看使用什么算法求全源最短路

```cpp
// 比较函数：用于对节点按距离进行排序
// 功能：当val[a] < val[b]时，a的排名在b之前（升序排序）
// 参数：a, b为待比较的节点编号
bool cmp(int a, int b)
{
    return val[a] < val[b];
}

// Floyd-Warshall算法：求解图中所有节点对之间的最短路径
// 时间复杂度O(n³)，适用于节点数n不太大的情况
void Floyd()
{
    // k为中间节点：枚举所有可能的中转节点
    for (int k = 1; k <= n; k++)
        // i为起点：枚举所有可能的起点
        for (int i = 1; i <= n; i++)
            // j为终点：枚举所有可能的终点
            for (int j = 1; j <= n; j++)
                // 松弛操作：通过k中转是否能缩短i到j的距离
                d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
}
void solve()
{
    // 第一步：先计算所有节点对的最短路径
    Floyd();

    // 第二步：对每个节点i，将其他节点按到i的距离排序
    for (int i = 1; i <= n; i++)
    {
        for (int j = 1; j <= n; j++)
        {
            rk[i][j] = j;
            val[j] = d[i][j];
        }
        sort(rk[i] + 1, rk[i] + 1 + n, cmp);
    }

    // 第三步：初始化答案
    // 修正1：将ans的类型从int改为double，以精确存储半径
    double ans = 1e9;

    // 记录绝对中心位置的变量
    bool ok = true;
    int idx = -1;
    int au = -1, av = -1;
    double t = 0.0;
    // 情况1：绝对中心在某个节点上
    for (int i = 1; i <= n; i++)
    {
        int dis = d[i][rk[i][n]];
        if (dis < ans)
        {
            ok = true;
            ans = dis; // 将半径存入ans
            idx = i;
        }
    }
    // 情况2：绝对中心在某条边上（u-v，权重为w）
    for (int i = 1; i <= m; i++)
    {
        int u = a[i].u;
        int v = a[i].v;
        int w = a[i].w;

        for (int p = n, j = n - 1; j >= 1; j--)
        {
            // 这个双指针优化的逻辑是：对于每个j，找到一个p，使得(j, p)这对最远点构成的半径最小。
            // p需要指向从j到n的节点中，距离v最远的那个。
            // 首先更新p，使其成为从当前j到n的范围内离v最远的点
            if (d[v][rk[u][j]] > d[v][rk[u][p]])
            {
                p = j;
            }

            // 然后用当前的j和最优的p来计算路径长度
            int cur = d[u][rk[u][j]] + d[v][rk[u][p]] + w;

            // 修正2：用计算出的新半径(cur/2.0)与ans(最小半径)进行比较
            if (cur / 2.0 < ans)
            {
                // 修正3：ans存储的应该是半径，而不是路径长度
                ans = cur / 2.0;
                ok = false;
                au = u;
                av = v;
                t = (d[v][rk[u][p]] + w - d[u][rk[u][j]]) / 2.0;
                if (t < 0)
                    t = 0;
                if (t > w)
                    t = w;
            }
        }
    }
}
```

### 动态MST问题
![image](https://cdn.nlark.com/yuque/__latex/efc541079b45080327affad8793c1d7f.svg)是维护动态![image](https://cdn.nlark.com/yuque/__latex/67ca15b1b4ac65f7bcb0c3250083057b.svg)的利器，在原有的![image](https://cdn.nlark.com/yuque/__latex/9e5992eb8d8524b1796188b4bb135502.svg)上，如果我们想要再加一条边![image](https://cdn.nlark.com/yuque/__latex/8ab4e50c20d37aabf90503557085f344.svg)，，我们只需要利用![image](https://cdn.nlark.com/yuque/__latex/efc541079b45080327affad8793c1d7f.svg)找到链![image](https://cdn.nlark.com/yuque/__latex/838c98c94a4322ee88230f6f92e2ac73.svg)中最大边权的值![image](https://cdn.nlark.com/yuque/__latex/7ec0e55317309c7e20cc38e2d3d48a5b.svg)和位置，如果有![image](https://cdn.nlark.com/yuque/__latex/43ce468bb8dc8a8f5931e54dfcc05098.svg),我们把原先的边断开，链接新边即可,否则跳过这条边.

#### 次小生成树
严格次小生成树和非严格次小生成树没有做法上的区别，都是![image](https://cdn.nlark.com/yuque/__latex/28f26e920f683bf3930be1e1f302f9da.svg)维护生成树的裸题，只需要把非生成树边不断尝试即可

### kruskal重构树
用于瓶颈路相关问题，可以在![image](https://cdn.nlark.com/yuque/__latex/ff4edff51773a4560f25e8eab96349ff.svg)时间内求出图上两点之间最大最小边权问题。但重构树并不一定只能维护边权,例如，我们可以把边出现的时间当作边权维护，从而达到维护连通性的效果，我们适当的把其他元素转化为边权能起到很好的效果.

```cpp
class KruskalTree
{
private:
    DSU dsu;
    std::vector<int> lc, rc, val;
    int idx;
    std::vector<std::vector<int>> fa;
    std::vector<int> dep;
    int lg;

public:
    // 构造函数，初始化并构建重构树
    KruskalTree(const std::vector<std::array<int, 3>> &g, int n)
        : lc(2 * n + 1),
          rc(2 * n + 1),
          val(2 * n + 1),
          idx(n),
          dsu(2 * n),
          dep(2 * n + 1)
    {

        // 计算二进制提升的最大层数
        lg = std::__lg(2 * n + 1);
        fa.assign(2 * n + 1, std::vector<int>(lg + 1, 0));

        // 按边权从大到小排序
        auto e = g;
        std::sort(e.begin(), e.end(),
                  [](const auto &a, const auto &b)
                  { return a[2] < b[2]; });

        // 构建Kruskal重构树
        for (const auto &[u, v, w] : e)
        {
            if (dsu.root(u) != dsu.root(v))
            {
                ++idx;
                int rootU = dsu.root(u);
                int rootV = dsu.root(v);
                lc[idx] = rootU;
                rc[idx] = rootV;
                dsu.pre[rootU] = idx;
                dsu.pre[rootV] = idx;
                val[idx] = w;
            }
            if (idx == 2 * n - 1)
            {
                break;
            }
        }

        // DFS预处理二进制提升表
        auto dfs = [&](auto &&self, int u, int parent) -> void
        {
            fa[u][0] = parent;
            for (int i = 1; i <= lg; ++i)
            {
                fa[u][i] = fa[fa[u][i - 1]][i - 1];
            }
            if (lc[u])
            {
                dep[lc[u]] = dep[u] + 1;
                self(self, lc[u], u);
            }
            if (rc[u])
            {
                dep[rc[u]] = dep[u] + 1;
                self(self, rc[u], u);
            }
        };

        // 从根节点开始DFS
        for (int i = idx; i >= 1; --i)
        {
            if (!dep[i])
            {
                dep[i] = 1;
                dfs(dfs, i, 0);
            }
        }
    }

    // 查询两个节点的最近公共祖先
    int getLca(int u, int v) const
    {
        if (dep[u] < dep[v])
        {
            std::swap(u, v);
        }
        // 提升u到与v相同深度
        for (int i = lg; i >= 0; --i)
        {
            if (dep[fa[u][i]] >= dep[v])
            {
                u = fa[u][i];
            }
        }
        if (u == v)
        {
            return u;
        }
        // 同时提升u和v
        for (int i = lg; i >= 0; --i)
        {
            if (fa[u][i] != fa[v][i])
            {
                u = fa[u][i];
                v = fa[v][i];
            }
        }
        return fa[u][0];
    }
    int getVal(int x)
    {
        return val[x];
    }
    bool isConnected(int u, int v)
    {
        return dsu.root(u) == dsu.root(v);
    }
};
```

### 最小斯坦纳树
从某种程度上讲斯坦纳树也是生成树的一种，只不过是一个关键点集的生成树，而不是对于所有节点。

问题形如，给你一个无向带权图![image](https://cdn.nlark.com/yuque/__latex/92232bff4c7103ad09227936b16c6ce8.svg),并且给你![image](https://cdn.nlark.com/yuque/__latex/6a6b811a2879516d7418f3d7325a142d.svg)个关键点，求一个边集![image](https://cdn.nlark.com/yuque/__latex/321138a59e6eab0c97c21f05282a80a6.svg)使得![image](https://cdn.nlark.com/yuque/__latex/df976ff7fcf17d60490267d18a1e3996.svg)个关键点联通且代价最小，显然最终形态应该是一棵树,但不保证只包含这![image](https://cdn.nlark.com/yuque/__latex/df976ff7fcf17d60490267d18a1e3996.svg)个节点

我们利用状压![image](https://cdn.nlark.com/yuque/__latex/cdaf04cddf57ae63edeafceb53eb4044.svg)解决这个问题,由于![image](https://cdn.nlark.com/yuque/__latex/6a6b811a2879516d7418f3d7325a142d.svg)的数据范围为![image](https://cdn.nlark.com/yuque/__latex/134c802fc5f0924cf1ea838feeca6c5e.svg),我们状压关键点的状态,设![image](https://cdn.nlark.com/yuque/__latex/8c5ee8f62764459367f818b4203a216c.svg)为以![image](https://cdn.nlark.com/yuque/__latex/1630b971d5658f77276568421cf21468.svg)为根,联通点状态为![image](https://cdn.nlark.com/yuque/__latex/6324f23d93cdd09e334e2b373a2a137e.svg)的最小代价，利用最短路+枚举子集![image](https://cdn.nlark.com/yuque/__latex/cdaf04cddf57ae63edeafceb53eb4044.svg)更新状态，复杂度![image](https://cdn.nlark.com/yuque/__latex/13befb2d5151bcfe1b9e84a644255076.svg)

```cpp
/**
 * @class SteinerTreeSolver
 * @brief 求解无向图中连接指定关键点的最小斯坦纳树问题
 *
 * @details
 * 使用动态规划结合SPFA松弛的方法求解最小斯坦纳树问题
 * - 节点编号从1开始
 * - 关键点存储在数组中下标从0开始
 * - 时间复杂度: O(n * 3^k + m * 2^k * log n)
 */
template <class T>
class SteinerTreeSolver
{
public:
    using Edge = std::tuple<int, int, int>; // (u, v, weight)
    const T inf = std::numeric_limits<T>::max() / 2;
    /**
     * @brief 构造函数
     * @param n 图中节点总数
     * @param e 图的边集合
     * @param key 关键点列表(下标从0开始)
     */
    SteinerTreeSolver(int n,
                      const std::vector<Edge> &e,
                      const std::vector<int> &key)
        : n(n),
          k(key.size()),
          key(key)
    {

        // 构建邻接表
        BuildGraph(e);
        // 初始化DP数组
        InitializeDP();
    }

    /**
     * @brief 计算最小斯坦纳树的权值和
     * @return 连接所有关键点的最小边权值和
     * @throws std::runtime_error 如果没有可行解
     */
    T ComputeMinSteinerTree()
    {
        // 动态规划处理所有状态
        for (int state = 0; state < (1 << k); ++state)
        {
            // 处理子集合并
            ProcessSubsetUnions(state);
            // 使用SPFA松弛当前状态
            RelaxWithSPFA(state);
        }

        // 在所有关键点都连通的状态中寻找最小值
        int fullMask = (1 << k) - 1;
        T minCost = inf;
        for (int u = 1; u <= n; ++u)
        {
            if (dp[u][fullMask] < minCost)
            {
                minCost = dp[u][fullMask];
            }
        }
        return minCost;
    }

private:
    int n;                                           // 节点总数
    int k;                                           // 关键点数量
    std::vector<int> key;                            // 关键点列表
    std::vector<std::vector<std::pair<int, int>>> g; // 邻接表
    std::vector<std::vector<T>> dp;                  // DP数组
    std::queue<int> q;                               // SPFA使用的队列
    std::vector<bool> inq;                           // SPFA标记数组

    /**
     * @brief 构建图的邻接表表示
     * @param e 图的边集合
     */
    void BuildGraph(const std::vector<Edge> &e)
    {
        g.resize(n + 1); // 节点编号从1开始

        for (const auto &[u, v, w] : e)
        {
            g[u].emplace_back(v, w);
            g[v].emplace_back(u, w); // 无向图
        }
    }

    /**
     * @brief 初始化DP数组
     */
    void InitializeDP()
    {
        // dp[i][s] 表示以i为根，连通状态为s的最小权值
        dp.resize(n + 1, std::vector<T>(1 << k, inf));

        // 初始化每个关键点单独连通的情况
        for (int i = 0; i < k; ++i)
        {
            dp[key[i]][1 << i] = 0;
        }

        // 初始化SPFA相关数据结构
        inq.resize(n + 1, false);
    }

    /**
     * @brief 处理状态子集的合并
     * @param state 当前状态掩码
     */
    void ProcessSubsetUnions(int state)
    {
        for (int u = 1; u <= n; ++u)
        {
            // 枚举state的所有非空子集subset
            for (int subset = state; subset > 0; subset = (subset - 1) & state)
            {
                // 避免整数溢出
                if (dp[u][subset] < inf &&
                    dp[u][state ^ subset] < inf)
                {
                    T newCost = dp[u][subset] + dp[u][state ^ subset];
                    if (newCost < dp[u][state])
                    {
                        dp[u][state] = newCost;
                    }
                }
            }

            // 如果当前节点的状态被更新，加入队列准备SPFA松弛
            if (dp[u][state] < inf)
            {
                q.push(u);
                inq[u] = true;
            }
        }
    }

    /**
     * @brief 使用SPFA算法松弛当前状态
     * @param state 当前状态掩码
     */
    void RelaxWithSPFA(int state)
    {
        while (!q.empty())
        {
            int u = q.front();
            q.pop();
            inq[u] = false;

            for (const auto &[v, weight] : g[u])
            {
                if (dp[u][state] < inf &&
                    dp[u][state] + weight < dp[v][state])
                {
                    dp[v][state] = dp[u][state] + weight;
                    if (!inq[v])
                    {
                        q.push(v);
                        inq[v] = true;
                    }
                }
            }
        }
    }
};
```

## 连通性
### 有向图连通性
我们只要研究强联通分量以及其应用，一个强连通分量内的点两两可达，强联通具有传递性。

#### 强连通分量
```cpp
class SCC
{
    const std::vector<std::vector<int>> &e; // 图的邻接表引用（输入图）
    std::vector<int> stk;                   // Tarjan算法使用的栈
    int tt = 0;                             // 栈顶指针
    int idx = 0;                            // 时间戳计数器

    // Tarjan算法的DFS核心实现
    void dfs(int x)
    {
        dfn[x] = low[x] = ++idx; // 初始化当前节点的dfn和low值
        stk[++tt] = x;           // 节点入栈

        // 遍历所有邻接节点
        for (int y : e[x])
        {
            if (!dfn[y]) // 未访问过的节点
            {
                dfs(y);                            // 递归搜索
                low[x] = std::min(low[x], low[y]); // 更新low值
            }
            else if (!bel[y]) // 已访问但未确定SCC的节点（在栈中）
            {
                low[x] = std::min(low[x], dfn[y]); // 更新low值
            }
        }

        // 发现SCC的根节点
        if (dfn[x] == low[x])
        {
            cntBlock += 1; // SCC计数器增加
            int y;
            do
            {
                y = stk[tt--];            // 弹出栈顶节点
                p[cntBlock].push_back(y); // 将节点加入当前SCC
                bel[y] = cntBlock;        // 标记节点所属SCC编号
            } while (y != x); // 直到处理到当前根节点
        }
    }

public:
    // 原始图的访问信息
    std::vector<int> dfn; // DFS访问序号（时间戳）
    std::vector<int> low; // 能回溯到的最早节点的时间戳
    std::vector<int> bel; // 节点所属的SCC编号

    // SCC相关数据
    std::vector<std::vector<int>> p; // 每个SCC包含的节点列表
    std::vector<std::vector<int>> g; // 缩点后的DAG图（邻接表）
    std::vector<int> din;            // 缩点后各节点的入度
    std::vector<int> siz;            // 各SCC的大小（节点数）
    int cntBlock = 0;                // SCC总数计数器

    // 构造函数：输入图的邻接表
    SCC(const std::vector<std::vector<int>> &e)
        : e(e),          // 初始化图引用
          dfn(e.size()), // 分配dfn数组空间
          low(e.size()), // 分配low数组空间
          bel(e.size()), // 分配bel数组空间
          p(e.size())    // 分配SCC节点列表空间
    {
        int n = e.size() - 1; // 节点数（假设节点从1开始编号）
        stk.assign(n + 1, 0); // 初始化栈

        // 对每个未访问节点执行Tarjan算法
        for (int i = 1; i <= n; i++)
        {
            if (!dfn[i]) // 未访问过的节点
            {
                dfs(i); // 开始DFS
            }
        }

        // 构建缩点后的DAG图
        g.resize(cntBlock + 1);   // 调整缩点图大小
        din.resize(cntBlock + 1); // 调整入度数组大小
        siz.resize(cntBlock + 1); // 调整SCC大小数组

        // 遍历原始图构建缩点图
        for (int x = 1; x <= n; x++)
        {
            siz[bel[x]]++;     // 统计各SCC大小
            for (int y : e[x]) // 遍历邻接节点
            {
                if (bel[x] == bel[y]) // 同一SCC内部边跳过
                {
                    continue;
                }
                g[bel[x]].push_back(bel[y]); // 添加缩点后的边
                din[bel[y]]++;               // 更新目标SCC的入度
            }
        }
    }
};
// 如果belong[u]<belong[v]且u v联通 那么缩点以后边的方向是v->u
```

#### 2-Sat
![image](https://cdn.nlark.com/yuque/__latex/6b10c3a7f34bd10373d32488b11e3009.svg)问题是给定你一些二元布尔表达式，我们要求出满足所有表达式的一个解，或者报告无解。

需要注意的是 如果一个变量恒成立 那么我们连边![image](https://cdn.nlark.com/yuque/__latex/4e573d3ba7daedcc60e2e356e5748bb4.svg)

相对应的，如果一个变量恒不成立,我们连边 ![image](https://cdn.nlark.com/yuque/__latex/ec3fb4beb88f8e696b14345c5daef421.svg)



如何判断无解？ 存在某个变量![image](https://cdn.nlark.com/yuque/__latex/d29c2e5f4926e5b0e9a95305650f6e54.svg)满足![image](https://cdn.nlark.com/yuque/__latex/d29c2e5f4926e5b0e9a95305650f6e54.svg)和![image](https://cdn.nlark.com/yuque/__latex/1070ba647421461e6b7e8655fc06650b.svg)在同一个![image](https://cdn.nlark.com/yuque/__latex/de803e8b8d362d6fff6c031d185a1b8a.svg)内



如何输出方案？对于![image](https://cdn.nlark.com/yuque/__latex/d29c2e5f4926e5b0e9a95305650f6e54.svg)和![image](https://cdn.nlark.com/yuque/__latex/1070ba647421461e6b7e8655fc06650b.svg)我们取拓扑序大的为真，那么在![image](https://cdn.nlark.com/yuque/__latex/de803e8b8d362d6fff6c031d185a1b8a.svg)中拓扑序越大的所在![image](https://cdn.nlark.com/yuque/__latex/de803e8b8d362d6fff6c031d185a1b8a.svg)编号越小，因此输出方案为![image](https://cdn.nlark.com/yuque/__latex/1c482108317516ce3d52c40dad09862d.svg)，

#### 支配树
![image](https://cdn.nlark.com/yuque/__latex/7d79a88ce407a93f450311fa7b3547b5.svg)为![image](https://cdn.nlark.com/yuque/__latex/2443fbcfeb7e85e1d62b6f5e4f27207e.svg)的直接支配点，在支配树上是![image](https://cdn.nlark.com/yuque/__latex/2443fbcfeb7e85e1d62b6f5e4f27207e.svg)的父节点，![image](https://cdn.nlark.com/yuque/__latex/47e1b9409826d58bd69ca84940d736a7.svg)是半支配点，除了辅助求支配点外无实际意义。支配树上一点的所有祖先都是该点的支配点。

```cpp
struct DominatorTree
{
    int n, r;
    std::vector<std::vector<int>> G, rG;  // 原图和反图
    std::vector<int> dfn, idfn, parent;   // dfn[u] = DFS序, idfn[i] = DFS序为i的节点, parent[u] = DFS树父节点
    std::vector<int> sdom, idom;          // 半支配点和直接支配点
    std::vector<int> fa, mn;              // 并查集结构
    std::vector<std::vector<int>> bucket; // 分组处理sdom

    DominatorTree(int n, int r) : n(n), r(r), G(n + 1), rG(n + 1) {}

    void addEdge(int u, int v)
    {
        G[u].push_back(v);
        rG[v].push_back(u); // 同时构建反图
    }

    void dfs(int u)
    {
        dfn[u] = idfn.size();
        idfn.push_back(u);
        for (int v : G[u])
        {
            if (!dfn[v])
            { // 未访问过
                parent[v] = u;
                dfs(v);
            }
        }
    }

    // 并查集：路径压缩 + 维护sdom最小值
    int find(int u)
    {
        if (fa[u] == u)
            return u;
        int root = find(fa[u]);
        if (dfn[sdom[mn[fa[u]]]] < dfn[sdom[mn[u]]])
        {
            mn[u] = mn[fa[u]]; // 更新最小值
        }
        return fa[u] = root; // 路径压缩
    }

    // 构建支配树，返回idom数组（idom[u] = u的直接支配点）
    std::vector<int> build()
    {
        // Step 1: 初始化
        dfn.assign(n + 1, 0);
        parent.assign(n + 1, 0);
        idfn.push_back(0); // 占位，使id[1..n]有效
        dfs(r);            // 从根节点开始DFS

        // Step 2: 初始化sdom和idom
        sdom.resize(n + 1);
        idom.resize(n + 1);
        for (int i = 1; i <= n; ++i)
        {
            sdom[i] = i;
            idom[i] = 0; // 初始化为0（无效值）
        }

        // Step 3: 并查集初始化
        fa.resize(n + 1);
        mn.resize(n + 1);
        for (int i = 1; i <= n; ++i)
        {
            fa[i] = mn[i] = i;
        }

        bucket.resize(n + 1);
        // Step 4: 按DFS序逆序处理（从大到小）
        for (int i = (int)idfn.size() - 1; i >= 2; --i)
        { // 跳过根节点（i=1）
            int u = idfn[i];

            // Step 4.1: 计算sdom[u]
            for (int v : rG[u])
            { // 遍历反图（即原图的前驱）
                if (!dfn[v])
                    continue; // 跳过不可达节点
                if (dfn[v] < dfn[u])
                {
                    sdom[u] = dfn[v] < dfn[sdom[u]] ? v : sdom[u];
                }
                else
                {
                    find(v); // 路径压缩
                    sdom[u] = dfn[sdom[mn[v]]] < dfn[sdom[u]] ? sdom[mn[v]] : sdom[u];
                }
            }
            bucket[sdom[u]].push_back(u);

            // Step 4.2: 合并到父节点
            if (parent[u])
            {
                merge(parent[u], u);
            }

            // Step 4.3: 处理bucket中的节点
            for (int v : bucket[parent[u]])
            {
                find(v);
                if (sdom[mn[v]] == parent[u])
                {
                    idom[v] = parent[u];
                }
                else
                {
                    idom[v] = mn[v]; // 暂时存储，后续修正
                }
            }
            bucket[parent[u]].clear();
        }

        // Step 5: 修正idom
        for (int i = 2; i < idfn.size(); ++i)
        { // 跳过根节点（i=1）
            int u = idfn[i];
            if (idom[u] != sdom[u])
            {
                idom[u] = idom[idom[u]];
            }
        }
        // 根节点的idom设为0（表示无支配点）
        idom[r] = 0;
        return idom;
    }

private:
    // 并查集合并操作
    void merge(int u, int v)
    {
        fa[v] = u;
    }
};
```

### 无向图连通性
我们主要研究点双连通分量和边双连通分量，前者对应割点，后者对应割边，割边又称桥

特别的，孤立点和孤立边的两个端点都不是割点，但孤立边是割边



我们有如下结论

![image](https://cdn.nlark.com/yuque/__latex/53072c2388d69edc65c2377681e4e87c.svg)对于![image](https://cdn.nlark.com/yuque/__latex/838c98c94a4322ee88230f6f92e2ac73.svg)两点间任意一条简单路径，其路径上的割边就是两点间的所有必经边，所以割边也可以看做必经边

![image](https://cdn.nlark.com/yuque/__latex/2b89979f54ec02a7bf87aa0c1ea58ff9.svg)对于两个点双联通分量，如果二者有公共点，那么该点一定是割点，反过来讲，该点是割点当且仅当它属于两个以上点双

![image](https://cdn.nlark.com/yuque/__latex/a7720a85557fdd660de5e2da1dfa7c07.svg)边双具有传递性，但点双不具有传递性

![image](https://cdn.nlark.com/yuque/__latex/afb0613a26341d701b3967ba170aa30c.svg)如果两个点属于一个点双，那么这两点之间所有简单路径的并集恰好完全等于该点双



对于边双，我们可以通过缩点进一步刻画其连通性，但是点双的形态不适用于缩点，我们用广义圆方树刻画

#### 点双连通分量
在模板中我们有一个割度数组![image](https://cdn.nlark.com/yuque/__latex/c4adcde1c9e92089f5992aec745fac9f.svg)，割度表示删去该点后增加的联通分量数。割度不为![image](https://cdn.nlark.com/yuque/__latex/22d0feea96d3bb2fc273f7598ce748c1.svg)的点均为割点。

```cpp
// 用于计算图的顶点双连通分量和割点（关节点）的类
class VertexBC
{
    // 图的邻接表引用（const引用避免拷贝）
    const std::vector<std::vector<int>> &adj;
    // DFS时间戳计数器，用于记录访问顺序
    int cur = 0;

    // DFS遍历函数，用于发现割点
    // x: 当前遍历的顶点
    // root: 当前连通分量的根节点
    void dfs(int x, int root)
    {
        // 初始化当前顶点的发现时间和low值
        dfn[x] = low[x] = cur++;

        // 记录在DFS树中的子节点数量
        int sonNum = 0;

        // 遍历所有邻接顶点
        for (int y : adj[x])
        {
            if (dfn[y] == -1) // 如果邻接顶点未被访问过
            {
                sonNum++;     // 增加子节点计数
                dfs(y, root); // 递归访问
                // 回溯时更新low值
                low[x] = std::min(low[x], low[y]);

                // 割点判定条件：
                // 1. 子节点的low值 >= 当前节点的dfn值
                // 2. 当前节点不是根节点
                if (low[y] >= dfn[x] && x != root)
                {
                    cutDeg[x] += 1; // 增加当前节点的割点度数
                }
            }
            else // 如果邻接顶点已被访问过（可能是回边）
            {
                // 通过回边更新low值
                low[x] = std::min(low[x], dfn[y]);
            }
        }

        // 特殊处理根节点的情况
        if (x == root)
        {
            // 根节点的割点度数 = 子树数量 - 1
            cutDeg[x] = std::max(sonNum - 1, 0);
        }
    }

public:
    // 存储每个顶点的发现时间（DFS序）
    std::vector<int> dfn;
    // 存储每个顶点的low值（能回溯到的最早祖先）
    std::vector<int> low;
    // 存储每个顶点作为割点时的度数（删除后会增加的连通分量数）
    std::vector<int> cutDeg;
    // 记录图的连通分量数量
    int componentNum = 0;

    // 构造函数，接收邻接表并计算割点信息
    VertexBC(const std::vector<std::vector<int>> &adj)
        : adj(adj),            // 初始化邻接表引用
          dfn(adj.size(), -1), // 初始化dfn数组（-1表示未访问）
          low(adj.size()),     // 初始化low数组
          cutDeg(adj.size())   // 初始化割点度数数组
    {
        int n = adj.size();

        // 遍历所有顶点（从1开始，假设顶点编号为1~n-1）
        for (int i = 1; i < n; i++)
        {
            if (dfn[i] == -1) // 遇到未访问的顶点
            {
                componentNum++; // 增加连通分量计数
                dfs(i, i);      // 从该顶点开始DFS
            }
        }
    }
};

```

广义圆方树有十分多好的性质，我们单独讨论

![image](https://cdn.nlark.com/yuque/__latex/53072c2388d69edc65c2377681e4e87c.svg)广义圆方树上没有两个邻点形状相同

![image](https://cdn.nlark.com/yuque/__latex/2b89979f54ec02a7bf87aa0c1ea58ff9.svg)两个圆点在圆方树上的路径，以及经过的所有方点相邻圆点的集合，等于原图中两点间所有简单路径的并集

![image](https://cdn.nlark.com/yuque/__latex/a7720a85557fdd660de5e2da1dfa7c07.svg)根据![image](https://cdn.nlark.com/yuque/__latex/2b89979f54ec02a7bf87aa0c1ea58ff9.svg)的结论，如果我们圆点赋值![image](https://cdn.nlark.com/yuque/__latex/f5c91774886192157cf2ef03c17dcfc2.svg)，方点赋值点双大小,那么路径权值和等于简单路径并集大小![image](https://cdn.nlark.com/yuque/__latex/a90a96499bb8a41d2cf42a347aae12de.svg)

#### 广义圆方树
```cpp
class ExRSTree
{
    const std::vector<std::vector<int>> &adj; // 原始图的邻接表
    int cur = 0;                              // DFS时间戳计数器
    std::vector<int> stk;                     // 用于Tarjan算法的栈
    int tt = 0;                               // 栈顶指针

    // 在圆方树中添加边的辅助函数
    void add(int u, int v)
    {
        tree[u].push_back(v);
        tree[v].push_back(u);
    }

    // Tarjan算法实现，用于构建圆方树
    // x: 当前遍历的顶点
    // root: 当前连通分量的根节点
    void dfs(int x, int root)
    {
        dfn[x] = low[x] = cur++; // 初始化发现时间和low值
        stk[++tt] = x;           // 将当前节点压栈

        int sonNum = 0; // DFS树中子节点计数

        for (int y : adj[x]) // 遍历所有邻接节点
        {
            if (dfn[y] == -1) // 未访问过的节点
            {
                sonNum += 1;
                dfs(y, root);
                low[x] = std::min(low[x], low[y]); // 更新low值

                // 发现割点条件
                if (low[y] >= dfn[x])
                {
                    ++cnt; // 新增一个方点

                    // 弹出栈中元素直到遇到y，构建点双连通分量
                    while (stk[tt] != y)
                    {
                        Size[cnt]++;         // 更新点双大小
                        add(cnt, stk[tt--]); // 将圆点连接到方点
                    }

                    // 处理剩余部分
                    add(cnt, stk[tt--]); // 连接y到方点
                    add(cnt, x);         // 连接当前割点到方点
                    Size[cnt] += 2;      // 更新点双大小（加上x和y）
                }
            }
            else
            {
                low[x] = std::min(low[x], dfn[y]); // 遇到已访问节点，更新low值
            }
        }
    }

    // 第二次DFS，计算子树大小和所属根节点
    // u: 当前节点
    // fa: 父节点
    // r: 所属连通分量的根节点
    void dfs1(int u, int fa, int r)
    {
        if (u <= n) // 如果是圆点（原始节点）
        {
            siz[u] = 1; // 初始化大小为1
        }

        bel[u] = r; // 记录所属根节点

        for (auto v : tree[u]) // 遍历圆方树中的邻接节点
        {
            if (v != fa) // 避免回溯父节点
            {
                dfs1(v, u, r);
                siz[u] += siz[v]; // 累加子树大小
            }
        }
    }

public:
    // original graph
    int n;                              // 原始图的顶点数
    int cnt;                            // 圆方树中的节点计数器（圆点+方点）
    std::vector<int> dfn, low;          // Tarjan算法用的发现时间和low值
    std::vector<std::vector<int>> tree; // 圆方树
    int componentNum = 0;               // 连通分量数量
    std::vector<int> root;              // 所有圆方树的根节点
    std::vector<int> bel;               // 节点所属的圆方树根节点
    std::vector<int> siz;               // 子树大小
                                        // 在圆方树中，一个圆点的割度为度数-1
    std::vector<int> Size;              // 点双连通分量的大小

    // 构造函数：从原始图构建圆方树
    ExRSTree(const std::vector<std::vector<int>> &adj)
        : adj(adj),
          n(adj.size() - 1), // 假设顶点编号从1开始
          dfn(n + 1, -1),    // 初始化dfn数组
          low(n + 1),        // 初始化low数组
          tree(2 * n + 1),   // 圆方树最多有2n个节点（n圆点+n方点）
          bel(2 * n + 1),    // 所属根节点数组
          siz(2 * n + 1)     // 子树大小数组
    {
        Size.assign(2 * n + 1, 0); // 初始化点双大小数组
        stk.assign(n + 1, 0);      // 初始化Tarjan栈
        cnt = n;                   // 方点从n+1开始编号

        // 遍历所有顶点构建圆方树
        for (int i = 1; i <= n; i++)
        {
            if (dfn[i] == -1) // 未访问过的顶点
            {
                root.push_back(i); // 记录根节点
                componentNum += 1; // 增加连通分量计数
                dfs(i, i);         // 第一次DFS构建圆方树
                dfs1(i, i, i);     // 第二次DFS计算子树信息
            }
        }
    }
};
```

#### 边双连通分量
```cpp
class EdgeBC
{
    // 输入的无向图的邻接表（引用，避免拷贝）
    const std::vector<std::vector<int>> &e;
    
    // Tarjan算法用的栈
    std::vector<int> stk; // stack
    int tt = 0;           // 栈顶指针
    int cur = 0;          // 全局时间戳，用于dfn和low的标记

    // Tarjan算法求边双连通分量（EBCC）
    void dfs(int x, int fa)
    {
        // 初始化当前节点的dfn和low值为当前时间戳
        dfn[x] = low[x] = ++cur;
        // 将当前节点压入栈
        stk[++tt] = x;

        // 遍历所有邻接节点
        for (int y : e[x])
        {
            // 跳过父节点（处理无向图的重复边）
            if (y == fa)
            {
                fa = ~fa; // 特殊处理，确保每条边只处理一次
                continue;
            }
            
            // 如果邻接节点y未被访问过
            if (!dfn[y])
            {
                dfs(y, x); // 递归访问y
                low[x] = std::min(low[x], low[y]); // 更新low值
            }
            else
            {
                // y已被访问，更新low值
                low[x] = std::min(low[x], dfn[y]);
            }
        }

        // 如果dfn[x] == low[x]，说明x是一个边双连通分量的根
        if (dfn[x] == low[x])
        {
            int y;
            cntBlock += 1; // 边双连通分量计数
            // 弹出栈中元素，直到x被弹出，这些元素构成一个边双连通分量
            do
            {
                y = stk[tt--];
                ebcc[cntBlock].push_back(y); // 将y加入当前边双连通分量
                bel[y] = cntBlock;           // 记录y所属的边双连通分量编号
            } while (y != x);
        }
    }

public:
    // 原始图的属性
    std::vector<int> dfn;  // 访问时间戳（DFS序）
    std::vector<int> low;   // 通过回边能到达的最小dfn值
    std::vector<int> bel;   // 每个节点所属的边双连通分量编号
    std::vector<std::vector<int>> ebcc; // 存储每个边双连通分量的节点列表

    // 缩点后的图（边双连通分量构成的树/森林）
    std::vector<std::vector<int>> g; // 缩点后的邻接表
    std::vector<int> siz;           // 每个边双连通分量的大小
    std::vector<int> val;           // 每个边双连通分量的权值（可选）
    int cntBlock = 0;               // 边双连通分量的总数

    // 构造函数：输入无向图的邻接表e（节点编号从1开始）
    EdgeBC(const std::vector<std::vector<int>> &e) : 
        e(e),                       // 初始化图的引用
        dfn(e.size()),              // 初始化dfn数组
        low(e.size()),              // 初始化low数组
        bel(e.size()),              // 初始化bel数组
        stk(e.size()),              // 初始化栈
        ebcc(e.size())              // 初始化ebcc数组
    {
        int n = e.size() - 1; // 节点数（假设节点编号为1~n）

        // 遍历所有节点，对未访问的节点调用Tarjan算法
        for (int i = 1; i <= n; i++)
        {
            if (!dfn[i])
            {
                dfs(i, -1); // 从i开始DFS，初始父节点为-1
            }
        }

        // 调整ebcc的大小为实际边双连通分量的数量
        ebcc.resize(cntBlock + 1);
        
        // 初始化缩点后的图
        g.resize(cntBlock + 1);
        siz.resize(cntBlock + 1);
        // val.resize(cntBlock + 1); // 如果需要权值，可以取消注释

        // 遍历所有节点，构建缩点后的图
        for (int x = 1; x <= n; x++)
        {
            siz[bel[x]]++; // 统计每个边双连通分量的大小
            // val[bel[x]] += a[x]; // 如果需要权值，可以累加

            // 遍历x的邻接节点y
            for (int y : e[x])
            {
                // 如果x和y属于不同的边双连通分量，则在缩点后的图中添加边
                if (bel[x] != bel[y])
                {
                    g[bel[x]].push_back(bel[y]);
                }
            }
        }
    }
};
```

#### 构造边双连通图
即给你一个无向图，加最少的边使其成为边双连通图。首先我们![image](https://cdn.nlark.com/yuque/__latex/5a309a58a010ec33df3d862d2c7aff04.svg)缩点，这样一定会形成一颗森林，

我们假如说这是一棵树的话，记叶子结点数量为![image](https://cdn.nlark.com/yuque/__latex/20c6cc2dab2e408052b5a1a81eadb61f.svg)，那么答案为![image](https://cdn.nlark.com/yuque/__latex/6cd1270c677a189820bb7d2e85c16c5a.svg)，构造方法是，我们把![image](https://cdn.nlark.com/yuque/__latex/3554585ecb04a4bf73b5938d239b0fe5.svg)得到的叶子结点按遍历顺序放到数组中，然后不断首尾匹配即可。

那么如果是森林，我们考虑先把它连成一棵树使得该树的叶子数量最少，在不考虑孤立点的情况下，每棵树至少会有两个叶子，那么我们把这两个叶子找出来，把这些森林按顺序首尾链接即可，注意需要特判孤立点的情况。

假如有![image](https://cdn.nlark.com/yuque/__latex/a42a4fc28b384cc408de066beed57485.svg)个联通块，那么这里消耗边数![image](https://cdn.nlark.com/yuque/__latex/73beedd8e7900b684c1f43c4fbb53bf5.svg)

## 欧拉图
欧拉路径：经过每条边恰好一次的路径

欧拉回路：经过每条边恰好一次并回到起点的路径

欧拉图：有欧拉回路的图被称作欧拉图

半欧拉图：没有欧拉回路但有欧拉路径的图被称作半欧拉图



欧拉图判断条件：

对于连通图![image](https://cdn.nlark.com/yuque/__latex/f8df64a4bfdeb9bdcbc357668b6fb123.svg)，如下三个性质等价：

1：![image](https://cdn.nlark.com/yuque/__latex/f8df64a4bfdeb9bdcbc357668b6fb123.svg)是欧拉图。

2：对于无向图，![image](https://cdn.nlark.com/yuque/__latex/f8df64a4bfdeb9bdcbc357668b6fb123.svg)中所有顶点的度数都是偶数；对于有向图，每个点入度等于出度。

3：![image](https://cdn.nlark.com/yuque/__latex/f8df64a4bfdeb9bdcbc357668b6fb123.svg)可以被分解成若干条不共边的回路。



半欧拉图判断条件：

对于有向图：有一个点![image](https://cdn.nlark.com/yuque/__latex/dfacf8f15d8317f6523d90688caffb5c.svg),有一个点![image](https://cdn.nlark.com/yuque/__latex/ae40caadf0549c974c748e7b3b88a551.svg),其余点![image](https://cdn.nlark.com/yuque/__latex/e7ce0dd4975d1fde7526eb11102ce8e2.svg)

对于无向图，有两个点![image](https://cdn.nlark.com/yuque/__latex/ed23b67649658d425e875e10432c9955.svg)为奇数。

显然对于有向图和无向图，两个特殊点都是欧拉通路的两个端点。

### 无向图
注意代码求出的是字典序最小的欧拉路。

```cpp
class UndirectedEulerRoad
{

public:
    UndirectedEulerRoad(int _n) : n(_n), g(_n + 1)
    {
        cnt.assign(n + 1, 0);
        deg.assign(n + 1, 0);
        revTot.assign(n + 1, 0);
    }

    void addEdge(int u, int v)
    {
        if (u != v)
        {
            g[u].push_back({v, 1, 0});
            g[v].push_back({u, 1, 0});
        }
        else
        {
            g[u].push_back({v, 1, 0});
        }
        deg[v]++;
        deg[u]++;
    }
    void hierholzer(int x)
    {

        for (int &i = cnt[x]; i < g[x].size();)
        {
            auto &e = g[x][i];
            if (e.exist)
            {
                e.exist = false;
                if (e.v != x)
                {
                    g[e.v][e.revCnt].exist = false;
                }
                ++i;
                hierholzer(e.v);
            }
            else
                ++i;
        }
        road.push_back(x);
    }
    int work()
    {
        for (int i = 1; i <= n; ++i)
        {
            std::sort(begin(g[i]), end(g[i]));
        }
        for (int i = 1; i <= n; ++i)
        {
            for (int j = 0; j < g[i].size(); ++j)
            {
                g[i][j].revCnt = revTot[g[i][j].v]++;
            }
        }
        int start = 0;
        int tot = 0;
        for (int i = n; i >= 1; --i)
        {
            tot += (deg[i] & 1);
            if (deg[i] & 1)
            {
                start = i;
            }
            else if (deg[i] and deg[start] % 2 == 0)
            {
                start = i;
            }
        }
        if (tot != 2 and tot != 0)
        {
            return 0;
        }
        hierholzer(start);
        return (tot ? 1 : 2);
    }
    auto getRoad()
    {
        std::reverse(begin(road), end(road));
        return road;
    }

private:
    struct Edge
    {
        int v;      // 到达的点是谁
        bool exist; // 该边是否被用过
        int revCnt; // 反边在对应vector中的编号
        bool operator<(const Edge &e) const
        {
            return v < e.v;
        }
    };
    int n;
    std::vector<std::vector<Edge>> g; // 存图
    std::vector<int> cnt;             // 遍历到哪条边了
    std::vector<int> deg;
    std::vector<int> road;
    std::vector<int> revTot;
};

```

### 有向图
注意代码求出的是字典序最小的欧拉路。

```cpp

class DirectedEulerRoad
{

public:
    DirectedEulerRoad(int _n) : n(_n), g(_n + 1)
    {
        cnt.assign(n + 1, 0);
        in.assign(n + 1, 0), out.assign(n + 1, 0);
    }
    void addEdge(int u, int v)
    {
        g[u].push_back({v, 1});
        in[v]++;
        out[u]++;
    }
    void hierholzer(int x)
    {
        for (int &i = cnt[x]; i < g[x].size();)
        {
            auto &e = g[x][i];
            if (e.exist)
            {
                e.exist = false;
                ++i;
                hierholzer(e.v);
            }
            else
                ++i;
        }
        road.push_back(x);
    }
    int work()
    {
        for (int i = 1; i <= n; ++i)
        {
            std::sort(begin(g[i]), end(g[i]));
        }
        int start = 0;
        int tot = 0, tot1 = 0, tot2 = 0;
        for (int i = n; i >= 1; --i)
        {
            tot += (in[i] != out[i]);
            tot1 += (in[i] == out[i] + 1);
            tot2 += (in[i] == out[i] - 1);
            if (out[i] != in[i])
            {
                start = i;
            }
            else if (out[start] == in[start] and in[i] == out[i] and in[i])
            {
                start = i;
            }
        }
        if (tot != 2 and tot != 0)
        {
            return 0;
        }
        if (tot1 > 1 or tot2 > 1)
        {
            return 0;
        }
        hierholzer(start);
        return (tot ? 1 : 2);
    }
    auto getRoad()
    {
        std::reverse(begin(road), end(road));
        return road;
    }

private:
    struct Edge
    {
        int v;      // 到达的点是谁
        bool exist; // 该边是否被用过
        bool operator<(const Edge &e) const
        {
            return v < e.v;
        }
    };
    int n;
    std::vector<std::vector<Edge>> g; // 存图
    std::vector<int> cnt;             // 遍历到哪条边了
    std::vector<int> in, out;
    std::vector<int> road;
};
```

### 混合图
混合图即既有有向边又有无向边，之所以不能转化为有向图，是因为在该问题下，无向边被视作可定向的有向边



判断是否有欧拉回路：

首先给每条无向边任意定向，设![image](https://cdn.nlark.com/yuque/__latex/9eec6dfb917c00b55e0e53a08ae989b5.svg)

若存在![image](https://cdn.nlark.com/yuque/__latex/e6c5796e96b225ac044f567f635300c0.svg)或者图不联通 直接无解

否则我们建立源点![image](https://cdn.nlark.com/yuque/__latex/55fc237afbe535f7d8434985b848a6a7.svg)和汇点![image](https://cdn.nlark.com/yuque/__latex/1553dae3cc5c15cddb4f5b5a367b0aba.svg)

对于一个点![image](https://cdn.nlark.com/yuque/__latex/712ecf7894348e92d8779c3ee87eeeb0.svg),如果![image](https://cdn.nlark.com/yuque/__latex/2958772a8c1c3a5cd03fb63d7b316194.svg)，那么![image](https://cdn.nlark.com/yuque/__latex/55fc237afbe535f7d8434985b848a6a7.svg)向![image](https://cdn.nlark.com/yuque/__latex/712ecf7894348e92d8779c3ee87eeeb0.svg)流量为![image](https://cdn.nlark.com/yuque/__latex/1eba656ea6732baf75b3f3441e03e02a.svg)的边，否则![image](https://cdn.nlark.com/yuque/__latex/712ecf7894348e92d8779c3ee87eeeb0.svg)向![image](https://cdn.nlark.com/yuque/__latex/1553dae3cc5c15cddb4f5b5a367b0aba.svg)连流量为![image](https://cdn.nlark.com/yuque/__latex/d995acf5bbc2e5a6bc7b66bf40c9d932.svg)的边，对于定向的无向边![image](https://cdn.nlark.com/yuque/__latex/d6a0c03c07bc2b18d1c40913751b9e57.svg)，连边![image](https://cdn.nlark.com/yuque/__latex/c26748e4b62342cac60b46108d5f838f.svg)，跑最大流算法

如果与![image](https://cdn.nlark.com/yuque/__latex/55fc237afbe535f7d8434985b848a6a7.svg)和![image](https://cdn.nlark.com/yuque/__latex/1553dae3cc5c15cddb4f5b5a367b0aba.svg)相连的所有边均满流，那么说明有解。

同时该条件等价于![image](https://cdn.nlark.com/yuque/__latex/855287f0da64deda0bb3dfdb97d41f99.svg)，即最大流等于所有入度大于出度节点对应的入度减出度除以二的和



构造方案：<font style="color:rgba(0, 0, 0, 0.85);">根据网络流的结果调整无向边的方向。将网络流中加入的定向边流量为</font>![image](https://cdn.nlark.com/yuque/__latex/53072c2388d69edc65c2377681e4e87c.svg)<font style="color:rgba(0, 0, 0, 0.85);">的边翻转</font>

## 拉姆齐定理
有![image](https://cdn.nlark.com/yuque/__latex/94e79ad0c1aabeafef9e2fc4af6adf66.svg)个人，任意两两之间认识或不认识，我们定义![image](https://cdn.nlark.com/yuque/__latex/5a0219951c3d2beae26e6e6cf14b9a0e.svg)为<font style="color:rgb(26, 28, 30);"> </font><font style="color:rgb(26, 28, 30);">保证“存在一个 m 人的朋友小团体（红色 </font>![image](https://cdn.nlark.com/yuque/__latex/47a243b22984ba5b21297ed262dcf195.svg)<font style="color:rgb(26, 28, 30);">（红色边表示朋友））”或“一个 n 人的陌生人小团体（蓝色 </font>![image](https://cdn.nlark.com/yuque/__latex/6977933cd128581118d355f96afb96e7.svg)<font style="color:rgb(26, 28, 30);">(蓝色边表示陌生)）”所需要的</font><font style="color:rgb(26, 28, 30);">最小派对人数</font>

<font style="color:rgb(26, 28, 30);">朋友小团体指该团体内两两互为朋友，陌生人即该团体内两两均不认识</font><font style="color:rgb(26, 28, 30);">。</font>

![image](https://cdn.nlark.com/yuque/__latex/443244b29e270c41d2e6e3a48abf0b4b.svg)

## 竞赛图
任意两点之间有且仅有一条有向边的图为竞赛图，由于连边方式类似于任意两人都打一场单循环赛，得名竞赛图，特别的，我们一般认为有向边的起点是获胜者，因此每个点的出度为对应选手的得分。



得分序列：把每个点的出度拿出来升序排序后的序列。



#### **兰道定理**
对于任意一个单调不减的序列，该序列可以为竞赛图的得分序列当且仅当：

![image](https://cdn.nlark.com/yuque/__latex/53072c2388d69edc65c2377681e4e87c.svg)对任意的![image](https://cdn.nlark.com/yuque/__latex/7a1179a3d92345d7a5fb94dba8dd2cd3.svg)，前![image](https://cdn.nlark.com/yuque/__latex/2443fbcfeb7e85e1d62b6f5e4f27207e.svg)个得分和一定不小于![image](https://cdn.nlark.com/yuque/__latex/88aa508903bab3f0bf8942d942007383.svg)

![image](https://cdn.nlark.com/yuque/__latex/2b89979f54ec02a7bf87aa0c1ea58ff9.svg)总和必须等于![image](https://cdn.nlark.com/yuque/__latex/2f6a4fcf61c75b2f8f3f5330065e98bb.svg)

若满足兰道定理，我们一定可以构造出满足条件的竞赛图。



构造方法：我们不妨设每个选手有一个需求值![image](https://cdn.nlark.com/yuque/__latex/ed7fedff055c71d274202a83acad92cc.svg)，其中![image](https://cdn.nlark.com/yuque/__latex/26fdbf8e53cb0e48da5f4ddd4aaf5a5c.svg)是需要赢多少场，![image](https://cdn.nlark.com/yuque/__latex/d29c2e5f4926e5b0e9a95305650f6e54.svg)是已经赢多少场，我们每次让需求最大的选手打赢需求最小的选手即可。

## 建图
### 线段树优化建图
一定要注意函数参数的位置！



![image](https://cdn.nlark.com/yuque/__latex/d0546b061bbe047e6e7ac5bde453ba5d.svg)数组用于单点连多点，![image](https://cdn.nlark.com/yuque/__latex/acdca535b07267caff67df09297a5cb9.svg)数组用于多点连单点

对于多点连多点的情况，我们新开节点，然后分为多连一![image](https://cdn.nlark.com/yuque/__latex/5202c7326ce1c7e97f87c45fbdbe9ef3.svg)一连多即可

对于单点连单点的情况，我们直接连就可以了

```cpp
class SegmentTreeGraph
{
#define lc u << 1
#define rc u << 1 | 1

public:
    int tot;
    int n;
    std::vector<std::vector<std::pair<int, int>>> g;
    SegmentTreeGraph(int n) : n(n), tot(n), in((n << 2) + 1), out((n << 2) + 1), g((n << 2) + 1) // 传入实际的点数
    {
        auto build = [&](auto build, int u, int l, int r) -> void
        {
            if (l == r)
            {
                in[u] = l;
                out[u] = l;
                return;
            }
            int mid = l + r >> 1;
            build(build, lc, l, mid);
            build(build, rc, mid + 1, r);
            in[u] = ++tot;
            out[u] = ++tot;
            g[in[u]].emplace_back(in[lc], 0);
            g[in[u]].emplace_back(in[rc], 0);
            g[out[lc]].emplace_back(out[u], 0);
            g[out[rc]].emplace_back(out[u], 0);
        };
        build(build, 1, 1, n);
    }
    void singleToRange(int u, int l, int r, int w)
    {
        singleToRange(1, 1, n, u, l, r, w);
    }
    void rangeToSingle(int u, int l, int r, int w)
    {
        rangeToSingle(1, 1, n, u, l, r, w);
    }
    void singleToSingle(int u, int v, int w)
    {
        g[u].emplace_back(v, w);
    }
    void rangeToRange(int l, int r, int x, int y, int w)
    {
        ++tot;
        if (g.size() <= tot)
        {
            g.resize(tot + 1);
        }
        rangeToSingle(tot, l, r, 0);
        singleToRange(tot, x, y, w);
    }

private:
    std::vector<int> in, out;
    void singleToRange(int u, int l, int r, int st, int x, int y, int w) // st为起点向[x,y]连边  不要边权就随便传
    {
        if (x <= l and y >= r)
        {
            g[st].emplace_back(in[u], w);
            return;
        }
        int mid = l + r >> 1;
        if (x <= mid)
        {
            singleToRange(lc, l, mid, st, x, y, w);
        }
        if (y > mid)
        {
            singleToRange(rc, mid + 1, r, st, x, y, w);
        }
    }
    void rangeToSingle(int u, int l, int r, int ed, int x, int y, int w) //[x,y]向终点ed连边
    {
        if (x <= l and y >= r)
        {
            g[out[u]].emplace_back(ed, w);
            return;
        }
        int mid = l + r >> 1;
        if (x <= mid)
        {
            rangeToSingle(lc, l, mid, ed, x, y, w);
        }
        if (y > mid)
        {
            rangeToSingle(rc, mid + 1, r, ed, x, y, w);
        }
    }
};
```

### 前后缀优化建图
```cpp
struct BuildEdge
{
    int n;
    int tot;
    std::vector<std::vector<std::pair<int, int>>> g;
    BuildEdge(int n) : n(n), g(5 * n + 1), tot(5 * n)
    {
        for (int i = 2; i <= n; ++i)
        {
            g[n + i].emplace_back(n + i - 1, 0);         // 连前缀
            g[2 * n + i - 1].emplace_back(2 * n + i, 0); // 连后缀
            g[3 * n + i].emplace_back(3 * n + i - 1, 0);
            g[4 * n + i - 1].emplace_back(4 * n + i, 0);
        }
        for (int i = 1; i <= n; ++i)
        {
            g[n + i].emplace_back(i, 0);
            g[2 * n + i].emplace_back(i, 0);
            g[i].emplace_back(3 * n + i, 0);
            g[i].emplace_back(4 * n + i, 0);
        }
    }
    void norm(int tot)
    {
        if (g.size() <= tot)
        {
            g.resize(tot + 1);
        }
    }
    void linkPre(int x, int y, int w) // x->[1,y]
    {
        g[x].emplace_back(n + y, w);
    }
    void linkSuf(int x, int y, int w) // x->[y,n]
    {
        g[x].emplace_back(2 * n + y, w);
    }
    void preLink(int x, int y, int w) //[1,x]->y
    {
        g[3 * n + x].emplace_back(y, w);
    }
    void sufLink(int x, int y, int w) //[x,n]->y
    {
        g[4 * n + x].emplace_back(y, w);
    }
    void preToPre(int x, int y, int w) //[1,x]->[1,y]
    {
        ++tot;
        norm(tot);
        preLink(x, tot, w);
        linkPre(tot, y, 0);
    }
    void preToSuf(int x, int y, int w) //[1,x]->[y,n]
    {
        ++tot;
        norm(tot);
        preLink(x, tot, w);
        linkSuf(tot, y, 0);
    }
    void sufToPre(int x, int y, int w) //[x,n]->[1,y]
    {
        ++tot;
        norm(tot);
        sufLink(tot, x, w);
        linkPre(tot, y, 0);
    }
    void sufToSuf(int x, int y, int w) //[x,n]->[y,n]
    {
        ++tot;
        norm(tot);
        sufLink(x, tot, w);
        linkSuf(tot, y, 0);
    }
};
```

### ST表优化建图
我们考虑一种操作 即![image](https://cdn.nlark.com/yuque/__latex/be4a2805dbbf1090765accbe20c7d97d.svg)向![image](https://cdn.nlark.com/yuque/__latex/2a52a2674f4ee1a1d458d37616cf6f8d.svg)连边，保证两区间长度相等，连法是一对一对应位置连边，我们考虑像![image](https://cdn.nlark.com/yuque/__latex/fcd5b9e4e7009628bacef402bc06d6bf.svg)表一样建出![image](https://cdn.nlark.com/yuque/__latex/4fdce66a3ca18398b05c1efc03c7aa4f.svg)个区间作为并查集所有的节点，然后可以把![image](https://cdn.nlark.com/yuque/__latex/fe5ecbec1e96a37e46f979f585190277.svg)次数转为![image](https://cdn.nlark.com/yuque/__latex/ff4edff51773a4560f25e8eab96349ff.svg)个并查集节点相连，在所有![image](https://cdn.nlark.com/yuque/__latex/fe5ecbec1e96a37e46f979f585190277.svg)操作结束以后，由于每个区间可以拆成对应的左右子区间，把祖先节点对应的![image](https://cdn.nlark.com/yuque/__latex/b6a68bffd59def8247ed510be1f253a4.svg)标记下传给子区间即可。

具体的说，我们按层考虑，对于同一层内所有![image](https://cdn.nlark.com/yuque/__latex/b6a68bffd59def8247ed510be1f253a4.svg)相同的节点，我们按顺序把它们的左儿子![image](https://cdn.nlark.com/yuque/__latex/fe5ecbec1e96a37e46f979f585190277.svg)，再按顺序把他们的右儿子![image](https://cdn.nlark.com/yuque/__latex/fe5ecbec1e96a37e46f979f585190277.svg)即可。这样下传到最后一层，考虑并查集的连通性即可。

正向连正向(比如![image](https://cdn.nlark.com/yuque/__latex/598b1a2d6849bb9289bbbf209d180a13.svg)连![image](https://cdn.nlark.com/yuque/__latex/20088f56acec094fe73fca2af2529a7c.svg))

```cpp

struct BuildGraph
{
    int n, log;
    DSU *dsu;
    std::vector<std::vector<int>> f;
    std::vector<int> lc, rc;
    BuildGraph(int n) : n(n)
    {
        log = std::__lg(n) + 1;
        f.assign(log, std::vector<int>(n + 1, 0));
        for (int i = 1; i <= n; ++i)
        {
            f[0][i] = i;
        }
        int idx = n;
        for (int i = log - 1; i >= 1; --i)
        {
            for (int j = 1; j + (1 << i) - 1 <= n; ++j)
            {
                f[i][j] = ++idx;
            }
        }
        lc.assign(idx + 1, -1);
        rc.assign(idx + 1, -1);
        dsu = new DSU(idx + 1);
    }
    void merge(int l1, int r1, int l2, int r2)
    {
        int len = r1 - l1 + 1;
        for (int i = log - 1; i >= 0; --i)
        {
            if (len >= (1 << i))
            {
                dsu->merge(f[i][l1], f[i][l2]);
                len -= (1 << i);
                l1 += (1 << i);
                l2 += (1 << i);
            }
        }
    }
    void pushall()
    {
        for (int i = log - 1; i >= 1; --i)
        {
            for (int j = 1; j + (1 << i) - 1 <= n; ++j)
            {
                int root = dsu->root(f[i][j]);
                if (lc[root] != -1)
                {
                    dsu->merge(lc[root], f[i - 1][j]);
                    dsu->merge(rc[root], f[i - 1][j + (1 << i - 1)]);
                }
                else
                {
                    lc[root] = f[i - 1][j];
                    rc[root] = f[i - 1][j + (1 << i - 1)];
                }
            }
            for (int j = 1; j + (1 << i) - 1 <= n; ++j)
            {
                int root = dsu->root(f[i][j]);
                lc[root] = rc[root] = -1;
            }
        }
    }
    std::vector<int> calc()
    {
        pushall();
        std::vector<int> ans(n + 1);
        for (int i = 1; i <= n; ++i)
        {
            ans[i] = dsu->root(i);
        }
        return ans;
    } //
};
```

正向连反向(比如![image](https://cdn.nlark.com/yuque/__latex/598b1a2d6849bb9289bbbf209d180a13.svg)连![image](https://cdn.nlark.com/yuque/__latex/c2c722cde9297d91ddaed3e2e63c1b02.svg))

```cpp
struct BuildGraph
{
    int n, log;
    DSU *dsu;
    std::vector<std::vector<int>> f, g;
    std::vector<int> lc, rc;
    BuildGraph(int n) : n(n)
    {
        log = std::__lg(n) + 1;
        f.assign(log, std::vector<int>(n + 1, 0));
        g.assign(log, std::vector<int>(n + 1, 0));

        for (int i = 1; i <= n; ++i)
        {
            f[0][i] = i;
            g[0][i] = n - i + 1;
        }
        int idx = n;
        for (int i = log - 1; i >= 1; --i)
        {
            for (int j = 1; j + (1 << i) - 1 <= n; ++j)
            {
                f[i][j] = ++idx;
                g[i][j] = ++idx;
            }
        }
        lc.assign(idx + 1, -1);
        rc.assign(idx + 1, -1);
        dsu = new DSU(idx + 1);
    }
    void merge(int l1, int r1, int l2, int r2)
    //[l2,r2]反向
    {
        l2 = n - l2 + 1;
        r2 = n - r2 + 1;
        std::swap(l2, r2);
        int len = r1 - l1 + 1;
        for (int i = log - 1; i >= 0; --i)
        {
            if (len >= (1 << i))
            {
                dsu->merge(f[i][l1], g[i][l2]);
                len -= (1 << i);
                l1 += (1 << i);
                l2 += (1 << i);
            }
        }
    }
    void pushall()
    {
        for (int i = log - 1; i >= 1; --i)
        {
            for (int j = 1; j + (1 << i) - 1 <= n; ++j)
            {
                int root = dsu->root(f[i][j]);
                if (lc[root] != -1)
                {
                    dsu->merge(lc[root], f[i - 1][j]);
                    dsu->merge(rc[root], f[i - 1][j + (1 << i - 1)]);
                }
                else
                {
                    lc[root] = f[i - 1][j];
                    rc[root] = f[i - 1][j + (1 << i - 1)];
                }
                root = dsu->root(g[i][j]);
                if (lc[root] != -1)
                {
                    dsu->merge(lc[root], g[i - 1][j]);
                    dsu->merge(rc[root], g[i - 1][j + (1 << i - 1)]);
                }
                else
                {
                    lc[root] = g[i - 1][j];
                    rc[root] = g[i - 1][j + (1 << i - 1)];
                }
            }
            for (int j = 1; j + (1 << i) - 1 <= n; ++j)
            {
                int root = dsu->root(f[i][j]);
                lc[root] = rc[root] = -1;
                root = dsu->root(g[i][j]);
                lc[root] = rc[root] = -1;
            }
        }
    }
    std::vector<int> calc()
    {
        pushall();
        std::vector<int> ans(n + 1);
        for (int i = 1; i <= n; ++i)
        {
            ans[i] = dsu->root(i);
            //std::cerr << ans[i] << " \n"[i == n];
        }
        return ans;
    } //
};
```

### 网格建图
```cpp
template <class Element, class Vector, class AdjEle>
//元素类型(int char) 一行的类型(string vector)   第三个默认为int
class GridPre
{
    const int h, w, n;
    static constexpr int D = 4;
    static constexpr int dx[D] = {0, 0, -1, 1};
    static constexpr int dy[D] = {-1, 1, 0, 0};

public:
    std::vector<std::vector<AdjEle>> g;
    // std::vector<Element> a;
    std::vector<int> reachableVertexSet;

    GridPre(const std::vector<Vector> &grid, const std::set<Element> &reachableSet)
        : h{(int)grid.size() - 1}, w{(int)grid[1].size() - 1}, n{h * w + 1}, g{n} //,a(n)
    {
        reachableVertexSet.reserve(n);

        auto ok = [&](int x, int y)
        {
            return 1 <= x and x <= h and 1 <= y and y <= w and reachableSet.count(grid[x][y]);
        };

        for (int i = 1; i <= h; i++)
        {
            for (int j = 1; j <= w; j++)
            {
                if (reachableSet.count(grid[i][j]) == 0)
                {
                    continue;
                }

                int x = (i - 1) * w + j;
                // a[x] = grid[i][j];

                reachableVertexSet.push_back(x);

                for (int k = 0; k < D; k++)
                {
                    int next_i = i + dx[k];
                    int next_j = j + dy[k];

                    if (ok(next_i, next_j))
                    {
                        g[x].emplace_back((next_i - 1) * w + next_j);
                    }
                }
            }
        }
    }
};

```

## 网络流
网络流是一种建好图以后，内置反悔机制的一种贪心策略，不需要我们人为去寻找贪心的反悔策略

容量:当前边最多经过的流量记作![image](https://cdn.nlark.com/yuque/__latex/d2924c1ca87fd7ada05e8bd003a387df.svg)

流量:当前边实际经过的流量记作![image](https://cdn.nlark.com/yuque/__latex/dbc45948b8f24efea624f9d310494fc5.svg)

残量:![image](https://cdn.nlark.com/yuque/__latex/7818cdb5709cf97fc7c32ce8602a2922.svg)

残量网络：把残量为0的边删去，剩下的图称作残量网络，对应边的边权也变为残量

增广路：与二分图中增广路定义不同，增广路指残量网络上源点到汇点的一条简单路径

割:割是一个边的集合，一个边集是割当且仅当去掉这些边后网络不在流通，即最大流为![image](https://cdn.nlark.com/yuque/__latex/22d0feea96d3bb2fc273f7598ce748c1.svg)

最大流最小割定理:一个网格的最大流等于其最小割



我们根据定义发现，只要存在增广路，流量就能不断增大，因此求最大流是一个求增广路的过程,并且这条增广路我们遵循能流满就流满的贪心策略

我们选择一条增广路，假设流量为![image](https://cdn.nlark.com/yuque/__latex/d0103d8bdd582d9114bab6698940d2e4.svg),我们正向边容量![image](https://cdn.nlark.com/yuque/__latex/2bc7216168e08df864ec080117883ca3.svg)，反向边容量![image](https://cdn.nlark.com/yuque/__latex/af777f04a42e77f0942a35e5634eb258.svg)，这就是最开始我们说的内置反悔机制,也就是说我们可以通过反边流量进行反悔

由于![image](https://cdn.nlark.com/yuque/__latex/b15def98468ae43a213eafc8866c0827.svg)算法不优于![image](https://cdn.nlark.com/yuque/__latex/54a1dbe10e79a54da19a90a56152b3b6.svg),我们只介绍![image](https://cdn.nlark.com/yuque/__latex/54a1dbe10e79a54da19a90a56152b3b6.svg)算法

![image](https://cdn.nlark.com/yuque/__latex/54a1dbe10e79a54da19a90a56152b3b6.svg)是多路增广+当前弧优化的增广路算法

我们通过![image](https://cdn.nlark.com/yuque/__latex/0c86b50bf23d4de38f21c0ef89918da0.svg)给图分层，分层后多路增广,也就是同时累加多条增广路的流量

当前弧优化是指，流量已经流满的边无用，我们没必要对每个点每次都从头开始遍历，而是记录一个当前弧，直接从当前弧开始遍历

贪心的正确性全部基于退流反边对流量不断调整直至最优状态

### **拆点**
注意到在流网络中，我们对于限制都是加在边上的。那么对于点的限制我们往往考虑拆点。具体的说，我们把一个点![image](https://cdn.nlark.com/yuque/__latex/4faf0c587205d654244bd07bba6f65de.svg)拆成对应的![image](https://cdn.nlark.com/yuque/__latex/2bcc75bbb06235edd61f0b46403dafbd.svg)和![image](https://cdn.nlark.com/yuque/__latex/c0f098cb7efd84bec40913cb0d9f96d7.svg)，然后连边![image](https://cdn.nlark.com/yuque/__latex/da39e8e821693f68b68d06db4d2ad7a0.svg)，边的流量限制即为该点的流量限制。

### 最大流
```cpp
template <class T>
struct Flow
{
    const T inf = std::numeric_limits<T>::max() / 2;
    const int n;

    std::vector<std::pair<int, T>> e;
    std::vector<std::vector<int>> g;
    std::vector<int> cur, dep;

    Flow(int n) : n(n), g(n + 1) {}

    bool bfs(int s, int t)
    {
        dep.assign(n + 1, -1);
        std::queue<int> q;
        dep[s] = 0;

        q.push(s);
        while (!q.empty())
        {
            const int u = q.front();
            q.pop();

            for (int i : g[u])
            {
                auto [v, c] = e[i];

                if (c > 0 and dep[v] == -1)
                {
                    dep[v] = dep[u] + 1;
                    if (v == t)
                    {
                        return true;
                    }
                    q.push(v);
                }
            }
        }

        return false;
    }

    T dfs(int u, int t, T f)
    {
        if (u == t)
        {
            return f;
        }
        T res = f;
        for (int &i = cur[u]; i < g[u].size(); i++)
        {
            const int j = g[u][i];
            auto [v, c] = e[j];

            if (c > 0 and dep[v] == dep[u] + 1)
            {
                T out = dfs(v, t, std::min(res, c));
                e[j].second -= out;
                e[j ^ 1].second += out;

                res -= out;
                if (res == 0)
                {
                    return f;
                }
            }
        }
        return f - res;
    }

    void add(int u, int v, T c)
    {
        g[u].push_back(e.size());
        e.emplace_back(v, c);
        g[v].push_back(e.size());
        e.emplace_back(u, 0);
    }

    T work(int s, int t)
    {
        T ans = 0;
        while (bfs(s, t))
        {
            cur.assign(n + 1, 0);
            ans += dfs(s, t, inf);
        }
        return ans;
    }
    std::vector<std::tuple<int, int, T>> getFlowEdges()
    {
        std::vector<std::tuple<int, int, T>> edge;
        for (int i = 0; i < e.size(); i += 2) // 只检查正向边
        {
            int u = e[i ^ 1].first; // 反向边的起点是正向边的终点
            int v = e[i].first;
            T flow = e[i ^ 1].second; // 反向边的容量就是正向边的流量
            edge.push_back({u, v, flow});
        }
        return edge;
    }
};
```

### 最小费用最大流
#### Dinic(dijkstra)
```cpp
template <class T>
struct MinCostFlow
{
    struct _Edge
    {
        int to;
        T cap;
        T cost;
        _Edge(int to_, T cap_, T cost_) : to(to_), cap(cap_), cost(cost_) {}
    };
    int n;
    std::vector<_Edge> e;
    std::vector<std::vector<int>> g;
    std::vector<T> h, dis;
    std::vector<int> pre;
    bool dijkstra(int s, int t)
    {
        dis.assign(n + 1, std::numeric_limits<T>::max());
        pre.assign(n + 1, -1);
        std::priority_queue<std::pair<T, int>, std::vector<std::pair<T, int>>, std::greater<std::pair<T, int>>> que;
        dis[s] = 0;
        que.emplace(0, s);
        while (!que.empty())
        {
            T d = que.top().first;
            int u = que.top().second;
            que.pop();
            if (dis[u] != d)
            {
                continue;
            }
            for (int i : g[u])
            {
                int v = e[i].to;
                T cap = e[i].cap;
                T cost = e[i].cost;
                if (cap > 0 && dis[v] > d + h[u] - h[v] + cost)
                {
                    dis[v] = d + h[u] - h[v] + cost;
                    pre[v] = i;
                    que.emplace(dis[v], v);
                }
            }
        }
        return dis[t] != std::numeric_limits<T>::max();
    }
    MinCostFlow() {}
    MinCostFlow(int n_)
    {
        init(n_);
    }
    void init(int n_)
    {
        n = n_;
        e.clear();
        g.assign(n + 1, {});
    }
    void add(int u, int v, T cap, T cost)
    {
        g[u].push_back(e.size());
        e.emplace_back(v, cap, cost);
        g[v].push_back(e.size());
        e.emplace_back(u, 0, -cost);
    }
    std::pair<T, T> work(int s, int t)
    {
        T flow = 0;
        T cost = 0;
        h.assign(n + 1, 0);
        while (dijkstra(s, t))
        {
            for (int i = 0; i <= n; ++i)
            {
                h[i] += dis[i];
            }
            T aug = std::numeric_limits<int>::max();
            for (int i = t; i != s; i = e[pre[i] ^ 1].to)
            {
                aug = std::min(aug, e[pre[i]].cap);
            }
            for (int i = t; i != s; i = e[pre[i] ^ 1].to)
            {
                e[pre[i]].cap -= aug;
                e[pre[i] ^ 1].cap += aug;
            }
            flow += aug;
            cost += aug * h[t];
        }
        return std::make_pair(flow, cost);
    }
    struct Edge
    {
        int from;
        int to;
        T cap;
        T cost;
        T flow;
    };
    std::vector<Edge> edges()
    {
        std::vector<Edge> a;
        for (int i = 0; i < e.size(); i += 2)
        {
            Edge x;
            x.from = e[i + 1].to;
            x.to = e[i].to;
            x.cap = e[i].cap + e[i + 1].cap;
            x.cost = e[i].cost;
            x.flow = e[i + 1].cap;
            a.push_back(x);
        }
        return a;
    }

    void printFlowEdges()
    {
        std::cout << "Flow edges (from -> to: flow / cost):" << std::endl;
        auto allEdges = edges();
        for (const auto &edge : allEdges)
        {
            if (edge.flow > 0)
            {
                std::cout << edge.from << " -> " << edge.to << ": "
                          << edge.flow << " / " << edge.cost << std::endl;
            }
        }
    }
};
```

#### Dinic(SPFA)
```cpp
template <class T>
struct MinCostFlow
{
    struct _Edge
    {
        int to;
        T cap;
        T cost;
        _Edge(int to_, T cap_, T cost_) : to(to_), cap(cap_), cost(cost_) {}
    };

    int n;
    std::vector<_Edge> e;
    std::vector<std::vector<int>> g;
    std::vector<T> dis;
    std::vector<int> pre;

    MinCostFlow() {}
    MinCostFlow(int n_) { init(n_); }

    void init(int n_)
    {
        n = n_;
        e.clear();
        g.assign(n + 1, {});
    }

    void add(int u, int v, T cap, T cost)
    {
        g[u].push_back((int)e.size());
        e.emplace_back(v, cap, cost);
        g[v].push_back((int)e.size());
        e.emplace_back(u, 0, -cost);
    }

    /// 用 SPFA 找最短费用增广路
    bool spfa(int s, int t)
    {
        const T INF = std::numeric_limits<T>::max() / 4;
        dis.assign(n + 1, INF);
        pre.assign(n + 1, -1);
        std::vector<bool> inq(n + 1, false);

        std::queue<int> q;
        dis[s] = 0;
        q.push(s);
        inq[s] = true;

        while (!q.empty())
        {
            int u = q.front();
            q.pop();
            inq[u] = false;

            for (int i : g[u])
            {
                int v = e[i].to;
                if (e[i].cap > 0 && dis[v] > dis[u] + e[i].cost)
                {
                    dis[v] = dis[u] + e[i].cost;
                    pre[v] = i;
                    if (!inq[v])
                    {
                        q.push(v);
                        inq[v] = true;
                    }
                }
            }
        }
        return dis[t] != INF;
    }

    /// 主过程
    std::pair<T, T> work(int s, int t)
    {
        T flow = 0, cost = 0;
        const T INF = std::numeric_limits<T>::max() / 4;

        while (spfa(s, t))
        {
            // 找到最小残量（可增广的流量）
            T aug = INF;
            for (int i = t; i != s; i = e[pre[i] ^ 1].to)
            {
                aug = std::min(aug, e[pre[i]].cap);
            }
            // 更新残量网络
            for (int i = t; i != s; i = e[pre[i] ^ 1].to)
            {
                e[pre[i]].cap -= aug;
                e[pre[i] ^ 1].cap += aug;
            }
            flow += aug;
            cost += aug * dis[t];
        }
        return {flow, cost};
    }

    struct Edge
    {
        int from;
        int to;
        T cap;
        T cost;
        T flow;
    };

    std::vector<Edge> edges()
    {
        std::vector<Edge> a;
        for (int i = 0; i < (int)e.size(); i += 2)
        {
            Edge x;
            x.from = e[i ^ 1].to;
            x.to = e[i].to;
            x.cap = e[i].cap + e[i ^ 1].cap;
            x.cost = e[i].cost;
            x.flow = e[i ^ 1].cap;
            a.push_back(x);
        }
        return a;
    }

    void printFlowEdges()
    {
        std::cout << "Flow edges (from -> to: flow / cost):" << std::endl;
        auto allEdges = edges();
        for (const auto &edge : allEdges)
        {
            if (edge.flow > 0)
            {
                std::cout << edge.from << " -> " << edge.to << ": "
                          << edge.flow << " / " << edge.cost << std::endl;
            }
        }
    }
};

```

#### EK(SPFA)
```cpp
template <class T>
struct MinCostFlow
{
    // ====== 内部边结构：存储邻接表索引指向的真实边 ======
    struct _Edge
    {
        int to;     // 终点
        T cap;      // 残量容量
        T cost;     // 单位费用
        _Edge(int to_, T cap_, T cost_) : to(to_), cap(cap_), cost(cost_) {}
    };

    int n = 0;                                  // 点数（默认按 1..n 使用）
    std::vector<_Edge> e;                       // 边表（正反向成对存储）
    std::vector<std::vector<int>> g;            // 邻接表：存储边表下标
    std::vector<T> dis;                         // 最短费用距离
    std::vector<int> pre;                       // 记录最短路上边的编号（边表下标）

    MinCostFlow() {}
    MinCostFlow(int n_) { init(n_); }

    // ====== 初始化 ======
    void init(int n_)
    {
        n = n_;
        e.clear();
        g.assign(n + 1, {});
    }

    // ====== 加边：自动加反向边 ======
    void add(int u, int v, T cap, T cost)
    {
        g[u].push_back((int)e.size());
        e.emplace_back(v, cap, cost);
        g[v].push_back((int)e.size());
        e.emplace_back(u, 0, -cost);
    }

    // ====== SPFA：在残量网络上找费用最短增广路（可含负边费用） ======
    bool spfa(int s, int t)
    {
        const T INF = std::numeric_limits<T>::max() / 4;
        dis.assign(n + 1, INF);
        pre.assign(n + 1, -1);
        std::vector<bool> inq(n + 1, false);

        std::queue<int> q;
        dis[s] = 0;
        q.push(s);
        inq[s] = true;

        while (!q.empty())
        {
            int u = q.front();
            q.pop();
            inq[u] = false;

            for (int idx : g[u])
            {
                const _Edge &ed = e[idx];
                if (ed.cap <= 0) continue;
                int v = ed.to;
                T nd = dis[u] + ed.cost;
                if (nd < dis[v])
                {
                    dis[v] = nd;
                    pre[v] = idx;
                    if (!inq[v])
                    {
                        q.push(v);
                        inq[v] = true;
                    }
                }
            }
        }
        return dis[t] != INF;
    }

    // ====== 主过程：不断用 SPFA 找最短费用增广路，直至无法增广 ======
    std::pair<T, T> work(int s, int t)
    {
        T flow = 0;     // 总流量
        T cost = 0;     // 总费用
        const T INF = std::numeric_limits<T>::max() / 4;

        while (spfa(s, t))
        {
            // 计算本次可增广的流量
            T aug = INF;
            for (int v = t; v != s; v = e[pre[v] ^ 1].to)
            {
                aug = std::min(aug, e[pre[v]].cap);
            }

            // 沿最短路增广
            for (int v = t; v != s; v = e[pre[v] ^ 1].to)
            {
                e[pre[v]].cap -= aug;
                e[pre[v] ^ 1].cap += aug;
            }

            flow += aug;
            cost += aug * dis[t];  // dis[t] 为本次单位费用
        }

        return std::make_pair(flow, cost);
    }

    // ====== 对外可视边结构（便于调试/打印） ======
    struct Edge
    {
        int from;   // 起点
        int to;     // 终点
        T cap;      // 原始容量
        T cost;     // 单位费用
        T flow;     // 已经流过的流量
    };

    // 返回所有原始边的信息（以正向边为准）
    std::vector<Edge> edges()
    {
        std::vector<Edge> a;
        a.reserve(e.size() / 2);
        for (int i = 0; i < (int)e.size(); i += 2)
        {
            Edge x;
            x.from = e[i ^ 1].to;
            x.to   = e[i].to;
            // 正反向残量之和等于原始容量
            x.cap  = e[i].cap + e[i ^ 1].cap;
            x.cost = e[i].cost;
            // 反向边的容量就是已流过的流量
            x.flow = e[i ^ 1].cap;
            a.push_back(x);
        }
        return a;
    }

    // 打印所有有流量的边
    void printFlowEdges()
    {
        std::cout << "Flow edges (from -> to: flow / cost):" << std::endl;
        auto all = edges();
        for (const auto &ed : all)
        {
            if (ed.flow > 0)
            {
                std::cout << ed.from << " -> " << ed.to << ": "
                          << ed.flow << " / " << ed.cost << std::endl;
            }
        }
    }
};

```

### 原始对偶优化
如果有负权边，在调用![image](https://cdn.nlark.com/yuque/__latex/ba3908cd4430ca453b5ee867015587dc.svg)时需要先跑一遍最短路算法计算势能![image](https://cdn.nlark.com/yuque/__latex/67df0f404d0960fadcc99f6258733f22.svg)

这里考虑采用![image](https://cdn.nlark.com/yuque/__latex/ab4b473d027a85e44563e5929e25d83e.svg)



这里优化了最短路算法的复杂度（即通过对偶的方式让![image](https://cdn.nlark.com/yuque/__latex/4dc575314dfc9be173edc5e447b1d3c0.svg)可行），但事实上不加优化的![image](https://cdn.nlark.com/yuque/__latex/cdab6df32b1b78b580c54ef5aa7af7bb.svg)极快，这里的优化可能起到负作用

#### Dinic
```cpp
template <class T>
struct MinCostFlow
{
    struct _Edge
    {
        int to;
        T cap;
        T cost;
        _Edge(int to_, T cap_, T cost_) : to(to_), cap(cap_), cost(cost_) {}
    };

    int n;
    std::vector<_Edge> e;
    std::vector<std::vector<int>> g;
    std::vector<T> h;     // 节点势 (potential)
    std::vector<T> dis;   // Dijkstra 或 SPFA 计算出的距离
    std::vector<int> dep; // 用于 Dinic 的分层
    std::vector<int> cur; // 当前弧优化 (在 dfs 中隐式使用)

    bool ok = false; // 自动检测负权边的标志
    const T INF = std::numeric_limits<T>::max() / 4;

    MinCostFlow() {}
    MinCostFlow(int n_) { init(n_); }

    void init(int n_)
    {
        n = n_;
        e.clear();
        g.assign(n + 1, {});
        h.assign(n + 1, 0);
        ok = false; // 重置标志
    }

    void add(int u, int v, T cap, T cost)
    {
        ok |= (cost < 0);
        g[u].push_back((int)e.size());
        e.emplace_back(v, cap, cost);
        g[v].push_back((int)e.size());
        e.emplace_back(u, 0, -cost);
    }

private:
    // 仅在有负权边时，用于计算初始势的 SPFA
    void SPFA(int s)
    {
        dis.assign(n + 1, INF);
        std::vector<bool> inq(n + 1, false);
        std::queue<int> q;
        dis[s] = 0;
        q.push(s);
        inq[s] = true;
        while (!q.empty())
        {
            int u = q.front();
            q.pop();
            inq[u] = false;
            for (int i : g[u])
            {
                auto &t = e[i];
                if (t.cap > 0 && dis[t.to] > dis[u] + t.cost)
                {
                    dis[t.to] = dis[u] + t.cost;
                    if (!inq[t.to])
                    {
                        q.push(t.to);
                        inq[t.to] = true;
                    }
                }
            }
        }
    }
    // 使用 Dijkstra 寻找最短路，边权为 cost + h[u] - h[v]
    bool dijkstra(int s, int t)
    {
        dis.assign(n + 1, INF);
        dis[s] = 0;
        using pti = std::pair<T, int>;
        std::priority_queue<pti, std::vector<pti>, std::greater<pti>> pq;
        pq.push({0, s});

        while (!pq.empty())
        {
            auto [d, u] = pq.top();
            pq.pop();
            if (dis[u] < d)
                continue;
            for (int i : g[u])
            {
                auto &t = e[i];
                T c = t.cost + h[u] - h[t.to];
                if (t.cap > 0 && dis[t.to] > dis[u] + c)
                {
                    dis[t.to] = dis[u] + c;
                    pq.push({dis[t.to], t.to});
                }
            }
        }
        return dis[t] != INF;
    }
    // 在可接受网络上（缩减成本为0的边）构建分层图
    bool bfs(int s, int t)
    {
        dep.assign(n + 1, 0);
        dep[s] = 1;
        std::queue<int> q;
        q.push(s);
        while (!q.empty())
        {
            int u = q.front();
            q.pop();
            for (int i : g[u])
            {
                auto &t = e[i];
                if (t.cap > 0 && !dep[t.to] && t.cost + h[u] - h[t.to] == 0)
                {
                    dep[t.to] = dep[u] + 1;
                    q.push(t.to);
                }
            }
        }
        return dep[t] != 0;
    }
    T dfs(int u, int t, T limit)
    {
        if (u == t)
            return limit;
        T used = 0;
        for (int i : g[u])
        {
            if (used == limit)
                break;
            auto &E = e[i];
            if (E.cap > 0 && dep[E.to] == dep[u] + 1 && E.cost + h[u] - h[E.to] == 0)
            {
                T f = dfs(E.to, t, std::min(limit - used, E.cap));
                if (f > 0)
                {
                    E.cap -= f;
                    e[i ^ 1].cap += f;
                    used += f;
                }
            }
        }
        if (used == 0)
            dep[u] = 0;
        return used;
    }

public:
    // 主过程：原始对偶算法
    std::pair<T, T> work(int s, int t)
    {
        T flow = 0, cost = 0;
        // **智能初始化**：如果检测到负权边，则运行一次 SPFA 初始化势 h
        if (ok)
        {
            SPFA(s);
            for (int i = 0; i <= n; ++i)
            {
                if (dis[i] < INF)
                    h[i] = dis[i];
            }
        }
        // 主循环：不断用 Dijkstra 寻找增广路
        while (dijkstra(s, t))
        {
            for (int i = 0; i <= n; ++i)
            {
                if (dis[i] < INF)
                {
                    h[i] += dis[i];
                }
            }
            T f = 0;
            while (bfs(s, t))
            {
                f += dfs(s, t, std::numeric_limits<T>::max());
            }

            flow += f;
            cost += f * h[t];
        }
        return {flow, cost};
    }

    struct Edge
    {
        int from, to;
        T cap, cost, flow;
    };
    std::vector<Edge> edges()
    {
        std::vector<Edge> a;
        for (size_t i = 0; i < e.size(); i += 2)
        {
            a.push_back({e[i ^ 1].to, e[i].to, e[i].cap + e[i ^ 1].cap, e[i].cost, e[i ^ 1].cap});
        }
        return a;
    }
};
```

#### EK
```cpp
template <class T>
struct MinCostFlowEK
{
    struct _Edge
    {
        int to;
        T cap;
        T cost;
        _Edge(int to_, T cap_, T cost_) : to(to_), cap(cap_), cost(cost_) {}
    };

    int n;
    std::vector<_Edge> e;
    std::vector<std::vector<int>> g;
    std::vector<T> h;     // 节点势
    std::vector<T> dis;   // Dijkstra 或 SPFA 计算出的距离
    std::vector<int> pre; // BFS/增广路径前驱
    bool ok = false;
    const T INF = std::numeric_limits<T>::max() / 4;

    MinCostFlowEK() {}
    MinCostFlowEK(int n_) { init(n_); }

    void init(int n_)
    {
        n = n_;
        e.clear();
        g.assign(n + 1, {});
        h.assign(n + 1, 0);
        ok = false;
    }

    void add(int u, int v, T cap, T cost)
    {
        ok |= (cost < 0);
        g[u].push_back((int)e.size());
        e.emplace_back(v, cap, cost);
        g[v].push_back((int)e.size());
        e.emplace_back(u, 0, -cost);
    }

private:
    void SPFA(int s)
    {
        dis.assign(n + 1, INF);
        std::vector<bool> inq(n + 1, false);
        std::queue<int> q;
        dis[s] = 0;
        q.push(s);
        inq[s] = true;
        while (!q.empty())
        {
            int u = q.front();
            q.pop();
            inq[u] = false;
            for (int i : g[u])
            {
                auto &E = e[i];
                if (E.cap > 0 && dis[E.to] > dis[u] + E.cost)
                {
                    dis[E.to] = dis[u] + E.cost;
                    if (!inq[E.to])
                    {
                        q.push(E.to);
                        inq[E.to] = true;
                    }
                }
            }
        }
    }

    // Dijkstra + potentials
    bool dijkstra(int s, int t)
    {
        dis.assign(n + 1, INF);
        using pti = std::pair<T, int>;
        std::priority_queue<pti, std::vector<pti>, std::greater<pti>> pq;
        dis[s] = 0;
        pq.push({0, s});
        while (!pq.empty())
        {
            auto [d, u] = pq.top();
            pq.pop();
            if (dis[u] < d)
                continue;
            for (int i : g[u])
            {
                auto &E = e[i];
                T c = E.cost + h[u] - h[E.to];
                if (E.cap > 0 && dis[E.to] > dis[u] + c)
                {
                    dis[E.to] = dis[u] + c;
                    pre[E.to] = i; // 记录前驱边
                    pq.push({dis[E.to], E.to});
                }
            }
        }
        return dis[t] != INF;
    }

public:
    std::pair<T, T> work(int s, int t)
    {
        T flow = 0, cost = 0;
        if (ok)
        {
            SPFA(s);
            for (int i = 0; i <= n; i++)
                if (dis[i] < INF)
                    h[i] = dis[i];
        }

        pre.assign(n + 1, -1);

        while (dijkstra(s, t))
        {
            // 更新势
            for (int i = 0; i <= n; i++)
                if (dis[i] < INF)
                    h[i] += dis[i];

            // 找到最小增广量
            T f = INF;
            for (int u = t; u != s; u = e[pre[u] ^ 1].to)
                f = std::min(f, e[pre[u]].cap);

            // 增广
            for (int u = t; u != s; u = e[pre[u] ^ 1].to)
            {
                e[pre[u]].cap -= f;
                e[pre[u] ^ 1].cap += f;
            }

            flow += f;
            cost += f * h[t]; // 原始对偶特性：h[t] = 本次增广的真实成本
        }

        return {flow, cost};
    }

    struct Edge
    {
        int from, to;
        T cap, cost, flow;
    };

    std::vector<Edge> edges()
    {
        std::vector<Edge> res;
        for (size_t i = 0; i < e.size(); i += 2)
            res.push_back({e[i ^ 1].to, e[i].to, e[i].cap + e[i ^ 1].cap, e[i].cost, e[i ^ 1].cap});
        return res;
    }
};

```

### 上下界网络流
注意在这一模块我们区分源点汇点和超级源点汇点，前者指原本的流量网络中的源汇，后者则是新的流量网络中的源汇。为了方便表示 ，我们分别表示为![image](https://cdn.nlark.com/yuque/__latex/8cb19bdde9d62a1302b1e9fc7615c946.svg)

#### 无源汇可行流
无源汇可行流是指给你一个流量网络![image](https://cdn.nlark.com/yuque/__latex/7a1e6a754b7a8e45cb731688765c5e85.svg)，每条边有上界![image](https://cdn.nlark.com/yuque/__latex/889134a2392096acc48ec069d1168c1c.svg)，也有下界![image](https://cdn.nlark.com/yuque/__latex/04292357a35009a02501dc45c7bed79e.svg)，我们要为每条边构造一个流量函数![image](https://cdn.nlark.com/yuque/__latex/25a2c6b7d08f1a7d608ecaf04bb4d2cd.svg)使得该网络满足流量网络的基本特性，即流量守恒和斜对称性等等。

我们不妨先把![image](https://cdn.nlark.com/yuque/__latex/25a2c6b7d08f1a7d608ecaf04bb4d2cd.svg)设为![image](https://cdn.nlark.com/yuque/__latex/04292357a35009a02501dc45c7bed79e.svg),这样对于某个点它的流量差可以确定![image](https://cdn.nlark.com/yuque/__latex/0a28e735e3b27aa35b2a7397192b75b0.svg)

当![image](https://cdn.nlark.com/yuque/__latex/0f35ecf4434257d18a4ba9b4f8cb85a7.svg)说明流入的过多，反之则说明流出的过多。根据斜对称性我们有![image](https://cdn.nlark.com/yuque/__latex/b7eb5a4fa13125a0a3c68fb7662e6b54.svg),我们不妨设![image](https://cdn.nlark.com/yuque/__latex/c0f53056b910648c88387c5dda7d3cef.svg)。这启发我们建立新的流量网络![image](https://cdn.nlark.com/yuque/__latex/f8df64a4bfdeb9bdcbc357668b6fb123.svg)，每条边的流量上界为![image](https://cdn.nlark.com/yuque/__latex/a999148ccbd6538ae0b42bb4629650a3.svg),

我们建立超级源点和汇点![image](https://cdn.nlark.com/yuque/__latex/aef5001e97eb1d64b534a81e04afcdca.svg)，如果![image](https://cdn.nlark.com/yuque/__latex/72f05f5c665433e26d6ba170ab4f41cc.svg)，我们连边![image](https://cdn.nlark.com/yuque/__latex/a4cdcb2fb4271061a0a86a8d93dec3e6.svg),否则我们连边![image](https://cdn.nlark.com/yuque/__latex/0b7228c7a4090a48ade331b625abd531.svg)，我们跑最大流得到最大流量![image](https://cdn.nlark.com/yuque/__latex/416e9a8046d05a55fd5a31adaf5e6858.svg),如果![image](https://cdn.nlark.com/yuque/__latex/56b8361a500f2bd15547d0d469e6414b.svg)，就说明可以构造出一条可行流。

每条边真实的流量函数![image](https://cdn.nlark.com/yuque/__latex/3d12a9b58249ea71774173657328121d.svg),其中![image](https://cdn.nlark.com/yuque/__latex/dbc45948b8f24efea624f9d310494fc5.svg)指![image](https://cdn.nlark.com/yuque/__latex/f8df64a4bfdeb9bdcbc357668b6fb123.svg)中的流量

```cpp
/**
 * @brief 无源汇可行流求解器
 */
template <class G>
class FeasibleFlow
{
public:
    /**
     * @brief 构造函数
     * @param n 图中节点数量（不包括超级源汇）
     * @param m 图中边数量
     */
    FeasibleFlow(int n, int m) : n(n), m(m), val(n + 2), ans(m + 1) {}

    /**
     * @brief 添加一条边
     * @param u 边的起点
     * @param v 边的终点
     * @param lower 流量下界
     * @param upper 流量上界
     * @param id 边的标识符（用于结果输出）
     */
    void addEdge(int u, int v, G lower, G upper, int id)
    {
        edges.emplace_back(u, v, lower, upper, id);
    }

    /**
     * @brief 求解可行流
     * @return 是否存在可行流
     */
    bool solve()
    {
        // 初始化最大流算法（包含超级源汇S=0和T=n+1）
        Flow<G> flow(n + 2);
        const int S = 0, T = n + 1;

        // 第一步：构建网络流图
        for (const auto &[u, v, b, c, id] : edges)
        {
            // 添加边，容量为上界减下界
            flow.add(u, v, c - b);
            // 初始流量设为下界
            ans[id] = b;
            // 维护节点流量平衡（入流-出流）
            val[v] += b;
            val[u] -= b;
        }

        // 第二步：处理流量平衡约束
        G sum = 0; // 记录需要补偿的总流量
        for (int i = 1; i <= n; ++i)
        {
            if (val[i] > 0)
            {
                // 该节点需要额外流入val[i]流量
                sum += val[i];
                flow.add(S, i, val[i]);
            }
            else if (val[i] < 0)
            {
                // 该节点需要额外流出-val[i]流量
                flow.add(i, T, -val[i]);
            }
        }

        // 第三步：计算最大流
        G f = flow.work(S, T);

        // 判断是否存在可行流
        if (f != sum)
        {
            return false; // 无法满足流量平衡约束
        }

        // 第四步：重构实际流量值
        auto flowEdges = flow.getFlowEdges();
        for (const auto &[from, to, flowVal] : flowEdges)
        {
            // 只处理原始图中的边（排除与超级源汇相连的边）
            if (1 <= from && from <= n && 1 <= to && to <= n)
            {
                // ans[id]+=flowVal; id得自行修改传入
                // 实际流量 = 下界 + 附加流量
            }
        }

        return true;
    }

    /**
     * @brief 获取每条边的实际流量
     * @return 包含各边流量的数组（按添加顺序）
     */
    std::vector<G> getFlow() const
    {
        return std::vector<G>(ans.begin() + 1, ans.end());
    }

private:
    int n;                                              // 原始图中节点数
    int m;                                              // 原始图中边数
    std::vector<G> val;                                 // 节点流量平衡值（入流-出流）
    std::vector<G> ans;                                 // 各边的实际流量
    std::vector<std::tuple<int, int, G, G, int>> edges; // 存储所有边(u,v,下界,上界,id)
};
```

注意代码中![image](https://cdn.nlark.com/yuque/__latex/b6c262a1ae972f9d5c381d97ef1bf515.svg)数组表示每条边的可行流量

#### 有源汇可行流
我们只需要连一条新边![image](https://cdn.nlark.com/yuque/__latex/aa179e742e628ff8d4550778a2d3d0a1.svg)，即可转化为无源汇可行流

#### 有源汇最大流
首先基于一个事实：只要给定的![image](https://cdn.nlark.com/yuque/__latex/25a2c6b7d08f1a7d608ecaf04bb4d2cd.svg)流函数是一组可行流，我们就一定能找到最大流。

我们首先考虑求出可行流，也就是执行上述过程，在这个过程中我们可以得到一组可行流函数![image](https://cdn.nlark.com/yuque/__latex/25a2c6b7d08f1a7d608ecaf04bb4d2cd.svg),并且此时已有的流量是![image](https://cdn.nlark.com/yuque/__latex/8a8e1cde17578983b3940ae542b6133e.svg)的反边流量。然后我们对![image](https://cdn.nlark.com/yuque/__latex/f8df64a4bfdeb9bdcbc357668b6fb123.svg)撤去![image](https://cdn.nlark.com/yuque/__latex/569356c00cd83bc4e342f310b0ad4264.svg)和![image](https://cdn.nlark.com/yuque/__latex/99208647aefa79a50d513913a1666a59.svg)并且删掉边![image](https://cdn.nlark.com/yuque/__latex/8a8e1cde17578983b3940ae542b6133e.svg)，再次从![image](https://cdn.nlark.com/yuque/__latex/13b7e5a4c93d861c9c8e082315569a63.svg)跑最大流。将得到的最大流和一开始的可行流相加即为答案。我们称撤去![image](https://cdn.nlark.com/yuque/__latex/cf732c6f0f346b3e6da8b982cd066679.svg)为初步调整，再次跑最大流为二次调整。

注意一定得按顺序来，必须先跑![image](https://cdn.nlark.com/yuque/__latex/374695d551e74942a95fd663acff11f7.svg)，然后删去![image](https://cdn.nlark.com/yuque/__latex/8a8e1cde17578983b3940ae542b6133e.svg)再跑![image](https://cdn.nlark.com/yuque/__latex/13b7e5a4c93d861c9c8e082315569a63.svg)

```cpp
template <class G>
class BoundedMaxFlow
{
public:
    BoundedMaxFlow(int n, int s, int t) : n(n), s(s), t(t), val(n + 2, 0) {}

    void addEdge(int u, int v, G b, G c)
    {
        edges.emplace_back(u, v, b, c);
    }

    G compute()
    {
        Flow<G> flow(n + 2); // 包含超级源汇S=0, T=n+1
        const int S = 0, T = n + 1;

        // 构建基础网络
        for (const auto &[u, v, b, c] : edges)
        {
            flow.add(u, v, c - b);
            val[v] += b;
            val[u] -= b;
        }

        // 添加补偿边
        G sum = 0;
        for (int i = 1; i <= n; ++i)
        {
            if (val[i] > 0)
            {
                sum += val[i];
                flow.add(S, i, val[i]);
            }
            else if (val[i] < 0)
            {
                flow.add(i, T, -val[i]);
            }
        }

        // 添加t->s的无限边
        flow.add(t, s, std::numeric_limits<G>::max() / 2);
        // 检查可行性
        if (flow.work(S, T) != sum)
        {
            return -1; // 无解
        }

        // 计算最大流
        G initialFlow = flow.e.back().second; // 最后一条边t-s的流量
        flow.g[s].pop_back();
        flow.g[t].pop_back();
        G additionalFlow = flow.work(s, t);
        return initialFlow + additionalFlow;
    }

private:
    int n;                                         // 节点数
    int s, t;                                      // 源汇点
    std::vector<G> val;                            // 流量平衡
    std::vector<std::tuple<int, int, G, G>> edges; // u,v,b,c
};
```

#### 有源汇最小流
根据结论 ![image](https://cdn.nlark.com/yuque/__latex/13b7e5a4c93d861c9c8e082315569a63.svg)的最小流等于![image](https://cdn.nlark.com/yuque/__latex/8a8e1cde17578983b3940ae542b6133e.svg)的最大流的相反数，用可行流流量减去![image](https://cdn.nlark.com/yuque/__latex/f8df64a4bfdeb9bdcbc357668b6fb123.svg)中![image](https://cdn.nlark.com/yuque/__latex/2dc818e6282cbc8ea706a3606bcd2f91.svg)的最大流

所以最终最小流为![image](https://cdn.nlark.com/yuque/__latex/f74329ac934323ed24bbdf37dfca34ac.svg)

其中![image](https://cdn.nlark.com/yuque/__latex/2b10c523092c20ee84d1067f1a95f334.svg)为给定的源和汇

#### 有源汇费用流
我们把最大流算法换成费用流算法，关于![image](https://cdn.nlark.com/yuque/__latex/971e48f973e8a0cb4788512adc9a1067.svg)的所有连边代价均为![image](https://cdn.nlark.com/yuque/__latex/22d0feea96d3bb2fc273f7598ce748c1.svg)，初始的费用为![image](https://cdn.nlark.com/yuque/__latex/505e58a0c6c93eff84113159b9e99387.svg)，然后我们要考虑撤去初步调整的影响，即加上![image](https://cdn.nlark.com/yuque/__latex/8af7a062babc59da245e717a0c77eb2e.svg)最小费用最大流产生的费用，然后二次调整也要加上![image](https://cdn.nlark.com/yuque/__latex/13b7e5a4c93d861c9c8e082315569a63.svg)最小费用最大流的费用。

#### 有负圈的费用流
我们考虑让负边强制满流，也就是让![image](https://cdn.nlark.com/yuque/__latex/b1ad03a9bf0d59ceb51f2d5b674c5fa3.svg),并且让![image](https://cdn.nlark.com/yuque/__latex/8be08b1b2fa3b3d1f6996ece1cf9b34d.svg)表示退流，这样![image](https://cdn.nlark.com/yuque/__latex/e6cdff7e69798d28b0aabed29902e773.svg)这条边就不会出现在流量网络![image](https://cdn.nlark.com/yuque/__latex/bf5a6fee97def1f1319baa14f3a40806.svg)中，就可以正常跑费用流了。

```cpp
/**
 * @brief 带负圈处理的最小费用流求解器
 * @tparam G 费用流数据类型（通常为int或long long）
 * @tparam MinCostFlow 最小费用流算法模板（需提供相同接口）
 */
template <typename G>
class NegativeCycleFlow
{
public:
    /**
     * @brief 构造函数
     * @param n 原始图中节点数（不包括超级源汇）
     * @param s 原始源点
     * @param t 原始汇点
     */
    NegativeCycleFlow(int n, int s, int t) : n(n), s(s), t(t), val(n + 1, 0) {}

    /**
     * @brief 添加有上下界和费用的边
     * @param u 起点
     * @param v 终点
     * @param minFlow 最小流量（下界）
     * @param maxFlow 最大流量（上界）
     * @param cost 单位费用
     */
    void addEdge(int u, int v, G minFlow, G maxFlow, G cost)
    {
        if (cost < 0)
        {
            edges.push_back({u, v, maxFlow, maxFlow, cost});
            edges.push_back({v, u, 0, maxFlow, -cost});
        }
        else
        {
            edges.push_back({u, v, minFlow, maxFlow, cost});
        }
    }

    /**
     * @brief 计算带负圈的最小费用流
     * @return 返回{总流量, 总费用}，若无解则返回{-1, -1}
     */
    std::pair<G, G> compute()
    {
        // 初始化费用流（包含超级源汇S=0和T=n+1）
        MinCostFlow<G> flow(n + 2);
        const int S = 0, T = n + 1;

        // 第一步：处理负费用边（强制流满上界消除负圈）
        G totalCost = 0;
        for (const auto &[u, v, minF, maxF, c] : edges)
        {
            totalCost += minF * c; // 计算强制流量的费用
            val[u] -= minF;        // 调整节点流量平衡
            val[v] += minF;
            // 添加剩余容量边
            flow.add(u, v, maxF - minF, c);
        }

        // 第二步：处理流量平衡约束
        G totalFlow = 0;
        for (int i = 1; i <= n; ++i)
        {
            if (val[i] > 0)
            {
                flow.add(S, i, val[i], 0);
                totalFlow += val[i];
            }
            else
            {
                flow.add(i, T, -val[i], 0);
            }
        }

        // 第三步：添加t->s的无限容量边（转化为循环流）
        flow.add(t, s, std::numeric_limits<G>::max() / 2, 0);

        // 第四步：检查可行性并计算初始费用
        auto [f1, c1] = flow.work(S, T);
        if (f1 != totalFlow)
        {
            return {-1, -1}; // 无可行流
        }
        totalCost += c1;

        // 第五步：计算实际最大流
        // 1. 获取初始可行流值（t->s边的流量）
        G initialFlow = flow.e.back().cap;
        flow.g[s].pop_back();
        flow.g[t].pop_back();
        // 2. 在残余网络上继续增广
        auto [f2, c2] = flow.work(s, t);
        totalCost += c2;

        return {initialFlow + f2, totalCost};
    }

private:
    int n;                                            // 原始节点数
    int s, t;                                         // 原始源汇点
    std::vector<G> val;                               // 节点流量平衡值
    std::vector<std::tuple<int, int, G, G, G>> edges; // 边信息[u, v, min, max, cost]
};
```

#### 最大费用最大流
我们把所有边权取反，跑（可能有负圈）的最小费用最大流即可。

具体的说，对于一条边![image](https://cdn.nlark.com/yuque/__latex/15ed2df7c5f3a2e742a03ee3ba20d1be.svg)来说如果![image](https://cdn.nlark.com/yuque/__latex/8d3480e61aab5ac0719f69e84308e463.svg)为负，我们把该边拆成两条分别是![image](https://cdn.nlark.com/yuque/__latex/36b8b671302f34a46bea9762a2b751da.svg)以及![image](https://cdn.nlark.com/yuque/__latex/415d168697d1a16d12e7f63f4438d44c.svg),这样在加入上下界网络流图中时负边权必须流满。

### Stoer-Wagner无向图全局最小割
定义无向联通图![image](https://cdn.nlark.com/yuque/__latex/f8df64a4bfdeb9bdcbc357668b6fb123.svg)的最小割为，边权和最小的边集![image](https://cdn.nlark.com/yuque/__latex/321138a59e6eab0c97c21f05282a80a6.svg)，满足去掉![image](https://cdn.nlark.com/yuque/__latex/321138a59e6eab0c97c21f05282a80a6.svg)之后可以使![image](https://cdn.nlark.com/yuque/__latex/f8df64a4bfdeb9bdcbc357668b6fb123.svg)变成两个联通分量。

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
const int N = 610;   // 最大顶点数
const ll INF = 1e18; // 代表无穷大
ll w[N][N];          // 邻接矩阵，存储边的权值
bool deleted[N];     // 标记顶点是否已被合并
int n;               // 图的顶点数
// Stoer-Wagner 全局最小割算法
// 返回一个 pair，包含最小割的值和构成割的一个顶点集合
pair<ll, vector<int>> stoer_wagner()
{
    ll min_cut = INF;
    vector<int> best_partition;

    // `nodes` 存储当前图中还存在的顶点
    vector<int> nodes(n);
    iota(nodes.begin(), nodes.end(), 0); // 初始化 nodes 为 {0, 1, ..., n-1}

    for (int phase = n; phase > 1; --phase)
    {
        // Minimum Cut Phase: 类似 Prim 算法，找出 s 和 t
        vector<ll> dist(n, 0);
        vector<bool> in_set(n, false);
        int s = -1, t = -1;

        for (int i = 0; i < phase; ++i)
        {
            int max_j = -1;
            // 找到不在集合中且 dist 最大的顶点
            for (int u : nodes)
            {
                if (!in_set[u] && (max_j == -1 || dist[u] > dist[max_j]))
                {
                    max_j = u;
                }
            }
            if (i == phase - 2)
                s = max_j; // 倒数第二个加入集合的顶点是 s
            if (i == phase - 1)
                t = max_j; // 最后一个加入集合的顶点是 t
            in_set[max_j] = true;
            // 更新所有不在集合中的顶点的 dist 值
            for (int u : nodes)
            {
                if (!in_set[u])
                {
                    dist[u] += w[max_j][u];
                }
            }
        }
        // 更新全局最小割
        if (dist[t] < min_cut)
        {
            min_cut = dist[t];
            // 找到构成当前割的原始顶点集合
            // 需要遍历所有原始顶点，判断它们最终被合并到了 t 还是其他节点
            // 但一个更简单的方法是直接知道 t 本身代表了哪些原始顶点
            // 这里我们偷个懒，只返回了 t 对应的划分，需要更复杂的逻辑来追踪所有合并
            // 对于只求最小割值的场景，这样已经足够。
            // 为了得到正确的划分，我们需要手动维护每个节点所代表的原始节点集合
            // 对于竞赛来说，通常只要求割的值
            best_partition = {t}; // 注意：这只是最简单的划分表示
        }
        // Contraction Phase: 合并 s 和 t
        // 将 t 的所有边权加到 s 上
        for (int u : nodes)
        {
            if (u != s && u != t)
            {
                w[s][u] += w[t][u];
                w[u][s] += w[t][u]; // 关键：维持对称性
            }
        }

        // 从 nodes 向量中移除 t
        nodes.erase(remove(nodes.begin(), nodes.end(), t), nodes.end());
    }
    return {min_cut, best_partition};
}

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int m;
    cin >> n >> m;
    // 初始化邻接矩阵
    for (int i = 0; i < n; ++i)
    {
        for (int j = 0; j < n; ++j)
        {
            w[i][j] = 0;
        }
    }
    for (int i = 0; i < m; ++i)
    {
        int u, v;
        ll c;
        cin >> u >> v >> c;
        --u;
        --v;
        // 无向图，边权累加
        w[u][v] += c;
        w[v][u] += c;
    }

    auto [min_cut_val, partition] = stoer_wagner();
    cout << min_cut_val << '\n';

    return 0;
}
```

### 其他总结
##### 残余网络
即跑完当前流以后所有容量>0的边的集合，注意无论正反边只要有容量即可（正边可以推流，反边可以退流）。

##### 最小割集
求最小割集的方法：在残余网络中从源点开始![image](https://cdn.nlark.com/yuque/__latex/ab9beef7db741e3cc3445e9070df572e.svg)（只走容量>0的边），能到达的所有点即为![image](https://cdn.nlark.com/yuque/__latex/55fc237afbe535f7d8434985b848a6a7.svg),![image](https://cdn.nlark.com/yuque/__latex/55fc237afbe535f7d8434985b848a6a7.svg)及其补集为最小割集。

##### 最小割集必须点
残余网络中![image](https://cdn.nlark.com/yuque/__latex/55fc237afbe535f7d8434985b848a6a7.svg)直接连向的点必在![image](https://cdn.nlark.com/yuque/__latex/55fc237afbe535f7d8434985b848a6a7.svg)的割集中, 直接连向![image](https://cdn.nlark.com/yuque/__latex/1553dae3cc5c15cddb4f5b5a367b0aba.svg)的点必在![image](https://cdn.nlark.com/yuque/__latex/1553dae3cc5c15cddb4f5b5a367b0aba.svg)的割集中; 若这些点的并集为全集, 则最小割方案唯一.

(这里可到是指只走容量>0的边)

##### 最小割可行边
在残余网络中跑![image](https://cdn.nlark.com/yuque/__latex/de803e8b8d362d6fff6c031d185a1b8a.svg)，缩点后剩余的边是可行边，这些边必然满流

##### 最小割必须边
仍然在残余网络中跑![image](https://cdn.nlark.com/yuque/__latex/de803e8b8d362d6fff6c031d185a1b8a.svg)，如果一条边![image](https://cdn.nlark.com/yuque/__latex/e6cdff7e69798d28b0aabed29902e773.svg)，满足![image](https://cdn.nlark.com/yuque/__latex/35f0658215634ca43797ff5d1be73093.svg)，那么是必须边

##### 最大权闭合子图
即选了![image](https://cdn.nlark.com/yuque/__latex/77c3adce895348f6083c425fe1ba2624.svg)必须选![image](https://cdn.nlark.com/yuque/__latex/77c3adce895348f6083c425fe1ba2624.svg)能到达的所有点，以此类推。

![image](https://cdn.nlark.com/yuque/__latex/55fc237afbe535f7d8434985b848a6a7.svg)向正权点![image](https://cdn.nlark.com/yuque/__latex/712ecf7894348e92d8779c3ee87eeeb0.svg)连流量为![image](https://cdn.nlark.com/yuque/__latex/97c3bb45228367ee126d0fca58d475fc.svg)的边，负权点![image](https://cdn.nlark.com/yuque/__latex/bf98c0ddcbe9c1e535f767c78c3aa813.svg)向![image](https://cdn.nlark.com/yuque/__latex/1553dae3cc5c15cddb4f5b5a367b0aba.svg)连流量为![image](https://cdn.nlark.com/yuque/__latex/95391d34e8628d8cdfd32a79cc2baa3c.svg)的边，每条有向边加入，流量无穷大即可。

求最小割后，![image](https://cdn.nlark.com/yuque/__latex/55fc237afbe535f7d8434985b848a6a7.svg)所在的最小割集即为选择方案。

##### 分组问题
有![image](https://cdn.nlark.com/yuque/__latex/df378375e7693bdcf9535661c023c02e.svg)个![image](https://cdn.nlark.com/yuque/__latex/8a9f78ca455ce4e53bd6598014177510.svg)型变量，你需要把他们分为![image](https://cdn.nlark.com/yuque/__latex/a9f9bd5be9388bc1293308d88586b235.svg)两组，每个点有为![image](https://cdn.nlark.com/yuque/__latex/22d0feea96d3bb2fc273f7598ce748c1.svg)的代价![image](https://cdn.nlark.com/yuque/__latex/47a7df221c955badf20b98a186a2a40d.svg),有为![image](https://cdn.nlark.com/yuque/__latex/53072c2388d69edc65c2377681e4e87c.svg)的代价![image](https://cdn.nlark.com/yuque/__latex/24a00a92acccd2f5795d9a6932687462.svg),有![image](https://cdn.nlark.com/yuque/__latex/4760e2f007e23d820825ba241c47ce3b.svg)个特殊限制，如果![image](https://cdn.nlark.com/yuque/__latex/a1170a444f2006784f140aea7fd6baa4.svg)同时在左侧会产生代价![image](https://cdn.nlark.com/yuque/__latex/a704d83f4af7a65fc7767f7aded869b6.svg)，同理有![image](https://cdn.nlark.com/yuque/__latex/d5bb88cd66766a08a865b8a86872b93a.svg)，我们考虑建立源点![image](https://cdn.nlark.com/yuque/__latex/55fc237afbe535f7d8434985b848a6a7.svg)，汇点![image](https://cdn.nlark.com/yuque/__latex/1553dae3cc5c15cddb4f5b5a367b0aba.svg)，![image](https://cdn.nlark.com/yuque/__latex/55fc237afbe535f7d8434985b848a6a7.svg)向每个点连流量为![image](https://cdn.nlark.com/yuque/__latex/47a7df221c955badf20b98a186a2a40d.svg)的边，每个点向![image](https://cdn.nlark.com/yuque/__latex/1553dae3cc5c15cddb4f5b5a367b0aba.svg)连流量为![image](https://cdn.nlark.com/yuque/__latex/24a00a92acccd2f5795d9a6932687462.svg)的边。对于左侧代价![image](https://cdn.nlark.com/yuque/__latex/a704d83f4af7a65fc7767f7aded869b6.svg),我们建立一个新点![image](https://cdn.nlark.com/yuque/__latex/712ecf7894348e92d8779c3ee87eeeb0.svg)，连边![image](https://cdn.nlark.com/yuque/__latex/5271f6351f044b546c7aaec04eca48c1.svg),![image](https://cdn.nlark.com/yuque/__latex/aba9fc0b5e66dc742e4beb9a31a5d861.svg),![image](https://cdn.nlark.com/yuque/__latex/2c7ab6894f9a8c9464291cf231c6ae3c.svg),对于右侧同理建新点![image](https://cdn.nlark.com/yuque/__latex/712ecf7894348e92d8779c3ee87eeeb0.svg)，连边![image](https://cdn.nlark.com/yuque/__latex/d7b6a384ef2b6bbfcd3a8947af71202b.svg)，![image](https://cdn.nlark.com/yuque/__latex/0da46215e9f711816367614afeac3b8f.svg),![image](https://cdn.nlark.com/yuque/__latex/783e6b3ec7591a1324110f06ebe128e5.svg),跑最小割即可。

## 二分图
二分图是无向图的概念，二分图是一类特殊的无向图.其特点是可以把点分成左右两堆，满足每堆内部的点两两不存在有边，特别的我们称为左部点和右部点

### 二分图的判断
一个无向图是二分图的充要条件是不存在奇环 我们有两种方法判断二分图



![image](https://cdn.nlark.com/yuque/__latex/53072c2388d69edc65c2377681e4e87c.svg)我们可以通过二分图染色来判断是否为二分图,如果是二分图，染色过程中还帮我们分出了左部点和右部点，时间复杂度![image](https://cdn.nlark.com/yuque/__latex/fdf264192b783f02198831921a7e54b0.svg)

![image](https://cdn.nlark.com/yuque/__latex/2b89979f54ec02a7bf87aa0c1ea58ff9.svg)如果像线段树分治那样，需要动态判断二分图，我们可以采用扩展域并查集，对于边![image](https://cdn.nlark.com/yuque/__latex/838c98c94a4322ee88230f6f92e2ac73.svg)我们![image](https://cdn.nlark.com/yuque/__latex/5eb2d6f6738ec0ec8a7ad18f0d2e2238.svg),加边![image](https://cdn.nlark.com/yuque/__latex/838c98c94a4322ee88230f6f92e2ac73.svg)时我们先![image](https://cdn.nlark.com/yuque/__latex/c3da6c53405982cfaa1ec6edd0de29bd.svg)![image](https://cdn.nlark.com/yuque/__latex/838c98c94a4322ee88230f6f92e2ac73.svg)是否连通，如果联通则说明有奇环，为什么呢？注意我们的连边方式，想要直接连通必须经过偶数条边，当再出现一条直接联通的边时，就存在了奇环

#### 二分图染色
```cpp
struct BiGraphColor
{
    std::vector<int> col;
    bool isBiGraph;
    int cnt1 = 0,cnt2 = 0;
    BiGraphColor(const std::vector<std::vector<int>> &e) : col(e.size(), -1), isBiGraph(true)
    {

        int n = e.size() - 1;
        std::function<void(int)> dfs = [&](int x)
        {
            if (!isBiGraph)
            {
                return;
            }
            for (int y : e[x])
            {
                if (col[y] == -1)
                {
                    col[y] = col[x] ^ 1;
                    if (col[y] == 0)
                    {
                        cnt1++;
                    }
                    else
                    {
                        cnt2++;
                    }
                    dfs(y);
                }
                else if (col[y] == col[x])
                {
                    isBiGraph = false;
                    return;
                }
            }
        };
        for (int i = 1; i <= n; i++)
        {
            if (col[i] == -1)
            {
                col[i] = 0;
                dfs(i);
            }
            if (!isBiGraph)
                return;
        }
    }
};
```

二分图匹配问题留在图匹配中统一说明

### 二分图上博弈
在一张二分图上，![image](https://cdn.nlark.com/yuque/__latex/6f32681da24989b84492c22ca4d55bc9.svg)和![image](https://cdn.nlark.com/yuque/__latex/b926709c260b3d3f06d1804916a571b5.svg)从某个起点开始轮流移动，![image](https://cdn.nlark.com/yuque/__latex/86b362c29d167c0034360c97e6aced98.svg)先手，不能重复移动到同一节点，无法移动者输？问必胜策略

结论：如果起点是最大匹配的关键点，那么![image](https://cdn.nlark.com/yuque/__latex/86b362c29d167c0034360c97e6aced98.svg)必胜

证明:![image](https://cdn.nlark.com/yuque/__latex/86b362c29d167c0034360c97e6aced98.svg)只要按匹配边不断走就可以，我们可以证明![image](https://cdn.nlark.com/yuque/__latex/b926709c260b3d3f06d1804916a571b5.svg)无法在过程中走到未盖点，假如![image](https://cdn.nlark.com/yuque/__latex/b926709c260b3d3f06d1804916a571b5.svg)走到未盖点，那我们翻转![image](https://cdn.nlark.com/yuque/__latex/86b362c29d167c0034360c97e6aced98.svg)的起点出发的路径，匹配数不变，但此时起点不再属于匹配点，与起点是关键点矛盾。因此![image](https://cdn.nlark.com/yuque/__latex/af73265d9203aae33185dd11045f60e8.svg)只能跟随![image](https://cdn.nlark.com/yuque/__latex/86b362c29d167c0034360c97e6aced98.svg)不断走交错路，直至无路可走

我们只需找到关键点即可，在二分图匹配中我们已经详细阐述了如何寻找关键点

### 删边二分图
给你一个无向图问删除一条边是不是二分图？

我们从维护奇环的角度来考虑，没有奇环是二分图的充要条件，我们考虑对图跑出![image](https://cdn.nlark.com/yuque/__latex/3554585ecb04a4bf73b5938d239b0fe5.svg)树，然后考虑非树边在树上构成的环路长度，我们每找到一个奇环，就对这条路径上的树边进行区间加,并标记该非树边，同理我们每找到一个偶环，也对这条路径上的树边区间加，我们用树上差分实现。十分关键的一点是，我们为什么要统计偶环呢？我们发现这种操作方式并不能找到所有的环，对于环套环的图即可发现，也就是说我们可能遗漏某些环的信息，具体的说，如果两个奇环合并又构成一个偶环，我们只会统计到一个奇环和一个偶环，我们知道只有两个奇环共用的边才是合法答案，而我们知道奇环+偶环![image](https://cdn.nlark.com/yuque/__latex/1c70e8fe6554270e03e7aef978b7394c.svg)奇环，如果一条边既被奇环覆盖，又被偶环覆盖，说明他可以衍生出新的奇环，这样该边就不合法了，因为我们删去这条边需要删掉所有的奇环

所以我们得到统计方法:

对于没有奇环的图，每条边都是合法边

对于存在奇环的图，对于树边，如果该边被奇环覆盖的次数等于统计的奇环个数，且该边不被偶环覆盖，那么是合法边。对于非树边，当且仅当只有一个奇环，且该树边构成这个奇环时才合法



## 图匹配
### 基础概念
匹配：

对于一张图![image](https://cdn.nlark.com/yuque/__latex/92232bff4c7103ad09227936b16c6ce8.svg),我们有一个边集![image](https://cdn.nlark.com/yuque/__latex/1e280e7010b5095e23f094054f87a116.svg)且满足![image](https://cdn.nlark.com/yuque/__latex/aba4dfa2f9c4ba9e9c330638b99d6c23.svg)中的边两两之间无公共点,那么![image](https://cdn.nlark.com/yuque/__latex/aba4dfa2f9c4ba9e9c330638b99d6c23.svg)称作该图的一个匹配。 在匹配中的边称作匹配边，否则称作非匹配边，同理我们称点为已盖点和未盖点

增广路:

两端都是未盖点的简单路径，且路径上的边满足匹配边和非匹配边交替的路径称作增广路。用边集表示类似于![image](https://cdn.nlark.com/yuque/__latex/9c0d13fa0d55440d835b7ff5c444fd27.svg),用点集表示即![image](https://cdn.nlark.com/yuque/__latex/d9187f838420abb724d8971665dd8264.svg)增广路的意义在于你翻转所有匹配边和非匹配边，得到的匹配边加一。

最大匹配：

在图的所有匹配中，如果一个匹配![image](https://cdn.nlark.com/yuque/__latex/aba4dfa2f9c4ba9e9c330638b99d6c23.svg)包含的元素数量是最多的，那么我们称作最大匹配，特别的，一个图不一定只有一个最大匹配

匹配关键点

在一个图的所有最大匹配中都存在的点称作匹配的关键点

增广路定理：

一个匹配是图的最大匹配当且仅当当前残图上的未盖点和非匹配边不存在增广路

完美匹配：

如果一个匹配![image](https://cdn.nlark.com/yuque/__latex/aba4dfa2f9c4ba9e9c330638b99d6c23.svg)中的边已经涵盖了图上原有的所有点，那么该匹配称作完美匹配

最大权匹配：

当我们的边存在边权时，匹配中边权和最大的匹配称作最大权匹配

最大权完美匹配

即边权和最大的完美匹配

最小点覆盖

对一个图来说，我们用最少的点覆盖所有的边，此时点的数量称作最小点覆盖

最小边覆盖

对一个图来说，我们用最少的边覆盖所有的点，此时边的数量称作最小边覆盖

最大独立集

对一个图来说，我们选出最多的点，满足这些点之间没有边直接相连，此时点的数量称作最大独立集

### 二分图上的匹配
匹配在二分图中将有很好的特殊性质，因此我们把二分图和一般图分开讨论，我们用![image](https://cdn.nlark.com/yuque/__latex/e42c07754723aea945c675a01b63d8dd.svg)表示二分图,![image](https://cdn.nlark.com/yuque/__latex/f1646088a08f26c0428233af85fbb16e.svg)表示左部点的集合，![image](https://cdn.nlark.com/yuque/__latex/0d553f695182dcfd2b452be19bffb3be.svg)表示右部点的集合



特别的如果题目没有帮我们区分左部点和右部点,我们可以二分图染色得到

#### 二分图最大匹配
匈牙利算法：根据增广路的概念和增广路定理，我们只需要朴素的不断寻找增广路即可，直至我们找不到增广路

由此诞生了匈牙利算法，匈牙利算法的原理是对每一个左部的未盖点，我去右部同样寻找一个未盖点与其配对形成增广路，这样匹配数![image](https://cdn.nlark.com/yuque/__latex/565392706b3df9d18b0948722bd70c91.svg)，但算法过程略有不同 ，对于左部点![image](https://cdn.nlark.com/yuque/__latex/f1646088a08f26c0428233af85fbb16e.svg)，假设找到了右部点![image](https://cdn.nlark.com/yuque/__latex/0d553f695182dcfd2b452be19bffb3be.svg)但![image](https://cdn.nlark.com/yuque/__latex/0d553f695182dcfd2b452be19bffb3be.svg)已经匹配，我们尝试递归![image](https://cdn.nlark.com/yuque/__latex/0d553f695182dcfd2b452be19bffb3be.svg)已匹配的左部点![image](https://cdn.nlark.com/yuque/__latex/4b4027618ff47afe8f79c1f10c72149b.svg)使其更换匹配点，如果![image](https://cdn.nlark.com/yuque/__latex/4b4027618ff47afe8f79c1f10c72149b.svg)能找到新匹配点![image](https://cdn.nlark.com/yuque/__latex/a49151a5e9a1b7809fd9d1d6b9746ce4.svg),那么![image](https://cdn.nlark.com/yuque/__latex/4b4027618ff47afe8f79c1f10c72149b.svg)和![image](https://cdn.nlark.com/yuque/__latex/a49151a5e9a1b7809fd9d1d6b9746ce4.svg)配对，![image](https://cdn.nlark.com/yuque/__latex/f1646088a08f26c0428233af85fbb16e.svg)和![image](https://cdn.nlark.com/yuque/__latex/0d553f695182dcfd2b452be19bffb3be.svg)配对。对每一个左部点都进行此操作，最终成功配对数量即最大匹配,复杂度![image](https://cdn.nlark.com/yuque/__latex/f5a32c6742c732a9aec0b1b4817a1111.svg)其中![image](https://cdn.nlark.com/yuque/__latex/df378375e7693bdcf9535661c023c02e.svg)为左部点数量，![image](https://cdn.nlark.com/yuque/__latex/321138a59e6eab0c97c21f05282a80a6.svg)为边的数量，![image](https://cdn.nlark.com/yuque/__latex/4760e2f007e23d820825ba241c47ce3b.svg)为右部点数量，不难发现我们可以使点数少的点为左部来优化时间

在题目中，如果明确了左部点右部点，不能进行二分图染色!

第一个是手动二分图染色版本

```cpp
struct Hungary
{
    int n;
    const std::vector<std::vector<int>> &g;
    std::vector<int> left, right, col;
    bool isBigraph;
    int maxMatch;
    std::vector<int> vis, match; // match记每个右部点匹配的左部点是谁
    int cnt = 0;
    void dfs1(int u) // 二分图染色
    {
        for (auto v : g[u])
        {
            if (col[v] == -1)
            {
                col[v] = col[u] ^ 1;
                if (col[v] == 1)
                {
                    right.push_back(v);
                }
                else
                {
                    left.push_back(v);
                }
                dfs1(v);
            }
            else if (col[u] == col[v])
            {
                isBigraph = false;
                return;
            }
        }
    }
    bool dfs2(int u, int num) // 找增广路
    {
        for (auto v : g[u])
        {
            if (vis[v] == num)
            {
                continue;
            }
            vis[v] = num;
            if (!match[v] or dfs2(match[v], num))
            {
                match[v] = u;
                return true;
            }
        }
        return false;
    }
    Hungary(const std::vector<std::vector<int>> &g) : g(g), n(g.size() - 1), vis(n + 1), match(n + 1)
    {
        isBigraph = 1;
        maxMatch = 0;
        col.assign(n + 1, -1);
        for (int i = 1; i <= n; ++i)
        {
            if (col[i] == -1)
            {
                col[i] = 0;
                left.push_back(i);
                dfs1(i);
            }
        }
        if (isBigraph)
        {
            if (left.size() > right.size())
            {
                std::swap(left, right);
            }
            for (auto i : left)
            {
                ++cnt; // 时间戳优化
                if (dfs2(i, cnt))
                {
                    ++maxMatch;
                }
            }
        }
    }
};

```

第二个是传入图和左部点集版本

```cpp
struct Hungary
{
    int n;
    const std::vector<std::vector<int>> &g;
    std::vector<int> left;
    int maxMatch;
    std::vector<int> vis, match; // match记每个右部点匹配的左部点是谁
    int cnt = 0;
    bool dfs2(int u, int num) // 找增广路
    {
        for (auto v : g[u])
        {
            if (vis[v] == num)
            {
                continue;
            }
            vis[v] = num;
            if (!match[v] or dfs2(match[v], num))
            {
                match[v] = u;
                return true;
            }
        }
        return false;
    }
    Hungary(const std::vector<std::vector<int>> &g, std::vector<int> L) : g(g), n(g.size() - 1), vis(n + 1), match(n + 1)
    {
        left = L;
        maxMatch = 0;
        for (auto i : left)
        {
            ++cnt; // 时间戳优化
            if (dfs2(i, cnt))
            {
                ++maxMatch;
            }
        }
    }
};
```

最大流做法，我们建立超级源点![image](https://cdn.nlark.com/yuque/__latex/55fc237afbe535f7d8434985b848a6a7.svg)和超级汇点![image](https://cdn.nlark.com/yuque/__latex/1553dae3cc5c15cddb4f5b5a367b0aba.svg)，![image](https://cdn.nlark.com/yuque/__latex/55fc237afbe535f7d8434985b848a6a7.svg)向每一个左部点连流量为![image](https://cdn.nlark.com/yuque/__latex/53072c2388d69edc65c2377681e4e87c.svg)的边,每一个右部点向![image](https://cdn.nlark.com/yuque/__latex/1553dae3cc5c15cddb4f5b5a367b0aba.svg)连流量为![image](https://cdn.nlark.com/yuque/__latex/cda341939d66e5fed7df0c8c9c199239.svg)的边，二分图原有边流量置为![image](https://cdn.nlark.com/yuque/__latex/53072c2388d69edc65c2377681e4e87c.svg)，从![image](https://cdn.nlark.com/yuque/__latex/55fc237afbe535f7d8434985b848a6a7.svg)到![image](https://cdn.nlark.com/yuque/__latex/1553dae3cc5c15cddb4f5b5a367b0aba.svg)的最大流即最大匹配，正确性显然

重边并不会影响算法的正确性，因为源点汇点的流量卡死了.

#### **匹配的关键点**
首先我们有朴素算法，即去掉每个点后再次跑最大匹配，看匹配的大小是否改变，但是我们有更优秀的方法

我们给出一个引理:

一个匹配点![image](https://cdn.nlark.com/yuque/__latex/c313da45855d219109d79253e9e4a276.svg)不是关键点，当且仅当存在一条以![image](https://cdn.nlark.com/yuque/__latex/ffd1905f6d4d60accedfa6b91be93ea9.svg)为端点，以匹配边出发的交替链，使得终点为某个未盖点



因此我们得出做法:先跑出最大匹配，然后我们从左边的每一个未盖点出发，给路径上的点打标记，然后左边未被标记的匹配点就是关键点，同理我们可以得到右边的关键点。复杂度![image](https://cdn.nlark.com/yuque/__latex/885872c14b6aac0cc7b5955da32370de.svg)

我们也可以用最大流跑出流网络然后再使用同样的方法得到关键点。

```cpp
class HungaryCriticalPoints
{
private:
    int n;                                  // 顶点数量
    const std::vector<std::vector<int>> &g; // 图的邻接表表示
    std::vector<int> left;                  // 左部点集合
    std::vector<int> matchl;                // 左部点的匹配点 (matchl[u] = v 表示左部点u匹配右部点v)
    std::vector<int> matchr;                // 右部点的匹配点 (matchr[v] = u 表示右部点v匹配左部点u)
    std::vector<int> pos;                   // 标记是左部点 还是右部点 左部点为1 右部点为0

public:
    /**
     * @brief 构造函数，初始化匈牙利算法关键点查找器
     * @param g 图的邻接表表示，g.size() = n+1，顶点编号从1开始
     * @param left 左部点集合
     */
    HungaryCriticalPoints(const std::vector<std::vector<int>> &g, std::vector<int> left)
        : g(g), n(g.size() - 1), left(left)
    {

        // 初始化匹配数组
        pos.resize(n + 1, 0);
        matchl.resize(n + 1, 0);
        matchr.resize(n + 1, 0);
        for (auto x : left) // 左部点标记为1
        {
            pos[x] = 1;
        }
        // 运行匈牙利算法找到最大匹配
        Hungary hungary(g, left);

        // 将匹配结果存入matchl和matchr
        for (int v = 1; v <= n; ++v)
        {
            if (hungary.match[v] != 0)
            {
                matchl[hungary.match[v]] = v;
                matchr[v] = hungary.match[v];
            }
        }
    }

    /**
     * @brief 查找所有关键点
     * @return 返回一个pair，first是左部关键点，second是右部关键点
     */
    std::pair<std::vector<int>, std::vector<int>> findCriticalPoints()
    {
        std::vector<bool> markl(n + 1, false); // 标记左部点是否被访问 未被访问是关键点
        std::vector<bool> markr(n + 1, false); // 标记右部点是否被访问

        // 从所有未匹配点出发进行BFS 左右两边分别做
        std::queue<int> ql, qr;
        for (int i = 1; i <= n; ++i)
        {
            if (pos[i] and matchl[i] == 0)
            {
                ql.push(i);
                markl[i] = 1;
            }
            else if (!pos[i] and matchr[i] == 0) // 未盖点
            {
                qr.push(i);
                markr[i] = 1;
            }
        }
        // BFS标记交替路径上的点
        while (!ql.empty())
        {
            int u = ql.front();
            ql.pop();
            for (auto v : g[u])
            {
                v = matchr[v];
                if (!markl[v])
                {
                    ql.push(v);
                    markl[v] = 1;
                }
            }
        }
        while (!qr.empty())
        {
            int u = qr.front();
            qr.pop();
            for (auto v : g[u])
            {
                v = matchl[v];
                if (!markr[v])
                {
                    qr.push(v);
                    markr[v] = 1;
                }
            }
        }
        // 收集关键点
        std::vector<int> leftCritical, rightCritical;
        for (int i = 1; i <= n; ++i)
        {
            if (pos[i] and !markl[i])
            {
                leftCritical.push_back(i);
            }
            else if (!pos[i] and !markr[i])
            {
                rightCritical.push_back(i);
            }
        }
        return {leftCritical, rightCritical};
    }
};

```

二分图最大匹配的性质

最大匹配![image](https://cdn.nlark.com/yuque/__latex/6cbf0a6b25529fca1e82691407feb43e.svg)最小点覆盖  

最大匹配![image](https://cdn.nlark.com/yuque/__latex/6cbf0a6b25529fca1e82691407feb43e.svg)![image](https://cdn.nlark.com/yuque/__latex/7f973e795fdff942207e4bc77de8c7cc.svg)最大独立集

最大匹配![image](https://cdn.nlark.com/yuque/__latex/6cbf0a6b25529fca1e82691407feb43e.svg)![image](https://cdn.nlark.com/yuque/__latex/7f973e795fdff942207e4bc77de8c7cc.svg)最小边覆盖![image](https://cdn.nlark.com/yuque/__latex/2aec6631d01238e01f7c7604953768c5.svg)孤立点数

![image](https://cdn.nlark.com/yuque/__latex/bf1f8ad2dca85c4e0b6d11d2007a4884.svg)定理:

对于一个二分图![image](https://cdn.nlark.com/yuque/__latex/a7dc749e1a082363961ee27f0d98d0d8.svg),我们设![image](https://cdn.nlark.com/yuque/__latex/55fc237afbe535f7d8434985b848a6a7.svg)为![image](https://cdn.nlark.com/yuque/__latex/f1646088a08f26c0428233af85fbb16e.svg)的一个子集，![image](https://cdn.nlark.com/yuque/__latex/b8b13c8881e15f236c8f1aac122c5a06.svg)为![image](https://cdn.nlark.com/yuque/__latex/55fc237afbe535f7d8434985b848a6a7.svg)的一个邻集，即![image](https://cdn.nlark.com/yuque/__latex/55fc237afbe535f7d8434985b848a6a7.svg)所有相邻点的集合，总有![image](https://cdn.nlark.com/yuque/__latex/ae2cfc51acbee2e00d4fc2f760bbb627.svg),也就是说左部点的子集的邻集元素数量不小于子集的元素数量

![image](https://cdn.nlark.com/yuque/__latex/c7d5ca93d70cba157f2157353880c97b.svg)定理加强描述：

更强的结论是，![image](https://cdn.nlark.com/yuque/__latex/f8df64a4bfdeb9bdcbc357668b6fb123.svg)的最大匹配为![image](https://cdn.nlark.com/yuque/__latex/8145cfed3379c0d8b0b7a98eb226eab0.svg)



最小点覆盖的构造方法:对于左部每个未匹配点，出发走交替路，给经过的所有点打标记。那么最小点覆盖的点集为:左部所有不可达点和右部所有可达点

最大独立集的构造方法:即最小点覆盖的补集

最小边覆盖的构造方法:未匹配点随机选一条出边即可

#### 二分图最大多重匹配
也即我们对![image](https://cdn.nlark.com/yuque/__latex/77c3adce895348f6083c425fe1ba2624.svg)点设一个变量![image](https://cdn.nlark.com/yuque/__latex/552ec54ab61a59a31630e5e3a751b487.svg)，代表![image](https://cdn.nlark.com/yuque/__latex/77c3adce895348f6083c425fe1ba2624.svg)点不能与超过![image](https://cdn.nlark.com/yuque/__latex/552ec54ab61a59a31630e5e3a751b487.svg)条边相连,一般的最大匹配中![image](https://cdn.nlark.com/yuque/__latex/0340f54849cdcd8533ab451738b6c74f.svg)

我们只需要把![image](https://cdn.nlark.com/yuque/__latex/8bc1cbdd1810e9560abd46d165b48f2e.svg),![image](https://cdn.nlark.com/yuque/__latex/de352194efce7a046273afbd404416ae.svg)的流量改为对应的![image](https://cdn.nlark.com/yuque/__latex/552ec54ab61a59a31630e5e3a751b487.svg)跑最大流即可

#### 二分图带权最大匹配
对于最大权或者最小权最大匹配，我们改最大流为最大费用最大流或最小费用最大流

#### 二分图最大权完美匹配
我们用![image](https://cdn.nlark.com/yuque/__latex/f34d7db360b2de397aec04fd6eec2cee.svg)算法在![image](https://cdn.nlark.com/yuque/__latex/a77815a52a2d0050828079fb142b1410.svg)的时间复杂度内解决该问题

我们默认左部右部点数量相等，否则将是最大权匹配

需要注意的是，如果题目存在负边权，那么不存在的边视作负无穷大，否则视作![image](https://cdn.nlark.com/yuque/__latex/22d0feea96d3bb2fc273f7598ce748c1.svg)

首先我们为每个点赋一个权值![image](https://cdn.nlark.com/yuque/__latex/552ec54ab61a59a31630e5e3a751b487.svg)称作顶标,要求对于所有的边![image](https://cdn.nlark.com/yuque/__latex/8ab4e50c20d37aabf90503557085f344.svg)，都满足![image](https://cdn.nlark.com/yuque/__latex/4f85c6bce17e01513e42357d8c141a71.svg)

然后我们引出相等子图的概念，相等子图即只包含满足![image](https://cdn.nlark.com/yuque/__latex/772d0db3dd9507de5cdda318afc81668.svg)的边的子图

然后我们有定理：如果相等子图存在完美匹配，那么该匹配为最大权完美匹配



所以求解最大权完美匹配的过程实际上是一个不断调整顶标的过程

我们初始化左部点顶标为对应出边最大值，右部点顶标为0

我们先给出类似匈牙利算法的朴素思想，每次搜索假设我们左部点为![image](https://cdn.nlark.com/yuque/__latex/77c3adce895348f6083c425fe1ba2624.svg)，我们遍历其所有出边，如果右部点![image](https://cdn.nlark.com/yuque/__latex/a770a282bbfa0ae1ec474b7ed311656d.svg)已被访问则跳过，否则检测该边是否在相等子图中，如果在子图中未被匹配或者递归可以更换匹配点的话（和匈牙利类似）,我们返回增广成功的信息.如果不在子图中，我们更新右部点的![image](https://cdn.nlark.com/yuque/__latex/a7a1b1829bda27dfb0f727b76eaef9e5.svg)值

然后取![image](https://cdn.nlark.com/yuque/__latex/56c1b0cb7a48ccf9520b0adb3c8cb2e8.svg)为所有未访问右部点的最小![image](https://cdn.nlark.com/yuque/__latex/a7a1b1829bda27dfb0f727b76eaef9e5.svg)值，访问过的左部点顶标减去![image](https://cdn.nlark.com/yuque/__latex/56c1b0cb7a48ccf9520b0adb3c8cb2e8.svg),右部点加上![image](https://cdn.nlark.com/yuque/__latex/bbda4b4bfcbe427652cba3802bf10f31.svg),对每个点进行此循环直至成功为止，最终的所有顶标和即为最大权,![image](https://cdn.nlark.com/yuque/__latex/334bf7f9fbfc3c59c720822be88ca237.svg)数组即为匹配情况，用![image](https://cdn.nlark.com/yuque/__latex/3554585ecb04a4bf73b5938d239b0fe5.svg)实现复杂度![image](https://cdn.nlark.com/yuque/__latex/13d0e318733fc4608fb59d358524fc3b.svg)

```cpp
template <class T>
class KuhnMunkres
{
private:
    const T low = std::numeric_limits<T>::min() / 2;
    const T high = std::numeric_limits<T>::max() / 2;
    int n;                             // 顶点数量
    std::vector<std::vector<T>> graph; // 邻接矩阵表示的带权二分图
    std::vector<T> A;                  // 左部顶点的顶标
    std::vector<T> B;                  // 右部顶点的顶标
    std::vector<int> match;            // 匹配结果，match[v] = u表示右部点v匹配左部点u
    std::vector<T> slack;              // 松弛量数组
    std::vector<int> vis;
    // 访问标记数组

    /**
     * @brief DFS寻找增广路
     * @param u 当前尝试匹配的左部顶点
     * @return 是否找到增广路
     */
    bool dfs(int u)
    {
        for (int v = 1; v <= n; ++v)
        {
            if (vis[v])
                continue; // 右部顶点已访问过

            if (A[u] + B[v] == graph[u][v])
            { // 满足相等子图条件
                vis[v] = true;
                if (!match[v] || dfs(match[v]))
                {                 // 如果v未匹配或可以找到增广路
                    match[v] = u; // 更新匹配
                    return true;
                }
            }
            else
            {
                // 更新松弛量
                slack[v] = std::min(slack[v], A[u] + B[v] - graph[u][v]);
            }
        }
        return false;
    }

public:
    /**
     * @brief 构造函数，初始化KM算法
     * @param n 顶点数量
     * @param edges 边的三元组(u, v, w)列表
     */
    KuhnMunkres(int n, const std::vector<std::tuple<int, int, int>> &edges)
        : n(n), graph(n + 1, std::vector<T>(n + 1, low)),
          A(n + 1, low), B(n + 1, 0),
          match(n + 1, 0), slack(n + 1, high), vis(n + 1, 0)
    {

        // 初始化邻接矩阵
        for (const auto &[u, v, w] : edges)
        {
            graph[u][v] = w;
        }

        // 初始化左部顶标为出边最大权值
        for (int u = 1; u <= n; ++u)
        {
            for (int v = 1; v <= n; ++v)
            {
                A[u] = std::max(A[u], graph[u][v]);
            }
        }
    }

    /**
     * @brief 计算最大权完美匹配
     * @return 匹配结果和总权重
     */
    std::pair<std::vector<int>, T> solve()
    {
        for (int u = 1; u <= n; ++u)
        { // 为每个左部顶点寻找匹配
            while (true)
            {
                // 每次尝试前重置访问标记和松弛量
                std::fill(vis.begin(), vis.end(), 0);
                std::fill(slack.begin(), slack.end(), high);

                if (dfs(u))
                    break; // 找到增广路则退出

                // 计算最小的松弛量d
                T d = high;
                for (int v = 1; v <= n; ++v)
                {
                    if (!vis[v])
                    {
                        d = std::min(d, slack[v]);
                    }
                }

                // 调整顶标
                for (int v = 1; v <= n; ++v)
                {
                    if (vis[v])
                    { // 在增广路中的右部顶点
                        B[v] += d;
                        A[match[v]] -= d;
                    }
                }
                A[u] -= d; // 调整当前左部顶点的顶标
            }
        }

        // 计算总权重
        T totalWeight = 0;
        for (int v = 1; v <= n; ++v)
        {
            if (match[v] > 0)
            {
                totalWeight += graph[match[v]][v];
            }
        }

        return {match, totalWeight};
    }
};
```

我们考虑继续优化，发现调整顶标后重新搜索十分浪费时间,我们考虑改![image](https://cdn.nlark.com/yuque/__latex/3554585ecb04a4bf73b5938d239b0fe5.svg)为![image](https://cdn.nlark.com/yuque/__latex/0c86b50bf23d4de38f21c0ef89918da0.svg),具体的说就是利用了交错树遗留的信息优化了复杂度，时间复杂度为![image](https://cdn.nlark.com/yuque/__latex/a77815a52a2d0050828079fb142b1410.svg),实际上![image](https://cdn.nlark.com/yuque/__latex/0c86b50bf23d4de38f21c0ef89918da0.svg)的过程并不好理解，卡![image](https://cdn.nlark.com/yuque/__latex/3554585ecb04a4bf73b5938d239b0fe5.svg)的题目也并不多

```cpp
template <class T>
class KuhnMunkresBFS
{
private:
    const T low = std::numeric_limits<T>::min() / 2;
    const T high = std::numeric_limits<T>::max() / 2;
    int n;                             // 顶点数量
    std::vector<std::vector<T>> graph; // 邻接矩阵表示的带权二分图
    std::vector<T> A;                  // 左部顶点的顶标
    std::vector<T> B;                  // 右部顶点的顶标
    std::vector<int> match;            // 匹配结果，match[v] = u表示右部点v匹配左部点u
    std::vector<T> slack;              // 松弛量数组
    std::vector<int> vis;              // 访问标记数组
    std::vector<int> pre;              // 前驱数组，用于记录增广路径

    /**
     * @brief BFS寻找增广路
     * @param u 起始的左部顶点
     */
    void bfs(int u)
    {
        std::fill(vis.begin(), vis.end(), 0);        // 重置访问标记
        std::fill(slack.begin(), slack.end(), high); // 重置松弛量

        int x = u, y = 0; // x:当前左部点，y:当前右部点
        match[0] = u;     // 哨兵值，便于后续处理

        while (true)
        {
            vis[y] = true; // 标记当前右部点已访问

            // 寻找最小松弛量和对应的右部点
            T minSlack = high;
            int nextY = 0;

            for (int i = 1; i <= n; ++i)
            {
                if (vis[i])
                    continue; // 跳过已访问的右部点

                // 计算当前松弛量
                T currentSlack = A[x] + B[i] - graph[x][i];

                // 更新松弛量数组和前驱
                if (currentSlack < slack[i])
                {
                    slack[i] = currentSlack;
                    pre[i] = y; // 记录前驱
                }

                // 跟踪最小松弛量
                if (slack[i] < minSlack)
                {
                    minSlack = slack[i];
                    nextY = i;
                }
            }

            // 调整顶标
            A[u] -= minSlack; // 调整起始左部点顶标

            for (int i = 1; i <= n; ++i)
            {
                if (vis[i])
                {
                    // 对于已访问的右部点，调整其和匹配左部点的顶标
                    B[i] += minSlack;
                    A[match[i]] -= minSlack;
                }
                else
                {
                    // 对于未访问的右部点，减少松弛量
                    slack[i] -= minSlack;
                }
            }

            y = nextY; // 移动到最小松弛量对应的右部点

            if (match[y] == 0)
                break; // 找到未匹配点，可以增广

            x = match[y]; // 继续从匹配的左部点开始搜索
        }

        // 更新匹配关系
        while (y != 0)
        {
            match[y] = match[pre[y]]; // 沿着前驱链回溯更新匹配
            y = pre[y];
        }
    }

public:
    /**
     * @brief 构造函数，初始化KM算法
     * @param n 顶点数量
     * @param edges 边的三元组(u, v, w)列表
     */
    KuhnMunkresBFS(int n, const std::vector<std::tuple<int, int, int>> &edges)
        : n(n), graph(n + 1, std::vector<T>(n + 1, low)),
          A(n + 1, low), B(n + 1, 0),
          match(n + 1, 0), slack(n + 1), vis(n + 1), pre(n + 1)
    {

        // 初始化邻接矩阵
        for (const auto &[u, v, w] : edges)
        {
            graph[u][v] = w;
        }

        // 初始化左部顶标为出边最大权值
        for (int u = 1; u <= n; ++u)
        {
            for (int v = 1; v <= n; ++v)
            {
                if (graph[u][v] > A[u])
                {
                    A[u] = graph[u][v];
                }
            }
        }
    }

    /**
     * @brief 计算最大权完美匹配
     * @return 匹配结果和总权重
     */
    std::pair<std::vector<int>, T> solve()
    {
        for (int u = 1; u <= n; ++u)
        {
            bfs(u); // 为每个左部顶点寻找匹配
        }

        // 计算总权重
        T totalWeight = 0;
        for (int v = 1; v <= n; ++v)
        {
            if (match[v] > 0)
            {
                totalWeight += graph[match[v]][v];
            }
        }

        return {match, totalWeight};
    }
};
```

#### 二分图最大权匹配
我们只需要将点数少的一边补足点，并且补满边权为![image](https://cdn.nlark.com/yuque/__latex/22d0feea96d3bb2fc273f7598ce748c1.svg)或者负无穷大的边，即可跑![image](https://cdn.nlark.com/yuque/__latex/a5ad9b60959a3a686d65b2d4497bdd35.svg)算法求最大权完美匹配

### 一般图最大匹配
在最大匹配的基础上，代码求出了匹配必需点（可能用于一般图上博弈）。

```cpp
#include <bits/stdc++.h>
using namespace std;

struct Edmonds
{
    int n;
    vector<vector<int>> g;
    vector<int> match, base, p, q, inq, inb, ed;

    Edmonds(int n) : n(n), g(n) {}

    void addEdge(int u, int v)
    {
        g[u].push_back(v);
        g[v].push_back(u);
    }

    int lca(int a, int b, vector<int> &mark)
    {
        fill(mark.begin(), mark.end(), 0);
        while (true)
        {
            a = base[a];
            mark[a] = 1;
            if (match[a] == -1)
                break;
            a = p[match[a]];
        }
        while (true)
        {
            b = base[b];
            if (mark[b])
                return b;
            if (match[b] == -1)
                break;
            b = p[match[b]];
        }
        return -1;
    }

    void markPath(int v, int b, int x)
    {
        while (base[v] != b)
        {
            inb[base[v]] = inb[base[match[v]]] = 1;
            p[v] = x;
            x = match[v];
            v = p[match[v]];
        }
    }

    int findPath(int root)
    {
        inq.assign(n, 0);
        p.assign(n, -1);
        iota(base.begin(), base.end(), 0);
        int qh = 0, qt = 0;
        q[qt++] = root;
        inq[root] = 1;
        while (qh < qt)
        {
            int v = q[qh++];
            for (int u : g[v])
                if (base[v] != base[u] && match[v] != u)
                {
                    if ((u == root) || (match[u] != -1 && p[match[u]] != -1))
                    {
                        int curbase = lca(v, u, ed);
                        fill(inb.begin(), inb.end(), 0);
                        markPath(v, curbase, u);
                        markPath(u, curbase, v);
                        for (int i = 0; i < n; i++)
                            if (inb[base[i]])
                            {
                                base[i] = curbase;
                                if (!inq[i])
                                    q[qt++] = i, inq[i] = 1;
                            }
                    }
                    else if (p[u] == -1)
                    {
                        p[u] = v;
                        if (match[u] == -1)
                        {
                            while (u != -1)
                            {
                                v = p[u];
                                int w = match[v];
                                match[v] = u;
                                match[u] = v;
                                u = w;
                            }
                            return 1;
                        }
                        else
                        {
                            q[qt++] = match[u];
                            inq[match[u]] = 1;
                        }
                    }
                }
        }
        return 0;
    }

    int maxMatching()
    {
        match.assign(n, -1);
        base.resize(n);
        q.resize(n);
        inb.resize(n);
        ed.resize(n);
        int res = 0;
        for (int i = 0; i < n; i++)
            if (match[i] == -1)
                res += findPath(i);
        return res;
    }

    // 返回所有必需点
    vector<int> essentialVertices()
    {
        int M = maxMatching();

        // Dulmage–Mendelsohn 分解
        vector<int> vis(n, 0);
        queue<int> que;
        for (int i = 0; i < n; i++)
            if (match[i] == -1)
            {
                que.push(i);
                vis[i] = 1;
            }

        while (!que.empty())
        {
            int v = que.front();
            que.pop();
            for (int u : g[v])
            {
                int m = match[u];
                if (!vis[u])
                {
                    vis[u] = 1;
                    if (m != -1 && !vis[m])
                    {
                        vis[m] = 1;
                        que.push(m);
                    }
                }
            }
        }

        // 必需点：未被交替树覆盖的点
        vector<int> ans;
        for (int i = 0; i < n; i++)
        {
            if (!vis[i])
                ans.push_back(i);
        }
        return ans;
    }
};

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int n, m;
    cin >> n >> m;
    Edmonds solver(n);
    for (int i = 0; i < m; i++)
    {
        int u, v;
        cin >> u >> v;
        --u;
        --v;
        solver.addEdge(u, v);
    }
    std::cout << solver.maxMatching() << '\n';
    auto t = solver.match;
    for (int i = 0; i < t.size(); ++i)
    {
        std::cout << t[i] + 1 << " \n"[i + 1 == t.size()];
    }
}

```

## 环计数问题
### 无向图三元环计数
<font style="color:rgba(0, 0, 0, 0.87);">首先给所有边定向。我们规定从度数小的点指向度数大的点，度数相同就从编号小的点指向编号大的点。那么此时此图是一张有向无环图。</font>

<font style="color:rgba(0, 0, 0, 0.87);">然后我们枚举所有的点</font>![image](https://cdn.nlark.com/yuque/__latex/0a25ff5d5f49aeb7283b1b06cf5b55d5.svg)<font style="color:rgba(0, 0, 0, 0.87);">和</font>![image](https://cdn.nlark.com/yuque/__latex/0a25ff5d5f49aeb7283b1b06cf5b55d5.svg)<font style="color:rgba(0, 0, 0, 0.87);">的出点</font>![image](https://cdn.nlark.com/yuque/__latex/e09917a14d880b13df0d5472af943033.svg)<font style="color:rgba(0, 0, 0, 0.87);">,再枚举</font>![image](https://cdn.nlark.com/yuque/__latex/a770a282bbfa0ae1ec474b7ed311656d.svg)<font style="color:rgba(0, 0, 0, 0.87);">的出点</font>![image](https://cdn.nlark.com/yuque/__latex/c9b08ae6d9fed72562880f75720531bc.svg)<font style="color:rgba(0, 0, 0, 0.87);">，检查</font>![image](https://cdn.nlark.com/yuque/__latex/c9b08ae6d9fed72562880f75720531bc.svg)<font style="color:rgba(0, 0, 0, 0.87);">和</font>![image](https://cdn.nlark.com/yuque/__latex/77c3adce895348f6083c425fe1ba2624.svg)<font style="color:rgba(0, 0, 0, 0.87);">是否联通即可。</font>

<font style="color:rgba(0, 0, 0, 0.87);"></font>

<font style="color:rgba(0, 0, 0, 0.87);">可以证明复杂度为</font>![image](https://cdn.nlark.com/yuque/__latex/8a41560ecbe8fafce870a62aad563e5e.svg)

```cpp
class TriangleCounter
{
private:
    std::vector<std::vector<int>> adj;
    int n;
    int m;

public:
    // 构造函数：接收顶点数和边数
    TriangleCounter(int vertices, int edges) : n(vertices), m(edges), adj(n + 1) {}

    // 添加边到图中
    void addEdge(int u, int v)
    {
        adj[u].push_back(v);
        adj[v].push_back(u);
    }

    // 计算图中三角形的数量
    int countTriangles() const
    {
        int ans = 0;
        std::vector<int> vis(n + 1, 0);

        // 遍历每个顶点
        for (int u = 1; u <= n; ++u)
        {
            // 第一阶段：标记满足条件的邻接点
            for (int v : adj[u])
            {
                if (shouldPointTo(u, v))
                {
                    vis[v] = u;
                }
            }

            // 第二阶段：查找三角形
            for (int v : adj[u])
            {
                if (shouldPointTo(u, v))
                {
                    for (int w : adj[v])
                    {
                        if (shouldPointTo(v, w) && vis[w] == u)
                        {
                            ++ans;
                        }
                    }
                }
            }
        }

        return ans;
    }

private:
    // 判断边的方向：度数大的点指向度数小的点，或者度数相同则编号大的点指向编号小的点
    bool shouldPointTo(int u, int v) const
    {
        return adj[u].size() > adj[v].size() ||
               (adj[u].size() == adj[v].size() && u > v);
    }
};
```

### 无向图四元环计数
<font style="color:rgba(0, 0, 0, 0.87);">类似地，</font><font style="color:rgba(0, 0, 0, 0.87);">四元环</font><font style="color:rgba(0, 0, 0, 0.87);"> 就是指四个点 </font>![image](https://cdn.nlark.com/yuque/__latex/9da8370cf72503652b4970d03ccb7899.svg)<font style="color:rgba(0, 0, 0, 0.87);">满足 </font>![image](https://cdn.nlark.com/yuque/__latex/3dda81c9818fb43f7f2d6ea46d140ac9.svg)<font style="color:rgba(0, 0, 0, 0.87);"> 均有边连接。</font>

<font style="color:rgba(0, 0, 0, 0.87);">考虑先对点进行排序。度数小的排在前面，度数大的排在后面。</font>

<font style="color:rgba(0, 0, 0, 0.87);">考虑枚举排在最后面的点 </font>![image](https://cdn.nlark.com/yuque/__latex/26fdbf8e53cb0e48da5f4ddd4aaf5a5c.svg)<font style="color:rgba(0, 0, 0, 0.87);">，此时只需要对于每个比</font>![image](https://cdn.nlark.com/yuque/__latex/26fdbf8e53cb0e48da5f4ddd4aaf5a5c.svg)<font style="color:rgba(0, 0, 0, 0.87);"> 排名更前的点 </font>![image](https://cdn.nlark.com/yuque/__latex/b891664b42113aee13f0bac25eb998e5.svg)<font style="color:rgba(0, 0, 0, 0.87);">，都求出有多少个排名比</font>![image](https://cdn.nlark.com/yuque/__latex/26fdbf8e53cb0e48da5f4ddd4aaf5a5c.svg)<font style="color:rgba(0, 0, 0, 0.87);">前的点</font>![image](https://cdn.nlark.com/yuque/__latex/e3b1a1ba9d491cc6835e70607ead3750.svg)<font style="color:rgba(0, 0, 0, 0.87);">满足</font>![image](https://cdn.nlark.com/yuque/__latex/720b0793de6f4604c6f546d8236dec70.svg)<font style="color:rgba(0, 0, 0, 0.87);">有边。然后只需要这些中任取两个都能成为一个四元环。求</font>![image](https://cdn.nlark.com/yuque/__latex/e3b1a1ba9d491cc6835e70607ead3750.svg)<font style="color:rgba(0, 0, 0, 0.87);">的数量只需要遍历一遍</font>![image](https://cdn.nlark.com/yuque/__latex/d29c2e5f4926e5b0e9a95305650f6e54.svg)<font style="color:rgba(0, 0, 0, 0.87);">和</font>![image](https://cdn.nlark.com/yuque/__latex/b891664b42113aee13f0bac25eb998e5.svg)<font style="color:rgba(0, 0, 0, 0.87);">即可。</font>

<font style="color:rgba(0, 0, 0, 0.87);">注意到我们枚举的复杂度本质上与枚举三元环等价，所以时间复杂度相同。</font>

<font style="color:rgba(0, 0, 0, 0.87);">值得注意的是，</font>![image](https://cdn.nlark.com/yuque/__latex/781962325050e431f95344ed2505c43b.svg)<font style="color:rgba(0, 0, 0, 0.87);">和</font>![image](https://cdn.nlark.com/yuque/__latex/add5337a2f9427b997be33b14e762d1a.svg)<font style="color:rgba(0, 0, 0, 0.87);">可以是两个不同的四元环。</font>

<font style="color:rgba(0, 0, 0, 0.87);">另外，度数相同的结点的排名将不相同，并且需要注意判断</font>![image](https://cdn.nlark.com/yuque/__latex/989e91f43965de1d53363d7a193c0175.svg)

```cpp

class SquareCounter
{
private:
    int n;                            // 顶点数
    std::vector<int> deg;             // 顶点度数
    std::vector<std::vector<int>> E;  // 原始无向图邻接表
    std::vector<std::vector<int>> E1; // 有向图邻接表（度数大→小，或编号大→小）
    std::vector<int> cnt;             // 临时计数器

public:
    // 构造函数：初始化图的大小
    explicit SquareCounter(int vertices)
        : n(vertices), deg(n + 1), E(n + 1), E1(n + 1), cnt(n + 1) {}

    // 添加边到图中
    void addEdge(int u, int v)
    {
        E[u].push_back(v);
        E[v].push_back(u);
        deg[u]++;
        deg[v]++;
    }

    // 计算图中三角形数量
    int count()
    {
        buildDirectedGraph();
        return calc();
    }

private:
    // 构建有向图E1：度数大的点指向度数小的点，度数相同则编号大的点指向编号小的点
    void buildDirectedGraph()
    {
        for (int u = 1; u <= n; ++u)
        {
            for (int v : E[u])
            {
                if (deg[u] > deg[v] || (deg[u] == deg[v] && u > v))
                {
                    E1[u].push_back(v);
                }
            }
        }
    }

    // 处理并计算三角形数量
    int calc()
    {
        int ans = 0;
        for (int a = 1; a <= n; ++a)
        {
            // 遍历a的所有有向边邻居b
            for (int b : E1[a])
            {
                // 遍历b的所有邻居c
                for (int c : E[b])
                {
                    // 检查c是否满足条件：度数小于a或度数相同但编号小于a
                    if (deg[c] < deg[a] || (deg[c] == deg[a] && c < a))
                    {
                        ans += cnt[c]++;
                    }
                }
            }
            // 重置计数器
            for (int b : E1[a])
            {
                for (int c : E[b])
                {
                    cnt[c] = 0;
                }
            }
        }
        return ans;
    }
};

```

## 最大团与最大独立集
考虑到最大独立集是补图的最大团，因此我们只需要考虑怎么求最大团。



我们考虑求最大团并计数



![image](https://cdn.nlark.com/yuque/__latex/56efd6d97976bd4b9489e073616adfcb.svg)折半搜索

我们考虑折半搜索，对前半部分，我们求出每个子集![image](https://cdn.nlark.com/yuque/__latex/55fc237afbe535f7d8434985b848a6a7.svg)对应的最大团，以及对应的数量。这个操作可以使用高维前缀和完成，复杂度为![image](https://cdn.nlark.com/yuque/__latex/79cd1fe651294105d803e4ba6b8cc0f3.svg),但我们发现我们可以考虑线性递推，具体的说，我们每次拿出![image](https://cdn.nlark.com/yuque/__latex/55fc237afbe535f7d8434985b848a6a7.svg)对应最低的位，考虑该位对应的点选不选即可。因此复杂度降为![image](https://cdn.nlark.com/yuque/__latex/23b542458229a1e9913bd7c32fb1d955.svg)。对后半部分，我们只考虑判断每个子集是否为团，然后找出和前半部分的兼容掩码，更新答案即可，最终复杂度![image](https://cdn.nlark.com/yuque/__latex/23b542458229a1e9913bd7c32fb1d955.svg)

```cpp
using ll = long long;
struct Result
{
    int size;               // 最大规模（顶点数量）
    ll count;               // 解的总数量（所有满足最大规模的子集个数）
    std::vector<int> nodes; // 其中一个具体解（顶点编号集合）
};

// 图求解器类：封装最大团和最大独立集的求解逻辑
class GraphSolver
{
private:
    int n;                              // 图的顶点总数（顶点编号从1开始）
    std::vector<std::vector<bool>> adj; // 邻接矩阵：adj[u][v] = true 表示u和v之间有边
    std::vector<int> pop;               // 预处理的位计数表：popCount[mask] = mask二进制中1的个数（快速计算子集大小）
    std::vector<int> log2;              // 预处理的低位1位置表：log2[lowbit] = 该低位1对应的幂次+1（快速定位顶点编号）
    const int bit = 25;                 // 最大位宽限制：确保log2表覆盖足够的掩码范围（1<<25可满足n≤50的场景）

public:
    // 构造函数：初始化顶点数量和邻接矩阵
    // 参数n：图的顶点总数
    GraphSolver(int n) : n(n), adj(n + 1, std::vector<bool>(n + 1, false))
    {
        // 1. 预处理位计数表popCount
        // 最大掩码长度为前半部分顶点数：(n+1)/2（折半搜索的前半段）
        int maxMask = 1 << ((n + 1) / 2);
        pop.resize(maxMask, 0);
        // 递推计算每个掩码的1的个数：mask的1的个数 = (mask去掉最低位1后的掩码)的1的个数 + 1
        for (int i = 1; i < maxMask; ++i)
        {
            pop[i] = pop[i ^ (i & -i)] + 1;
        }
        // 2. 预处理log2表（定位最低位1对应的顶点）
        log2.resize(1 << bit, 0);
        // 对于2^i的掩码，其最低位1在第i位，对应顶点编号i+1（因顶点从1开始）
        for (int i = 0; i < bit; ++i)
        {
            log2[1 << i] = i + 1;
        }
    }
    void addEdge(int u, int v)
    {
        adj[u][v] = true; // u到v有边
        adj[v][u] = true; // 无向图，v到u也有边
    }
    Result solve0() // 最大团
    {
        return solve(false);
    }
    Result solve1()
    {
        return solve(true);
    }

private:
    // 核心求解函数：统一处理最大团（原图）和最大独立集（补图）
    Result solve(bool ok)
    {
        std::vector<std::vector<bool>> cur; // 当前使用的邻接矩阵（原图或补图）
        if (ok)
        {
            // 构建补图：补图中u和v有边 ↔ 原图中u和v无边（自身环设为true，不影响团的判断）
            cur.resize(n + 1, std::vector<bool>(n + 1, false));
            for (int i = 1; i <= n; ++i)
            {
                for (int j = 1; j <= n; ++j)
                {
                    if (i == j)
                    {
                        cur[i][j] = true; // 自身环不影响团（团要求任意两点有边，自身无需考虑）
                    }
                    else
                    {
                        cur[i][j] = !adj[i][j]; // 补图边 = 原图边取反
                    }
                }
            }
        }
        else
        {
            cur = adj; // 求解最大团，直接使用原图邻接矩阵
        }

        // -------------------------- 步骤2：预处理顶点邻接掩码 --------------------------
        int mid = n / 2;                // 折半搜索：将顶点分为前半段（1~mid）和后半段（mid+1~n）
        std::vector<ll> mask(n + 1, 0); // mask[i]：顶点i的邻接顶点掩码（二进制位j=1表示i与j+1有边）
        for (int i = 1; i <= n; ++i)
        {
            for (int j = 1; j <= n; ++j)
            {
                if (cur[i][j])
                {
                    // 将j-1位设为1（因顶点j对应二进制位j-1，从0开始计数）
                    mask[i] |= 1LL << (j - 1);
                }
            }
        }

        // -------------------------- 步骤3：处理前半段顶点（动态规划预处理） --------------------------
        int x = 1 << mid; // 前半段顶点的所有子集数（2^mid个）
        // f[s]：前半段子集s对应的"最优团信息"
        // first：该子集能扩展出的最大团的掩码，second：该最大团的计数
        std::vector<std::pair<int, ll>> f(x);
        f[0] = {0, 1}; // 空集的初始状态：最大团为空（掩码0），计数1
        // 枚举前半段所有非空子集
        for (int s = 1; s < x; ++s)
        {
            int lowbit = s & -s;   // 取子集s的最低位1（对应一个顶点）
            int prev = s ^ lowbit; // 去掉最低位1后的子集（前一个状态）
            int v = log2[lowbit];  // 最低位1对应的顶点编号（从1开始）
            // 两种选择：
            // op1：不选顶点v，直接沿用prev子集的最优团信息
            auto op1 = f[prev];
            // op2：选顶点v，此时需取prev与v邻接的子集（确保v与团中所有顶点有边），再加入v
            auto op2 = f[prev & mask[v]];
            op2.first |= lowbit; // 将v对应的位加入团掩码
            // 选择更优的方案（优先按团大小，再按计数累加）
            if (pop[op2.first] > pop[op1.first])
            {
                // op2的团更大，更新为op2
                f[s] = op2;
            }
            else if (pop[op2.first] == pop[op1.first])
            {
                // 团大小相同，计数累加
                f[s].first = op1.first;
                f[s].second = op1.second + op2.second;
            }
            else
            {
                // op1的团更大，更新为op1
                f[s] = op1;
            }
        }

        // -------------------------- 步骤4：处理后半段顶点（筛选有效团） --------------------------
        int y = 1 << (n - mid);            // 后半段顶点的所有子集数（2^(n-mid)个）
        std::vector<bool> valid(y, false); // valid[s]：标记后半段子集s是否为团
        valid[0] = true;                   // 空集是团
        // 枚举后半段所有非空子集
        for (int s = 1; s < y; ++s)
        {
            int lowbit = s & -s;        // 取子集s的最低位1
            int prev = s ^ lowbit;      // 去掉最低位1后的子集
            int v = log2[lowbit] + mid; // 转换为原顶点编号（后半段顶点从mid+1开始）
            // 判断子集s是否为团：
            // 1. 前一个状态prev是团（valid[prev]为true）
            // 2. 新加入的顶点v与s中所有其他顶点有边（通过掩码判断：s去掉v后的部分都在v的邻接集中）
            valid[s] = valid[prev] && ((prev & ~(mask[v] >> mid)) == 0);
        }

        // -------------------------- 步骤5：合并前后半段结果，找全局最优解 --------------------------
        int maxSize = 0;           // 全局最大团/独立集的规模
        ll count = 0;              // 全局最大解的总数量
        ll bestMask = 0;           // 全局最优解的顶点掩码（二进制位i=1表示顶点i+1在解中）
        std::vector<int> to(y, 0); // to[b]：后半段子集b对应的前半段兼容最大团的掩码

        // 枚举所有有效的后半段团
        for (int b = 0; b < y; ++b)
        {
            if (!valid[b])
                continue; // 跳过非团的子集

            // 计算前半段中与后半段子集b兼容的最大团掩码t：
            // 兼容指：t中的所有顶点与b中的所有顶点都有边
            int t;
            if (b == 0)
            {
                // 后半段是空集，前半段可兼容的最大团是前半段所有顶点（掩码(1<<mid)-1）
                t = (1 << mid) - 1;
            }
            else
            {
                int lowbit = b & -b;        // 取后半段子集b的最低位1
                int prev = b ^ lowbit;      // 去掉最低位1后的子集
                int v = log2[lowbit] + mid; // 转换为原顶点编号
                // 前半段兼容掩码 = 前一个状态的兼容掩码 ∩ v的邻接掩码（确保与新加入的v兼容）
                t = to[prev] & mask[v];
            }
            to[b] = t; // 记录当前后半段子集b对应的前半段兼容掩码
            // 计算当前合并后的团规模和计数
            int curSize = pop[f[t].first] + pop[b]; // 前半段最大团大小 + 后半段团大小
            ll curCount = f[t].second;              // 前半段最大团的计数（后半段团只有1种）
            // 更新全局最优解
            if (curSize > maxSize)
            {
                // 找到更大的解，更新规模、计数和掩码
                maxSize = curSize;
                count = curCount;
                // 合并前后半段掩码：前半段掩码直接用，后半段掩码左移mid位（对应原顶点编号）
                bestMask = f[t].first | (ll(b) << mid);
            }
            else if (curSize == maxSize)
            {
                // 与当前最大规模相同，累加计数
                count += curCount;
            }
        }
        // -------------------------- 步骤6：从最优掩码中提取顶点编号 --------------------------
        std::vector<int> nodes;
        for (int i = 1; i <= n; ++i)
        {
            // 检查第i个顶点是否在最优掩码中（对应二进制位i-1）
            if (bestMask & (1ULL << (i - 1)))
            {
                nodes.push_back(i);
            }
        }
        // 返回求解结果
        return {maxSize, count, nodes};
    }
};
```

![image](https://cdn.nlark.com/yuque/__latex/4b61aa9ca965e7caa9057c4f4e68b0e5.svg) 启发式搜索

我们考虑每次找到最大的度数![image](https://cdn.nlark.com/yuque/__latex/416e9a8046d05a55fd5a31adaf5e6858.svg),如果![image](https://cdn.nlark.com/yuque/__latex/3ee447454557180a1b92216e5f2f00a4.svg)，说明是环或者链，可以通过预处理好的![image](https://cdn.nlark.com/yuque/__latex/18f3c2855f0e85a1ac2257f64d917144.svg)和![image](https://cdn.nlark.com/yuque/__latex/7a1e6a754b7a8e45cb731688765c5e85.svg)解决，否则我们选择度数最大的点递归搜索。

复杂度可以证明，上限为![image](https://cdn.nlark.com/yuque/__latex/d7b9f3a4a77609ee743574bd97c47ef6.svg)，实际运行速度极快

```cpp
#include <bits/stdc++.h>

using u64 = unsigned long long;
const int N = 55; // 最大顶点数量
int n, m;         // 顶点数和边数
int f[N], g[N];   // 存储链和环的方案数
u64 U;            // 表示所有顶点的集合（位掩码）
u64 e[N];         // 邻接表（位掩码形式）

/**
 * 深度优先搜索寻找最大独立集
 * @param S 当前待处理的顶点集合（位掩码）
 * @return  pair<u64, int>  最大独立集及其方案数
 */
std::pair<u64, int> dfs(u64 S)
{
    if (!S)
        return {0, 1}; // 空集处理

    // 选择当前集合中度数最大的顶点作为分支点
    int w = 0, d = -1;
    for (u64 i = S; i; i &= (i - 1))
    {
        int x = __builtin_ctzll(i);
        int t = __builtin_popcountll(e[x] & S); // 计算当前顶点在集合S中的度数
        if (t > d)
        {
            d = t;
            w = x;
        }
    }

    // 处理度数≤2的特殊情况（链或环）
    if (d <= 2)
    {
        u64 v = S, x = 0, s1, s2;
        int y = 1;
        bool O;

        // 内部DFS用于探索连通分量并进行二分图着色
        auto dfs = [&](auto &&sf, int x, bool o) -> void
        {
            v ^= (1ull << x);                           // 标记顶点x为已处理
            (o ? s2 : s1) |= 1ull << x;                 // 按颜色分组
            O &= (__builtin_popcountll(e[x] & S) == 2); // 检查是否为环
            // 递归访问所有未处理的邻居
            while (v & e[x])
            {
                sf(sf, __builtin_ctzll(v & e[x]), o ^ 1);
            }
        };

        // 处理所有连通分量
        while (v)
        {
            s1 = s2 = 0;
            O = 1;                           // 初始假设为环
            dfs(dfs, __builtin_ctzll(v), 0); // 从最低位顶点开始处理

            int a = __builtin_popcountll(s1);
            int b = __builtin_popcountll(s2);
            int num = a + b;

            // 选择最大独立集并累计算法数
            if (O && (num & 1))
            { // 奇环
                x |= (a < b ? s1 : s2);
            }
            else
            { // 偶环或链
                x |= (a > b ? s1 : s2);
            }
            y *= (O ? g : f)[num];
        }
        return {x, y};
    }

    // 常规情况：分支递归
    u64 W = 1ull << w;
    std::pair<u64, int> nw = dfs(S ^ W); // 不选顶点w

    // 选择顶点w（需排除其邻居）
    auto [x, y] = dfs(S & (~(e[w] | W)));
    x |= W;

    // 比较两种情况，选择最优解
    if (__builtin_popcountll(x) > __builtin_popcountll(nw.first))
    {
        nw = {x, y};
    }
    else if (__builtin_popcountll(x) == __builtin_popcountll(nw.first))
    {
        nw.second += y;
    }

    return nw;
}
// 预处理f和g数组（链和环的方案数）
void preprocess()
{
    // f[i]：i个顶点的链的最大独立集方案数
    // g[i]：i个顶点的环的最大独立集方案数
    for (int i = 1; i <= n; ++i)
    {
        f[i] = (i & 1) ? 1 : (i / 2 + 1); // 链的方案数公式
        g[i] = (i & 1) ? i : 2;           // 环的方案数公式
    }
}
void exchange() // 翻转图
{
    for (int i = 0; i < n; ++i)
    {
        // 补图的邻接集 = 全集排除自身和原图邻接集
        e[i] = ((~e[i]) & U) ^ (1ull << i);
    }
}

int main()
{
    std::ios::sync_with_stdio(0);
    std::cin.tie(0);

    std::cin >> n >> m;
    U = (1ull << n) - 1;
    while (m--)
    {
        int u, v;
        std::cin >> u >> v;
        --u;
        --v;
        e[u] |= (1ull << v);
        e[v] |= (1ull << u);
    }
    preprocess();
    exchange();
    auto [val, cnt] = dfs(U);
    std::cout << __builtin_popcountll(val) << ' ' << cnt << '\n';
    while (val)
    {
        std::cout << __builtin_ctzll(val) + 1 << ' ';
        val ^= (val & (-val));
    }
    std::cout << '\n';
    exchange();
    auto [x, y] = dfs(U);
    val = x, cnt = y;
    std::cout << __builtin_popcountll(val) << ' ' << cnt << '\n';
    while (val)
    {
        std::cout << __builtin_ctzll(val) + 1 << ' ';
        val ^= (val & (-val));
    }
}
```

